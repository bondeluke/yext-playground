/** @module @yext/components-404 */

import URI from 'urijs';

/**
 * Query param name for the original referrer to the missing page
 */
const originalReferrerParamName = 'oref';
/**
 * Query param name for the original URL of the missing page
 */
const originalUrlParamName = 'ourl';

/**
 * A function run by LostAndFound that returns a different URL to visit to try to resolve a 404
 * @callback LafHook
 * @param {Object} data
 * @param {string} data.currentUrl The URL of the current page
 * @param {string} data.siteDomain The domain of the current site
 * @returns {string} A URL to try as the intended page
 */

/**
 * Try to find the intended page after a 404
 */
class LostAndFound {
  /**
   * @param {string} url The URL of the missing page
   * @param {string} referrer The URL of the page that linked to the missing page
   * @param {Object} config
   * @param {string} config.destinationUrl The URL to redirect to if the page isn't found
   * @param {boolean} [config.isStaging=false] Whether it is running in a development environment
   * @param {string} [config.pixelUrl] config.pixelUrl The URL of the monitoring pixel
   * @param {string} config.siteDomain The domain of the current site
   * @param {number|string} config.siteId The ID of the current site, included in the monitoring pixel
   * @param {number} [config.timeout=1000] The max number of milliseconds to wait for the pixel to fire before redirecting
   */
  constructor(url, referrer, {
    destinationUrl,
    isStaging = false,
    pixelUrl,
    siteDomain,
    siteId,
    timeout = 1000
  }) {
    this.currentUrl = new URI(url);
    this.destinationUrl = destinationUrl;
    this.isStaging = isStaging;
    this.pixelUrl = pixelUrl;
    this.siteDomain = siteDomain;
    this.siteId = siteId;
    this.timeout = timeout;

    this.originalUrl = url;
    // If the current URL specifies an original url as a parameter, use it instead
    if((this.currentUrl).hasQuery(originalUrlParamName)) {
      this.originalUrl = this.currentUrl.query(true)[originalUrlParamName];
    }

    // If the current URL specifies an original referrer as a parameter, use it instead
    this.originalReferrer = referrer;
    if((this.currentUrl).hasQuery(originalReferrerParamName)) {
      this.originalReferrer = this.currentUrl.query(true)[originalReferrerParamName];
    }

    this.hooks = [];
  }

  // GENERATOR TODO: Put this in a common util spot since we have multiple copies in the codebase
  /**
   * Wrap a callback function in a function that will only run the callback on its first invocation
   * @param {function} task Callback function to run once
   */
  once(task) {
    if (!task)
      return;

    let invoked = false;
    return function() {
      if (invoked)
        return;
      invoked = true;
      task();
    }
  }

  /**
   * Adds a LaF hook function to try before firing the pixel
   * @param {module:@yext/components-404~LafHook} fn
   */
  preHook(fn) {
    this.hooks.push(fn);
  }

  /**
   * Installs hooks {@link module:@yext/components-404~TryLowercase TryLowercase} and {@link module:@yext/components-404~TryParent TryParent}
   * @see module:@yext/components-404~LostAndFound#preHook
   */
  installBasicHooks() {
    this.preHook(TryLowercase);
    this.preHook(TryParent);
  }

  /**
   * Fire a monitoring pixel with site data
   * @param {function} cb Callback to run after the pixel is fired
   */
  firePixel(cb) {
    if (!this.pixelUrl) {
      cb();
      return;
    }

    let pixel = new URI(this.pixelUrl);

    pixel.search({
      siteid: this.siteId,
      staging: this.isStaging,
      referrer: this.originalReferrer,
      url: this.originalUrl
    });

    const trackingImage = document.createElement('img');
    trackingImage.src = pixel.href();

    let onceCB = this.once(cb);
    trackingImage.onload = onceCB;
    trackingImage.onerror = onceCB;
    setTimeout(onceCB, this.timeout);
  }

  /**
   * Redirect to a new URL, preserving query params and hash
   * @param {string} rawUrl The URL to redirect to
   * @param {boolean} [installTrackingParams=false] Whether to add tracking query params for
   *   {@link module:@yext/components-404~originalReferrerParamName original referrer} and {@link module:@yext/components-404~originalUrlParamName original URL}
   */
  redirectTo(rawUrl, installTrackingParams = false) {
    let url = new URI(rawUrl);

     // Inherit any params on the current URL
    url.setSearch(this.currentUrl.search(true));
    url.hash(this.currentUrl.hash());

    if (installTrackingParams) {
      url.setSearch(originalUrlParamName, this.originalUrl);
      url.setSearch(originalReferrerParamName, this.originalReferrer);
    } else {
      // Remove tracking params in case the current url had them
      url.removeSearch(originalUrlParamName);
      url.removeSearch(originalReferrerParamName);
    }

    window.location.replace(url.href());
  }

  /**
   * Run any added hook functions, then if none give a new URL to redirect to, fire a monitoring pixel
   * and redirect to the destination URL
   */
  run() {
    let hookUrl = '';
    for (let hook of this.hooks) {
      hookUrl = hook({
        currentUrl: this.currentUrl.href(),
        siteDomain: this.siteDomain,
      });
      if(hookUrl != '') {
        this.redirectTo(hookUrl, true);
        return;
      }
    }

    this.firePixel(() => {
      if (this.destinationUrl) {
        // No need to preserve params going to our final destination.  While
        // its possible that location will 404, that is assumed to be programmer
        // error.
        this.redirectTo(this.destinationUrl, false);
      }
    });
  }
}

/**
 * Try the current URL with all lowercase letters
 * @member {module:@yext/components-404~LafHook}
 */
function TryLowercase({ currentUrl }) {
  let url = new URI(currentUrl);

  if (url.pathname(true).toLowerCase() != url.pathname(true)) {
    url.pathname(url.pathname(true).toLowerCase());
    return url.href();
  }

  return '';
}

// GENERATOR TODO: validate behavior of this on staging for reverse proxy sites OR
// in prod on the origin domain (not the RP with the folder)
// GENERATOR TODO: we might want to allow for /some/parent/path.html -> /some/parent.html,
// perhaps we can extend this to allow for file extensions
/**
 * Try the parent directory of the current URL
 * @member {module:@yext/components-404~LafHook}
 */
function TryParent({ currentUrl, siteDomain }) {
  // Doesn't change typical subdomains (a.foo.com == a.foo.com/) but allows
  // URI.js to interpret subdirectory reverse proxies to be interpreted as a
  // directory.
  siteDomain = `http://${siteDomain}/`;

  let url = new URI(currentUrl);
  let hostUrl = new URI(siteDomain);

  // Already at the root, can't go any further
  if (url.directory() == '/') {
    return '';
  }

  // At the reverse proxy's root, can't go any further
  if (url.hostname() == hostUrl.hostname() && url.directory() == hostUrl.directory()) {
    return '';
  }

  // Navigate "up" one-level
  url.pathname(url.directory(true));

  return url.href();
}

export {
  LostAndFound,
  TryLowercase,
  TryParent
};
