{"version":3,"file":"jsx-lexer.js","names":["JavascriptLexer","ts","unescape","JsxLexer","_JavascriptLexer","_inherits","_super","_createSuper","_this","options","arguments","length","undefined","_classCallCheck","call","componentFunctions","transSupportBasicHtmlNodes","transKeepBasicHtmlNodesFor","omitAttributes","attr","transIdentityFunctionsToIgnore","_createClass","key","value","extract","content","_this2","filename","keys","parseCommentNode","createCommentNodeParser","parseTree","node","entry","kind","SyntaxKind","CallExpression","expressionExtractor","TaggedTemplateExpression","taggedTemplateExpressionExtractor","JsxElement","jsxExtractor","JsxSelfClosingElement","push","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","keysWithNamespace","setNamespaces","keysWithPrefixes","setKeyPrefixes","sourceText","_this3","tagNode","openingElement","getPropValue","attributeName","_attribute$initialize","attribute","attributes","properties","find","name","text","initializer","expression","Identifier","emit","concat","getKey","includes","tagName","namespace","forEach","property","JsxSpreadAttribute","TrueKeyword","FalseKeyword","nodeAsString","nodeToString","defaultsProp","defaultValue","shouldUnescape","defaultNamespace","_this4","children","parseChildren","elemsToString","map","child","index","type","useTagName","isBasic","elementName","childrenString","selfClosing","Error","join","_this5","JsxText","replace","element","escapedText","hasDynamicChildren","prop","JsxExpression","AsExpression","StringLiteral","ObjectLiteralExpression","nonFormatProperties","filter","formatProperty","slicedExpression","slice","pos","end","default"],"sources":["../../src/lexers/jsx-lexer.js"],"sourcesContent":["import JavascriptLexer from './javascript-lexer.js'\nimport ts from 'typescript'\nimport { unescape } from '../helpers.js'\n\nexport default class JsxLexer extends JavascriptLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.componentFunctions = options.componentFunctions || ['Trans']\n    this.transSupportBasicHtmlNodes =\n      options.transSupportBasicHtmlNodes || false\n    this.transKeepBasicHtmlNodesFor = options.transKeepBasicHtmlNodesFor || [\n      'br',\n      'strong',\n      'i',\n      'p',\n    ]\n    this.omitAttributes = [this.attr, 'ns', 'defaults']\n    this.transIdentityFunctionsToIgnore =\n      options.transIdentityFunctionsToIgnore || []\n  }\n\n  extract(content, filename = '__default.jsx') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      switch (node.kind) {\n        case ts.SyntaxKind.CallExpression:\n          entry = this.expressionExtractor.call(this, node)\n          break\n        case ts.SyntaxKind.TaggedTemplateExpression:\n          entry = this.taggedTemplateExpressionExtractor.call(this, node)\n          break\n        case ts.SyntaxKind.JsxElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n        case ts.SyntaxKind.JsxSelfClosingElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    const keysWithNamespace = this.setNamespaces(keys)\n    const keysWithPrefixes = this.setKeyPrefixes(keysWithNamespace)\n\n    return keysWithPrefixes\n  }\n\n  jsxExtractor(node, sourceText) {\n    const tagNode = node.openingElement || node\n\n    const getPropValue = (node, attributeName) => {\n      const attribute = node.attributes.properties.find(\n        (attr) => attr.name !== undefined && attr.name.text === attributeName\n      )\n      if (!attribute) {\n        return undefined\n      }\n\n      if (attribute.initializer.expression?.kind === ts.SyntaxKind.Identifier) {\n        this.emit(\n          'warning',\n          `\"${attributeName}\" prop is not a string literal: ${attribute.initializer.expression.text}`\n        )\n        return undefined\n      }\n\n      return attribute.initializer.expression\n        ? attribute.initializer.expression.text\n        : attribute.initializer.text\n    }\n\n    const getKey = (node) => getPropValue(node, this.attr)\n\n    if (this.componentFunctions.includes(tagNode.tagName.text)) {\n      const entry = {}\n      entry.key = getKey(tagNode)\n\n      const namespace = getPropValue(tagNode, 'ns')\n      if (namespace) {\n        entry.namespace = namespace\n      }\n\n      tagNode.attributes.properties.forEach((property) => {\n        if (property.kind === ts.SyntaxKind.JsxSpreadAttribute) {\n          this.emit(\n            'warning',\n            `Component attribute is a JSX spread attribute : ${property.expression.text}`\n          )\n          return\n        }\n\n        if (this.omitAttributes.includes(property.name.text)) {\n          return\n        }\n\n        if (property.initializer) {\n          if (property.initializer.expression) {\n            if (\n              property.initializer.expression.kind === ts.SyntaxKind.TrueKeyword\n            ) {\n              entry[property.name.text] = true\n            } else if (\n              property.initializer.expression.kind ===\n              ts.SyntaxKind.FalseKeyword\n            ) {\n              entry[property.name.text] = false\n            } else {\n              entry[\n                property.name.text\n              ] = `{${property.initializer.expression.text}}`\n            }\n          } else {\n            entry[property.name.text] = property.initializer.text\n          }\n        } else entry[property.name.text] = true\n      })\n\n      const nodeAsString = this.nodeToString.call(this, node, sourceText)\n      const defaultsProp = getPropValue(tagNode, 'defaults')\n      let defaultValue = defaultsProp || nodeAsString\n      if (entry.shouldUnescape === true) {\n        defaultValue = unescape(defaultValue)\n      }\n\n      if (defaultValue !== '') {\n        entry.defaultValue = defaultValue\n\n        if (!entry.key) {\n          entry.key = nodeAsString\n        }\n      }\n\n      return entry.key ? entry : null\n    } else if (tagNode.tagName.text === 'Interpolate') {\n      const entry = {}\n      entry.key = getKey(tagNode)\n      return entry.key ? entry : null\n    } else if (tagNode.tagName.text === 'Translation') {\n      const namespace = getPropValue(tagNode, 'ns')\n      if (namespace) {\n        this.defaultNamespace = namespace\n      }\n    }\n  }\n\n  nodeToString(node, sourceText) {\n    const children = this.parseChildren.call(this, node.children, sourceText)\n\n    const elemsToString = (children) =>\n      children\n        .map((child, index) => {\n          switch (child.type) {\n            case 'js':\n            case 'text':\n              return child.content\n            case 'tag':\n              const useTagName =\n                child.isBasic &&\n                this.transSupportBasicHtmlNodes &&\n                this.transKeepBasicHtmlNodesFor.includes(child.name)\n              const elementName = useTagName ? child.name : index\n              const childrenString = elemsToString(child.children)\n              return childrenString || !(useTagName && child.selfClosing)\n                ? `<${elementName}>${childrenString}</${elementName}>`\n                : `<${elementName} />`\n            default:\n              throw new Error('Unknown parsed content: ' + child.type)\n          }\n        })\n        .join('')\n\n    return elemsToString(children)\n  }\n\n  parseChildren(children = [], sourceText) {\n    return children\n      .map((child) => {\n        if (child.kind === ts.SyntaxKind.JsxText) {\n          return {\n            type: 'text',\n            content: child.text\n              .replace(/(^(\\n|\\r)\\s*)|((\\n|\\r)\\s*$)/g, '')\n              .replace(/(\\n|\\r)\\s*/g, ' '),\n          }\n        } else if (\n          child.kind === ts.SyntaxKind.JsxElement ||\n          child.kind === ts.SyntaxKind.JsxSelfClosingElement\n        ) {\n          const element = child.openingElement || child\n          const name = element.tagName.escapedText\n          const isBasic = !element.attributes.properties.length\n          const hasDynamicChildren = element.attributes.properties.find(\n            (prop) => prop.name.escapedText === 'i18nIsDynamicList'\n          )\n          return {\n            type: 'tag',\n            children: hasDynamicChildren\n              ? []\n              : this.parseChildren(child.children, sourceText),\n            name,\n            isBasic,\n            selfClosing: child.kind === ts.SyntaxKind.JsxSelfClosingElement,\n          }\n        } else if (child.kind === ts.SyntaxKind.JsxExpression) {\n          // strip empty expressions\n          if (!child.expression) {\n            return {\n              type: 'text',\n              content: '',\n            }\n          }\n\n          // simplify trivial expressions, like TypeScript typecasts\n          while (child.expression.kind === ts.SyntaxKind.AsExpression) {\n            child = child.expression\n          }\n\n          // Sometimes, we might want to wrap ObjectExpressions in a function\n          // for typechecker compatibility: e.g.,\n          //\n          // Instead of\n          // `<Trans>Hello, <Link to=\"/\">{{ name }}</Link></Trans>`\n          // we might want:\n          // `<Trans>Hello, <Link to=\"/\">{castToString({ name })}</Link></Trans>`\n          //\n          // because that way, we can have {castToString(...)} be typed\n          // in a a way to return a string, which would be type-compatible\n          // with `children?: React.ReactNode`\n          //\n          // In these cases, we want to look at the object expressions within\n          // the function call to extract the variables\n          if (\n            child.expression.kind === ts.SyntaxKind.CallExpression &&\n            child.expression.expression.kind === ts.SyntaxKind.Identifier &&\n            this.transIdentityFunctionsToIgnore.includes(\n              child.expression.expression.escapedText\n            ) &&\n            child.expression.arguments.length >= 1\n          ) {\n            child = { expression: child.expression.arguments[0] }\n          }\n\n          if (child.expression.kind === ts.SyntaxKind.StringLiteral) {\n            return {\n              type: 'text',\n              content: child.expression.text,\n            }\n          }\n\n          // strip properties from ObjectExpressions\n          // annoying (and who knows how many other exceptions we'll need to write) but necessary\n          else if (\n            child.expression.kind === ts.SyntaxKind.ObjectLiteralExpression\n          ) {\n            // i18next-react only accepts two props, any random single prop, and a format prop\n\n            const nonFormatProperties = child.expression.properties.filter(\n              (prop) => prop.name.text !== 'format'\n            )\n            const formatProperty = child.expression.properties.find(\n              (prop) => prop.name.text === 'format'\n            )\n\n            // more than one property throw a warning in i18next-react, but still works as a key\n            if (nonFormatProperties.length > 1) {\n              this.emit(\n                'warning',\n                `The passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`\n              )\n\n              return {\n                type: 'text',\n                content: '',\n              }\n            }\n\n            // This matches the behaviour of the Trans component in i18next as of v13.0.2:\n            // https://github.com/i18next/react-i18next/blob/0a4681e428c888fe986bcc0109eb19eab6ff2eb3/src/TransWithoutContext.js#L88\n            const value = formatProperty\n              ? `${nonFormatProperties[0].name.text}, ${formatProperty.initializer.text}`\n              : nonFormatProperties[0].name.text\n\n            return {\n              type: 'js',\n              content: `{{${value}}}`,\n            }\n          }\n\n          // slice on the expression so that we ignore comments around it\n          const slicedExpression = sourceText.slice(\n            child.expression.pos,\n            child.expression.end\n          )\n\n          this.emit('warning', `Child is not literal: ${slicedExpression}`)\n\n          return {\n            type: 'js',\n            content: `{${slicedExpression}}`,\n          }\n        } else {\n          throw new Error('Unknown ast element when parsing jsx: ' + child.kind)\n        }\n      })\n      .filter((child) => child.type !== 'text' || child.content)\n  }\n}\n"],"mappings":"mjCAAA,OAAOA,eAAe,MAAM,uBAAuB;AACnD,OAAOC,EAAE,MAAM,YAAY;AAC3B,SAASC,QAAQ,QAAQ,eAAe;;AAEnBC,QAAQ,0BAAAC,gBAAA,GAAAC,SAAA,CAAAF,QAAA,EAAAC,gBAAA,MAAAE,MAAA,GAAAC,YAAA,CAAAJ,QAAA;EAC3B,SAAAA,SAAA,EAA0B,KAAAK,KAAA,KAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC,CAAAG,eAAA,OAAAV,QAAA;IACtBK,KAAA,GAAAF,MAAA,CAAAQ,IAAA,OAAML,OAAO;;IAEbD,KAAA,CAAKO,kBAAkB,GAAGN,OAAO,CAACM,kBAAkB,IAAI,CAAC,OAAO,CAAC;IACjEP,KAAA,CAAKQ,0BAA0B;IAC7BP,OAAO,CAACO,0BAA0B,IAAI,KAAK;IAC7CR,KAAA,CAAKS,0BAA0B,GAAGR,OAAO,CAACQ,0BAA0B,IAAI;IACtE,IAAI;IACJ,QAAQ;IACR,GAAG;IACH,GAAG,CACJ;;IACDT,KAAA,CAAKU,cAAc,GAAG,CAACV,KAAA,CAAKW,IAAI,EAAE,IAAI,EAAE,UAAU,CAAC;IACnDX,KAAA,CAAKY,8BAA8B;IACjCX,OAAO,CAACW,8BAA8B,IAAI,EAAE,QAAAZ,KAAA;EAChD,CAACa,YAAA,CAAAlB,QAAA,KAAAmB,GAAA,aAAAC,KAAA;;IAED,SAAAC,QAAQC,OAAO,EAA8B,KAAAC,MAAA,YAA5BC,QAAQ,GAAAjB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,eAAe;MACzC,IAAMkB,IAAI,GAAG,EAAE;;MAEf,IAAMC,gBAAgB,GAAG,IAAI,CAACC,uBAAuB,CAAC,CAAC;;MAEvD,IAAMC,SAAS,GAAG,SAAZA,SAASA,CAAIC,IAAI,EAAK;QAC1B,IAAIC,KAAK;;QAETJ,gBAAgB,CAACD,IAAI,EAAEI,IAAI,EAAEP,OAAO,CAAC;;QAErC,QAAQO,IAAI,CAACE,IAAI;UACf,KAAKjC,EAAE,CAACkC,UAAU,CAACC,cAAc;YAC/BH,KAAK,GAAGP,MAAI,CAACW,mBAAmB,CAACvB,IAAI,CAACY,MAAI,EAAEM,IAAI,CAAC;YACjD;UACF,KAAK/B,EAAE,CAACkC,UAAU,CAACG,wBAAwB;YACzCL,KAAK,GAAGP,MAAI,CAACa,iCAAiC,CAACzB,IAAI,CAACY,MAAI,EAAEM,IAAI,CAAC;YAC/D;UACF,KAAK/B,EAAE,CAACkC,UAAU,CAACK,UAAU;YAC3BP,KAAK,GAAGP,MAAI,CAACe,YAAY,CAAC3B,IAAI,CAACY,MAAI,EAAEM,IAAI,EAAEP,OAAO,CAAC;YACnD;UACF,KAAKxB,EAAE,CAACkC,UAAU,CAACO,qBAAqB;YACtCT,KAAK,GAAGP,MAAI,CAACe,YAAY,CAAC3B,IAAI,CAACY,MAAI,EAAEM,IAAI,EAAEP,OAAO,CAAC;YACnD;QACJ;;QAEA,IAAIQ,KAAK,EAAE;UACTL,IAAI,CAACe,IAAI,CAACV,KAAK,CAAC;QAClB;;QAEAD,IAAI,CAACY,YAAY,CAACb,SAAS,CAAC;MAC9B,CAAC;;MAED,IAAMc,UAAU,GAAG5C,EAAE,CAAC6C,gBAAgB;QACpCnB,QAAQ;QACRF,OAAO;QACPxB,EAAE,CAAC8C,YAAY,CAACC;MAClB,CAAC;MACDjB,SAAS,CAACc,UAAU,CAAC;;MAErB,IAAMI,iBAAiB,GAAG,IAAI,CAACC,aAAa,CAACtB,IAAI,CAAC;MAClD,IAAMuB,gBAAgB,GAAG,IAAI,CAACC,cAAc,CAACH,iBAAiB,CAAC;;MAE/D,OAAOE,gBAAgB;IACzB,CAAC,MAAA7B,GAAA,kBAAAC,KAAA;;IAED,SAAAkB,aAAaT,IAAI,EAAEqB,UAAU,EAAE,KAAAC,MAAA;MAC7B,IAAMC,OAAO,GAAGvB,IAAI,CAACwB,cAAc,IAAIxB,IAAI;;MAE3C,IAAMyB,YAAY,GAAG,SAAfA,YAAYA,CAAIzB,IAAI,EAAE0B,aAAa,EAAK,KAAAC,qBAAA;QAC5C,IAAMC,SAAS,GAAG5B,IAAI,CAAC6B,UAAU,CAACC,UAAU,CAACC,IAAI;UAC/C,UAAC5C,IAAI,UAAKA,IAAI,CAAC6C,IAAI,KAAKpD,SAAS,IAAIO,IAAI,CAAC6C,IAAI,CAACC,IAAI,KAAKP,aAAa;QACvE,CAAC;QACD,IAAI,CAACE,SAAS,EAAE;UACd,OAAOhD,SAAS;QAClB;;QAEA,IAAI,EAAA+C,qBAAA,GAAAC,SAAS,CAACM,WAAW,CAACC,UAAU,cAAAR,qBAAA,uBAAhCA,qBAAA,CAAkCzB,IAAI,MAAKjC,EAAE,CAACkC,UAAU,CAACiC,UAAU,EAAE;UACvEd,MAAI,CAACe,IAAI;YACP,SAAS,OAAAC,MAAA;cACLZ,aAAa,uCAAAY,MAAA,CAAmCV,SAAS,CAACM,WAAW,CAACC,UAAU,CAACF,IAAI;UAC3F,CAAC;UACD,OAAOrD,SAAS;QAClB;;QAEA,OAAOgD,SAAS,CAACM,WAAW,CAACC,UAAU;QACnCP,SAAS,CAACM,WAAW,CAACC,UAAU,CAACF,IAAI;QACrCL,SAAS,CAACM,WAAW,CAACD,IAAI;MAChC,CAAC;;MAED,IAAMM,MAAM,GAAG,SAATA,MAAMA,CAAIvC,IAAI,UAAKyB,YAAY,CAACzB,IAAI,EAAEsB,MAAI,CAACnC,IAAI,CAAC;;MAEtD,IAAI,IAAI,CAACJ,kBAAkB,CAACyD,QAAQ,CAACjB,OAAO,CAACkB,OAAO,CAACR,IAAI,CAAC,EAAE;QAC1D,IAAMhC,KAAK,GAAG,CAAC,CAAC;QAChBA,KAAK,CAACX,GAAG,GAAGiD,MAAM,CAAChB,OAAO,CAAC;;QAE3B,IAAMmB,SAAS,GAAGjB,YAAY,CAACF,OAAO,EAAE,IAAI,CAAC;QAC7C,IAAImB,SAAS,EAAE;UACbzC,KAAK,CAACyC,SAAS,GAAGA,SAAS;QAC7B;;QAEAnB,OAAO,CAACM,UAAU,CAACC,UAAU,CAACa,OAAO,CAAC,UAACC,QAAQ,EAAK;UAClD,IAAIA,QAAQ,CAAC1C,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAAC0C,kBAAkB,EAAE;YACtDvB,MAAI,CAACe,IAAI;cACP,SAAS,qDAAAC,MAAA;gBAC0CM,QAAQ,CAACT,UAAU,CAACF,IAAI;YAC7E,CAAC;YACD;UACF;;UAEA,IAAIX,MAAI,CAACpC,cAAc,CAACsD,QAAQ,CAACI,QAAQ,CAACZ,IAAI,CAACC,IAAI,CAAC,EAAE;YACpD;UACF;;UAEA,IAAIW,QAAQ,CAACV,WAAW,EAAE;YACxB,IAAIU,QAAQ,CAACV,WAAW,CAACC,UAAU,EAAE;cACnC;cACES,QAAQ,CAACV,WAAW,CAACC,UAAU,CAACjC,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAAC2C,WAAW;cAClE;gBACA7C,KAAK,CAAC2C,QAAQ,CAACZ,IAAI,CAACC,IAAI,CAAC,GAAG,IAAI;cAClC,CAAC,MAAM;cACLW,QAAQ,CAACV,WAAW,CAACC,UAAU,CAACjC,IAAI;cACpCjC,EAAE,CAACkC,UAAU,CAAC4C,YAAY;cAC1B;gBACA9C,KAAK,CAAC2C,QAAQ,CAACZ,IAAI,CAACC,IAAI,CAAC,GAAG,KAAK;cACnC,CAAC,MAAM;gBACLhC,KAAK;gBACH2C,QAAQ,CAACZ,IAAI,CAACC,IAAI,CACnB,OAAAK,MAAA;kBAAOM,QAAQ,CAACV,WAAW,CAACC,UAAU,CAACF,IAAI,MAAG;cACjD;YACF,CAAC,MAAM;cACLhC,KAAK,CAAC2C,QAAQ,CAACZ,IAAI,CAACC,IAAI,CAAC,GAAGW,QAAQ,CAACV,WAAW,CAACD,IAAI;YACvD;UACF,CAAC,MAAMhC,KAAK,CAAC2C,QAAQ,CAACZ,IAAI,CAACC,IAAI,CAAC,GAAG,IAAI;QACzC,CAAC,CAAC;;QAEF,IAAMe,YAAY,GAAG,IAAI,CAACC,YAAY,CAACnE,IAAI,CAAC,IAAI,EAAEkB,IAAI,EAAEqB,UAAU,CAAC;QACnE,IAAM6B,YAAY,GAAGzB,YAAY,CAACF,OAAO,EAAE,UAAU,CAAC;QACtD,IAAI4B,YAAY,GAAGD,YAAY,IAAIF,YAAY;QAC/C,IAAI/C,KAAK,CAACmD,cAAc,KAAK,IAAI,EAAE;UACjCD,YAAY,GAAGjF,QAAQ,CAACiF,YAAY,CAAC;QACvC;;QAEA,IAAIA,YAAY,KAAK,EAAE,EAAE;UACvBlD,KAAK,CAACkD,YAAY,GAAGA,YAAY;;UAEjC,IAAI,CAAClD,KAAK,CAACX,GAAG,EAAE;YACdW,KAAK,CAACX,GAAG,GAAG0D,YAAY;UAC1B;QACF;;QAEA,OAAO/C,KAAK,CAACX,GAAG,GAAGW,KAAK,GAAG,IAAI;MACjC,CAAC,MAAM,IAAIsB,OAAO,CAACkB,OAAO,CAACR,IAAI,KAAK,aAAa,EAAE;QACjD,IAAMhC,MAAK,GAAG,CAAC,CAAC;QAChBA,MAAK,CAACX,GAAG,GAAGiD,MAAM,CAAChB,OAAO,CAAC;QAC3B,OAAOtB,MAAK,CAACX,GAAG,GAAGW,MAAK,GAAG,IAAI;MACjC,CAAC,MAAM,IAAIsB,OAAO,CAACkB,OAAO,CAACR,IAAI,KAAK,aAAa,EAAE;QACjD,IAAMS,UAAS,GAAGjB,YAAY,CAACF,OAAO,EAAE,IAAI,CAAC;QAC7C,IAAImB,UAAS,EAAE;UACb,IAAI,CAACW,gBAAgB,GAAGX,UAAS;QACnC;MACF;IACF,CAAC,MAAApD,GAAA,kBAAAC,KAAA;;IAED,SAAA0D,aAAajD,IAAI,EAAEqB,UAAU,EAAE,KAAAiC,MAAA;MAC7B,IAAMC,QAAQ,GAAG,IAAI,CAACC,aAAa,CAAC1E,IAAI,CAAC,IAAI,EAAEkB,IAAI,CAACuD,QAAQ,EAAElC,UAAU,CAAC;;MAEzE,IAAMoC,aAAa,GAAG,SAAhBA,aAAaA,CAAIF,QAAQ;UAC7BA,QAAQ;UACLG,GAAG,CAAC,UAACC,KAAK,EAAEC,KAAK,EAAK;YACrB,QAAQD,KAAK,CAACE,IAAI;cAChB,KAAK,IAAI;cACT,KAAK,MAAM;gBACT,OAAOF,KAAK,CAAClE,OAAO;cACtB,KAAK,KAAK;gBACR,IAAMqE,UAAU;gBACdH,KAAK,CAACI,OAAO;gBACbT,MAAI,CAACtE,0BAA0B;gBAC/BsE,MAAI,CAACrE,0BAA0B,CAACuD,QAAQ,CAACmB,KAAK,CAAC3B,IAAI,CAAC;gBACtD,IAAMgC,WAAW,GAAGF,UAAU,GAAGH,KAAK,CAAC3B,IAAI,GAAG4B,KAAK;gBACnD,IAAMK,cAAc,GAAGR,aAAa,CAACE,KAAK,CAACJ,QAAQ,CAAC;gBACpD,OAAOU,cAAc,IAAI,EAAEH,UAAU,IAAIH,KAAK,CAACO,WAAW,CAAC,OAAA5B,MAAA;kBACnD0B,WAAW,OAAA1B,MAAA,CAAI2B,cAAc,QAAA3B,MAAA,CAAK0B,WAAW,aAAA1B,MAAA;kBAC7C0B,WAAW,QAAK;cAC1B;gBACE,MAAM,IAAIG,KAAK,CAAC,0BAA0B,GAAGR,KAAK,CAACE,IAAI,CAAC;YAC5D;UACF,CAAC,CAAC;UACDO,IAAI,CAAC,EAAE,CAAC;;MAEb,OAAOX,aAAa,CAACF,QAAQ,CAAC;IAChC,CAAC,MAAAjE,GAAA,mBAAAC,KAAA;;IAED,SAAAiE,cAAA,EAAyC,KAAAa,MAAA,YAA3Bd,QAAQ,GAAA7E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE,KAAE2C,UAAU,GAAA3C,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;MACrC,OAAO2E,QAAQ;MACZG,GAAG,CAAC,UAACC,KAAK,EAAK;QACd,IAAIA,KAAK,CAACzD,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACmE,OAAO,EAAE;UACxC,OAAO;YACLT,IAAI,EAAE,MAAM;YACZpE,OAAO,EAAEkE,KAAK,CAAC1B,IAAI;YAChBsC,OAAO,CAAC,8BAA8B,EAAE,EAAE,CAAC;YAC3CA,OAAO,CAAC,aAAa,EAAE,GAAG;UAC/B,CAAC;QACH,CAAC,MAAM;QACLZ,KAAK,CAACzD,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACK,UAAU;QACvCmD,KAAK,CAACzD,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACO,qBAAqB;QAClD;UACA,IAAM8D,OAAO,GAAGb,KAAK,CAACnC,cAAc,IAAImC,KAAK;UAC7C,IAAM3B,IAAI,GAAGwC,OAAO,CAAC/B,OAAO,CAACgC,WAAW;UACxC,IAAMV,OAAO,GAAG,CAACS,OAAO,CAAC3C,UAAU,CAACC,UAAU,CAACnD,MAAM;UACrD,IAAM+F,kBAAkB,GAAGF,OAAO,CAAC3C,UAAU,CAACC,UAAU,CAACC,IAAI;YAC3D,UAAC4C,IAAI,UAAKA,IAAI,CAAC3C,IAAI,CAACyC,WAAW,KAAK,mBAAmB;UACzD,CAAC;UACD,OAAO;YACLZ,IAAI,EAAE,KAAK;YACXN,QAAQ,EAAEmB,kBAAkB;YACxB,EAAE;YACFL,MAAI,CAACb,aAAa,CAACG,KAAK,CAACJ,QAAQ,EAAElC,UAAU,CAAC;YAClDW,IAAI,EAAJA,IAAI;YACJ+B,OAAO,EAAPA,OAAO;YACPG,WAAW,EAAEP,KAAK,CAACzD,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACO;UAC5C,CAAC;QACH,CAAC,MAAM,IAAIiD,KAAK,CAACzD,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACyE,aAAa,EAAE;UACrD;UACA,IAAI,CAACjB,KAAK,CAACxB,UAAU,EAAE;YACrB,OAAO;cACL0B,IAAI,EAAE,MAAM;cACZpE,OAAO,EAAE;YACX,CAAC;UACH;;UAEA;UACA,OAAOkE,KAAK,CAACxB,UAAU,CAACjC,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAAC0E,YAAY,EAAE;YAC3DlB,KAAK,GAAGA,KAAK,CAACxB,UAAU;UAC1B;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACEwB,KAAK,CAACxB,UAAU,CAACjC,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACC,cAAc;UACtDuD,KAAK,CAACxB,UAAU,CAACA,UAAU,CAACjC,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAACiC,UAAU;UAC7DiC,MAAI,CAACjF,8BAA8B,CAACoD,QAAQ;YAC1CmB,KAAK,CAACxB,UAAU,CAACA,UAAU,CAACsC;UAC9B,CAAC;UACDd,KAAK,CAACxB,UAAU,CAACzD,SAAS,CAACC,MAAM,IAAI,CAAC;UACtC;YACAgF,KAAK,GAAG,EAAExB,UAAU,EAAEwB,KAAK,CAACxB,UAAU,CAACzD,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;UACvD;;UAEA,IAAIiF,KAAK,CAACxB,UAAU,CAACjC,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAAC2E,aAAa,EAAE;YACzD,OAAO;cACLjB,IAAI,EAAE,MAAM;cACZpE,OAAO,EAAEkE,KAAK,CAACxB,UAAU,CAACF;YAC5B,CAAC;UACH;;UAEA;UACA;UAAA,KACK;UACH0B,KAAK,CAACxB,UAAU,CAACjC,IAAI,KAAKjC,EAAE,CAACkC,UAAU,CAAC4E,uBAAuB;UAC/D;YACA;;YAEA,IAAMC,mBAAmB,GAAGrB,KAAK,CAACxB,UAAU,CAACL,UAAU,CAACmD,MAAM;cAC5D,UAACN,IAAI,UAAKA,IAAI,CAAC3C,IAAI,CAACC,IAAI,KAAK,QAAQ;YACvC,CAAC;YACD,IAAMiD,cAAc,GAAGvB,KAAK,CAACxB,UAAU,CAACL,UAAU,CAACC,IAAI;cACrD,UAAC4C,IAAI,UAAKA,IAAI,CAAC3C,IAAI,CAACC,IAAI,KAAK,QAAQ;YACvC,CAAC;;YAED;YACA,IAAI+C,mBAAmB,CAACrG,MAAM,GAAG,CAAC,EAAE;cAClC0F,MAAI,CAAChC,IAAI;gBACP,SAAS;;cAEX,CAAC;;cAED,OAAO;gBACLwB,IAAI,EAAE,MAAM;gBACZpE,OAAO,EAAE;cACX,CAAC;YACH;;YAEA;YACA;YACA,IAAMF,KAAK,GAAG2F,cAAc,MAAA5C,MAAA;cACrB0C,mBAAmB,CAAC,CAAC,CAAC,CAAChD,IAAI,CAACC,IAAI,QAAAK,MAAA,CAAK4C,cAAc,CAAChD,WAAW,CAACD,IAAI;YACvE+C,mBAAmB,CAAC,CAAC,CAAC,CAAChD,IAAI,CAACC,IAAI;;YAEpC,OAAO;cACL4B,IAAI,EAAE,IAAI;cACVpE,OAAO,OAAA6C,MAAA,CAAO/C,KAAK;YACrB,CAAC;UACH;;UAEA;UACA,IAAM4F,gBAAgB,GAAG9D,UAAU,CAAC+D,KAAK;YACvCzB,KAAK,CAACxB,UAAU,CAACkD,GAAG;YACpB1B,KAAK,CAACxB,UAAU,CAACmD;UACnB,CAAC;;UAEDjB,MAAI,CAAChC,IAAI,CAAC,SAAS,2BAAAC,MAAA,CAA2B6C,gBAAgB,CAAE,CAAC;;UAEjE,OAAO;YACLtB,IAAI,EAAE,IAAI;YACVpE,OAAO,MAAA6C,MAAA,CAAM6C,gBAAgB;UAC/B,CAAC;QACH,CAAC,MAAM;UACL,MAAM,IAAIhB,KAAK,CAAC,wCAAwC,GAAGR,KAAK,CAACzD,IAAI,CAAC;QACxE;MACF,CAAC,CAAC;MACD+E,MAAM,CAAC,UAACtB,KAAK,UAAKA,KAAK,CAACE,IAAI,KAAK,MAAM,IAAIF,KAAK,CAAClE,OAAO,GAAC;IAC9D,CAAC,YAAAtB,QAAA,GAjUmCH,eAAe,WAAhCG,QAAQ,IAAAoH,OAAA"}