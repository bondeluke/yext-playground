"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  Im,
  Kh,
  Nm,
  QC,
  Rf,
  Wc,
  XC,
  ZC,
  al,
  bc,
  bm,
  eN,
  iN,
  nN,
  oN,
  rN,
  rl,
  tN,
  ta
} from "./chunk-QXIFOUKC.js";
import {
  require_react_dom
} from "./chunk-JEFOHQZM.js";
import {
  require_react
} from "./chunk-OMIYRWQL.js";
import {
  __toESM,
  require_dist
} from "./chunk-T67JVKC2.js";

// node_modules/@yext/pages-components/dist/index--cy1NwMF.js
var import_dist = __toESM(require_dist(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
function yr(n2) {
  const t = [];
  let e = -1;
  for (; ++e < n2.footnoteOrder.length; ) {
    const r = n2.footnoteById[n2.footnoteOrder[e]];
    if (!r)
      continue;
    const i = n2.all(r), l = String(r.identifier).toUpperCase(), o = al(l.toLowerCase());
    let a = 0;
    const c = [];
    for (; ++a <= n2.footnoteCounts[l]; ) {
      const p = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + n2.clobberPrefix + "fnref-" + o + (a > 1 ? "-" + a : ""),
          dataFootnoteBackref: true,
          className: ["data-footnote-backref"],
          ariaLabel: n2.footnoteBackLabel
        },
        children: [{ type: "text", value: "↩" }]
      };
      a > 1 && p.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(a) }]
      }), c.length > 0 && c.push({ type: "text", value: " " }), c.push(p);
    }
    const s = i[i.length - 1];
    if (s && s.type === "element" && s.tagName === "p") {
      const p = s.children[s.children.length - 1];
      p && p.type === "text" ? p.value += " " : s.children.push({ type: "text", value: " " }), s.children.push(...c);
    } else
      i.push(...c);
    const d = {
      type: "element",
      tagName: "li",
      properties: { id: n2.clobberPrefix + "fn-" + o },
      children: n2.wrap(i, true)
    };
    n2.patch(r, d), t.push(d);
  }
  if (t.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: n2.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(n2.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: n2.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: n2.wrap(t, true)
        },
        { type: "text", value: `
` }
      ]
    };
}
function Ot(n2, t) {
  const e = oN(n2, t), r = e.one(n2, null), i = yr(e);
  return i && r.children.push({ type: "text", value: `
` }, i), Array.isArray(r) ? { type: "root", children: r } : r;
}
var xr = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(n2, t) {
    return n2 && "run" in n2 ? kr(n2, t) : Sr(n2 || t);
  }
);
var br = xr;
function kr(n2, t) {
  return (e, r, i) => {
    n2.run(Ot(e, t), r, (l) => {
      i(l);
    });
  };
}
function Sr(n2) {
  return (t) => Ot(t, n2);
}
var Be = ["http", "https", "mailto", "tel"];
function wr(n2) {
  const t = (n2 || "").trim(), e = t.charAt(0);
  if (e === "#" || e === "/")
    return t;
  const r = t.indexOf(":");
  if (r === -1)
    return t;
  let i = -1;
  for (; ++i < Be.length; ) {
    const l = Be[i];
    if (r === l.length && t.slice(0, l.length).toLowerCase() === l)
      return t;
  }
  return i = t.indexOf("?"), i !== -1 && r > i || (i = t.indexOf("#"), i !== -1 && r > i) ? t : "javascript:void(0)";
}
var Er = function(t) {
  return t != null && t.constructor != null && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
};
var It = bc(Er);
function qn(n2) {
  return !n2 || typeof n2 != "object" ? "" : "position" in n2 || "type" in n2 ? je(n2.position) : "start" in n2 || "end" in n2 ? je(n2) : "line" in n2 || "column" in n2 ? ye(n2) : "";
}
function ye(n2) {
  return $e(n2 && n2.line) + ":" + $e(n2 && n2.column);
}
function je(n2) {
  return ye(n2 && n2.start) + "-" + ye(n2 && n2.end);
}
function $e(n2) {
  return n2 && typeof n2 == "number" ? n2 : 1;
}
var wn = class extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(t, e, r) {
    const i = [null, null];
    let l = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof e == "string" && (r = e, e = void 0), typeof r == "string") {
      const o = r.indexOf(":");
      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));
    }
    e && ("type" in e || "position" in e ? e.position && (l = e.position) : "start" in e || "end" in e ? l = e : ("line" in e || "column" in e) && (l.start = e)), this.name = qn(e) || "1:1", this.message = typeof t == "object" ? t.message : t, this.stack = "", typeof t == "object" && t.stack && (this.stack = t.stack), this.reason = this.message, this.fatal, this.line = l.start.line, this.column = l.start.column, this.position = l, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;
  }
};
wn.prototype.file = "";
wn.prototype.name = "";
wn.prototype.reason = "";
wn.prototype.message = "";
wn.prototype.stack = "";
wn.prototype.fatal = null;
wn.prototype.column = null;
wn.prototype.line = null;
wn.prototype.source = null;
wn.prototype.ruleId = null;
wn.prototype.position = null;
var Cn = { basename: vr, dirname: Cr, extname: Tr, join: Pr, sep: "/" };
function vr(n2, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Vn(n2);
  let e = 0, r = -1, i = n2.length, l;
  if (t === void 0 || t.length === 0 || t.length > n2.length) {
    for (; i--; )
      if (n2.charCodeAt(i) === 47) {
        if (l) {
          e = i + 1;
          break;
        }
      } else
        r < 0 && (l = true, r = i + 1);
    return r < 0 ? "" : n2.slice(e, r);
  }
  if (t === n2)
    return "";
  let o = -1, a = t.length - 1;
  for (; i--; )
    if (n2.charCodeAt(i) === 47) {
      if (l) {
        e = i + 1;
        break;
      }
    } else
      o < 0 && (l = true, o = i + 1), a > -1 && (n2.charCodeAt(i) === t.charCodeAt(a--) ? a < 0 && (r = i) : (a = -1, r = o));
  return e === r ? r = o : r < 0 && (r = n2.length), n2.slice(e, r);
}
function Cr(n2) {
  if (Vn(n2), n2.length === 0)
    return ".";
  let t = -1, e = n2.length, r;
  for (; --e; )
    if (n2.charCodeAt(e) === 47) {
      if (r) {
        t = e;
        break;
      }
    } else
      r || (r = true);
  return t < 0 ? n2.charCodeAt(0) === 47 ? "/" : "." : t === 1 && n2.charCodeAt(0) === 47 ? "//" : n2.slice(0, t);
}
function Tr(n2) {
  Vn(n2);
  let t = n2.length, e = -1, r = 0, i = -1, l = 0, o;
  for (; t--; ) {
    const a = n2.charCodeAt(t);
    if (a === 47) {
      if (o) {
        r = t + 1;
        break;
      }
      continue;
    }
    e < 0 && (o = true, e = t + 1), a === 46 ? i < 0 ? i = t : l !== 1 && (l = 1) : i > -1 && (l = -1);
  }
  return i < 0 || e < 0 || // We saw a non-dot character immediately before the dot.
  l === 0 || // The (right-most) trimmed path component is exactly `..`.
  l === 1 && i === e - 1 && i === r + 1 ? "" : n2.slice(i, e);
}
function Pr(...n2) {
  let t = -1, e;
  for (; ++t < n2.length; )
    Vn(n2[t]), n2[t] && (e = e === void 0 ? n2[t] : e + "/" + n2[t]);
  return e === void 0 ? "." : Or(e);
}
function Or(n2) {
  Vn(n2);
  const t = n2.charCodeAt(0) === 47;
  let e = Ir(n2, !t);
  return e.length === 0 && !t && (e = "."), e.length > 0 && n2.charCodeAt(n2.length - 1) === 47 && (e += "/"), t ? "/" + e : e;
}
function Ir(n2, t) {
  let e = "", r = 0, i = -1, l = 0, o = -1, a, c;
  for (; ++o <= n2.length; ) {
    if (o < n2.length)
      a = n2.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === o - 1 || l === 1))
        if (i !== o - 1 && l === 2) {
          if (e.length < 2 || r !== 2 || e.charCodeAt(e.length - 1) !== 46 || e.charCodeAt(e.length - 2) !== 46) {
            if (e.length > 2) {
              if (c = e.lastIndexOf("/"), c !== e.length - 1) {
                c < 0 ? (e = "", r = 0) : (e = e.slice(0, c), r = e.length - 1 - e.lastIndexOf("/")), i = o, l = 0;
                continue;
              }
            } else if (e.length > 0) {
              e = "", r = 0, i = o, l = 0;
              continue;
            }
          }
          t && (e = e.length > 0 ? e + "/.." : "..", r = 2);
        } else
          e.length > 0 ? e += "/" + n2.slice(i + 1, o) : e = n2.slice(i + 1, o), r = o - i - 1;
      i = o, l = 0;
    } else
      a === 46 && l > -1 ? l++ : l = -1;
  }
  return e;
}
function Vn(n2) {
  if (typeof n2 != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n2)
    );
}
var Ar = { cwd: Rr };
function Rr() {
  return "/";
}
function xe(n2) {
  return n2 !== null && typeof n2 == "object" && // @ts-expect-error: indexable.
  n2.href && // @ts-expect-error: indexable.
  n2.origin;
}
function _r(n2) {
  if (typeof n2 == "string")
    n2 = new URL(n2);
  else if (!xe(n2)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n2 + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (n2.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Lr(n2);
}
function Lr(n2) {
  if (n2.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = n2.pathname;
  let e = -1;
  for (; ++e < t.length; )
    if (t.charCodeAt(e) === 37 && t.charCodeAt(e + 1) === 50) {
      const r = t.charCodeAt(e + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
var Zn = ["history", "path", "basename", "stem", "extname", "dirname"];
var At = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let e;
    t ? typeof t == "string" || zr(t) ? e = { value: t } : xe(t) ? e = { path: t } : e = t : e = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = Ar.cwd(), this.value, this.stored, this.result, this.map;
    let r = -1;
    for (; ++r < Zn.length; ) {
      const l = Zn[r];
      l in e && e[l] !== void 0 && e[l] !== null && (this[l] = l === "history" ? [...e[l]] : e[l]);
    }
    let i;
    for (i in e)
      Zn.includes(i) || (this[i] = e[i]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(t) {
    xe(t) && (t = _r(t)), ee(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? Cn.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(t) {
    Ne(this.basename, "dirname"), this.path = Cn.join(t || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? Cn.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(t) {
    ee(t, "basename"), ne(t, "basename"), this.path = Cn.join(this.dirname || "", t);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? Cn.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(t) {
    if (ne(t, "extname"), Ne(this.dirname, "extname"), t) {
      if (t.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Cn.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? Cn.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(t) {
    ee(t, "stem"), ne(t, "stem"), this.path = Cn.join(this.dirname || "", t + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return (this.value || "").toString(t || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, e, r) {
    const i = new wn(t, e, r);
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = false, this.messages.push(i), i;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, e, r) {
    const i = this.message(t, e, r);
    return i.fatal = null, i;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, e, r) {
    const i = this.message(t, e, r);
    throw i.fatal = true, i;
  }
};
function ne(n2, t) {
  if (n2 && n2.includes(Cn.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Cn.sep + "`"
    );
}
function ee(n2, t) {
  if (!n2)
    throw new Error("`" + t + "` cannot be empty");
}
function Ne(n2, t) {
  if (!n2)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function zr(n2) {
  return It(n2);
}
function qe(n2) {
  if (n2)
    throw n2;
}
var Xn = Object.prototype.hasOwnProperty;
var Rt = Object.prototype.toString;
var Ue = Object.defineProperty;
var He = Object.getOwnPropertyDescriptor;
var Ve = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : Rt.call(t) === "[object Array]";
};
var Ye = function(t) {
  if (!t || Rt.call(t) !== "[object Object]")
    return false;
  var e = Xn.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Xn.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !e && !r)
    return false;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || Xn.call(t, i);
};
var We = function(t, e) {
  Ue && e.name === "__proto__" ? Ue(t, e.name, {
    enumerable: true,
    configurable: true,
    value: e.newValue,
    writable: true
  }) : t[e.name] = e.newValue;
};
var Qe = function(t, e) {
  if (e === "__proto__")
    if (Xn.call(t, e)) {
      if (He)
        return He(t, e).value;
    } else
      return;
  return t[e];
};
var Mr = function n() {
  var t, e, r, i, l, o, a = arguments[0], c = 1, s = arguments.length, d = false;
  for (typeof a == "boolean" && (d = a, a = arguments[1] || {}, c = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); c < s; ++c)
    if (t = arguments[c], t != null)
      for (e in t)
        r = Qe(a, e), i = Qe(t, e), a !== i && (d && i && (Ye(i) || (l = Ve(i))) ? (l ? (l = false, o = r && Ve(r) ? r : []) : o = r && Ye(r) ? r : {}, We(a, { name: e, newValue: n(d, o, i) })) : typeof i < "u" && We(a, { name: e, newValue: i }));
  return a;
};
var Xe = bc(Mr);
function be(n2) {
  if (typeof n2 != "object" || n2 === null)
    return false;
  const t = Object.getPrototypeOf(n2);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in n2) && !(Symbol.iterator in n2);
}
function Fr() {
  const n2 = [], t = { run: e, use: r };
  return t;
  function e(...i) {
    let l = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...i);
    function a(c, ...s) {
      const d = n2[++l];
      let p = -1;
      if (c) {
        o(c);
        return;
      }
      for (; ++p < i.length; )
        (s[p] === null || s[p] === void 0) && (s[p] = i[p]);
      i = s, d ? Dr(d, a)(...s) : o(null, ...s);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n2.push(i), t;
  }
}
function Dr(n2, t) {
  let e;
  return r;
  function r(...o) {
    const a = n2.length > o.length;
    let c;
    a && o.push(i);
    try {
      c = n2.apply(this, o);
    } catch (s) {
      const d = (
        /** @type {Error} */
        s
      );
      if (a && e)
        throw d;
      return i(d);
    }
    a || (c instanceof Promise ? c.then(l, i) : c instanceof Error ? i(c) : l(c));
  }
  function i(o, ...a) {
    e || (e = true, t(o, ...a));
  }
  function l(o) {
    i(null, o);
  }
}
var Br = Lt().freeze();
var _t = {}.hasOwnProperty;
function Lt() {
  const n2 = Fr(), t = [];
  let e = {}, r, i = -1;
  return l.data = o, l.Parser = void 0, l.Compiler = void 0, l.freeze = a, l.attachers = t, l.use = c, l.parse = s, l.stringify = d, l.run = p, l.runSync = m, l.process = h, l.processSync = w, l;
  function l() {
    const g = Lt();
    let y = -1;
    for (; ++y < t.length; )
      g.use(...t[y]);
    return g.data(Xe(true, {}, e)), g;
  }
  function o(g, y) {
    return typeof g == "string" ? arguments.length === 2 ? (ie("data", r), e[g] = y, l) : _t.call(e, g) && e[g] || null : g ? (ie("data", r), e = g, l) : e;
  }
  function a() {
    if (r)
      return l;
    for (; ++i < t.length; ) {
      const [g, ...y] = t[i];
      if (y[0] === false)
        continue;
      y[0] === true && (y[0] = void 0);
      const k = g.call(l, ...y);
      typeof k == "function" && n2.use(k);
    }
    return r = true, i = Number.POSITIVE_INFINITY, l;
  }
  function c(g, ...y) {
    let k;
    if (ie("use", r), g != null)
      if (typeof g == "function")
        S(g, ...y);
      else if (typeof g == "object")
        Array.isArray(g) ? L(g) : v(g);
      else
        throw new TypeError("Expected usable value, not `" + g + "`");
    return k && (e.settings = Object.assign(e.settings || {}, k)), l;
    function M(x) {
      if (typeof x == "function")
        S(x);
      else if (typeof x == "object")
        if (Array.isArray(x)) {
          const [R, ...q] = x;
          S(R, ...q);
        } else
          v(x);
      else
        throw new TypeError("Expected usable value, not `" + x + "`");
    }
    function v(x) {
      L(x.plugins), x.settings && (k = Object.assign(k || {}, x.settings));
    }
    function L(x) {
      let R = -1;
      if (x != null)
        if (Array.isArray(x))
          for (; ++R < x.length; ) {
            const q = x[R];
            M(q);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + x + "`");
    }
    function S(x, R) {
      let q = -1, X;
      for (; ++q < t.length; )
        if (t[q][0] === x) {
          X = t[q];
          break;
        }
      X ? (be(X[1]) && be(R) && (R = Xe(true, X[1], R)), X[1] = R) : t.push([...arguments]);
    }
  }
  function s(g) {
    l.freeze();
    const y = Nn(g), k = l.Parser;
    return te("parse", k), Ke(k, "parse") ? new k(String(y), y).parse() : k(String(y), y);
  }
  function d(g, y) {
    l.freeze();
    const k = Nn(y), M = l.Compiler;
    return re("stringify", M), Ge(g), Ke(M, "compile") ? new M(g, k).compile() : M(g, k);
  }
  function p(g, y, k) {
    if (Ge(g), l.freeze(), !k && typeof y == "function" && (k = y, y = void 0), !k)
      return new Promise(M);
    M(null, k);
    function M(v, L) {
      n2.run(g, Nn(y), S);
      function S(x, R, q) {
        R = R || g, x ? L(x) : v ? v(R) : k(null, R, q);
      }
    }
  }
  function m(g, y) {
    let k, M;
    return l.run(g, y, v), Je("runSync", "run", M), k;
    function v(L, S) {
      qe(L), k = S, M = true;
    }
  }
  function h(g, y) {
    if (l.freeze(), te("process", l.Parser), re("process", l.Compiler), !y)
      return new Promise(k);
    k(null, y);
    function k(M, v) {
      const L = Nn(g);
      l.run(l.parse(L), L, (x, R, q) => {
        if (x || !R || !q)
          S(x);
        else {
          const X = l.stringify(R, q);
          X == null || (Nr(X) ? q.value = X : q.result = X), S(x, q);
        }
      });
      function S(x, R) {
        x || !R ? v(x) : M ? M(R) : y(null, R);
      }
    }
  }
  function w(g) {
    let y;
    l.freeze(), te("processSync", l.Parser), re("processSync", l.Compiler);
    const k = Nn(g);
    return l.process(k, M), Je("processSync", "process", y), k;
    function M(v) {
      y = true, qe(v);
    }
  }
}
function Ke(n2, t) {
  return typeof n2 == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  n2.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (jr(n2.prototype) || t in n2.prototype);
}
function jr(n2) {
  let t;
  for (t in n2)
    if (_t.call(n2, t))
      return true;
  return false;
}
function te(n2, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + n2 + "` without `Parser`");
}
function re(n2, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + n2 + "` without `Compiler`");
}
function ie(n2, t) {
  if (t)
    throw new Error(
      "Cannot call `" + n2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Ge(n2) {
  if (!be(n2) || typeof n2.type != "string")
    throw new TypeError("Expected node, got `" + n2 + "`");
}
function Je(n2, t, e) {
  if (!e)
    throw new Error(
      "`" + n2 + "` finished async. Use `" + t + "` instead"
    );
}
function Nn(n2) {
  return $r(n2) ? n2 : new At(n2);
}
function $r(n2) {
  return !!(n2 && typeof n2 == "object" && "message" in n2 && "messages" in n2);
}
function Nr(n2) {
  return typeof n2 == "string" || It(n2);
}
var qr = {};
function Ur(n2, t) {
  const e = t || qr, r = typeof e.includeImageAlt == "boolean" ? e.includeImageAlt : true, i = typeof e.includeHtml == "boolean" ? e.includeHtml : true;
  return zt(n2, r, i);
}
function zt(n2, t, e) {
  if (Hr(n2)) {
    if ("value" in n2)
      return n2.type === "html" && !e ? "" : n2.value;
    if (t && "alt" in n2 && n2.alt)
      return n2.alt;
    if ("children" in n2)
      return Ze(n2.children, t, e);
  }
  return Array.isArray(n2) ? Ze(n2, t, e) : "";
}
function Ze(n2, t, e) {
  const r = [];
  let i = -1;
  for (; ++i < n2.length; )
    r[i] = zt(n2[i], t, e);
  return r.join("");
}
function Hr(n2) {
  return !!(n2 && typeof n2 == "object");
}
function an(n2, t, e, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let l = 0;
  return o;
  function o(c) {
    return iN(c) ? (n2.enter(e), a(c)) : t(c);
  }
  function a(c) {
    return iN(c) && l++ < i ? (n2.consume(c), a) : (n2.exit(e), t(c));
  }
}
var Vr = {
  tokenize: Yr
};
function Yr(n2) {
  const t = n2.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let e;
  return t;
  function r(a) {
    if (a === null) {
      n2.consume(a);
      return;
    }
    return n2.enter("lineEnding"), n2.consume(a), n2.exit("lineEnding"), an(n2, t, "linePrefix");
  }
  function i(a) {
    return n2.enter("paragraph"), l(a);
  }
  function l(a) {
    const c = n2.enter("chunkText", {
      contentType: "text",
      previous: e
    });
    return e && (e.next = c), e = c, o(a);
  }
  function o(a) {
    if (a === null) {
      n2.exit("chunkText"), n2.exit("paragraph"), n2.consume(a);
      return;
    }
    return rN(a) ? (n2.consume(a), n2.exit("chunkText"), l) : (n2.consume(a), o);
  }
}
var Wr = {
  tokenize: Qr
};
var nt = {
  tokenize: Xr
};
function Qr(n2) {
  const t = this, e = [];
  let r = 0, i, l, o;
  return a;
  function a(v) {
    if (r < e.length) {
      const L = e[r];
      return t.containerState = L[1], n2.attempt(
        L[0].continuation,
        c,
        s
      )(v);
    }
    return s(v);
  }
  function c(v) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && M();
      const L = t.events.length;
      let S = L, x;
      for (; S--; )
        if (t.events[S][0] === "exit" && t.events[S][1].type === "chunkFlow") {
          x = t.events[S][1].end;
          break;
        }
      k(r);
      let R = L;
      for (; R < t.events.length; )
        t.events[R][1].end = Object.assign({}, x), R++;
      return Wc(
        t.events,
        S + 1,
        0,
        t.events.slice(L)
      ), t.events.length = R, s(v);
    }
    return a(v);
  }
  function s(v) {
    if (r === e.length) {
      if (!i)
        return m(v);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return w(v);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, n2.check(
      nt,
      d,
      p
    )(v);
  }
  function d(v) {
    return i && M(), k(r), m(v);
  }
  function p(v) {
    return t.parser.lazy[t.now().line] = r !== e.length, o = t.now().offset, w(v);
  }
  function m(v) {
    return t.containerState = {}, n2.attempt(
      nt,
      h,
      w
    )(v);
  }
  function h(v) {
    return r++, e.push([t.currentConstruct, t.containerState]), m(v);
  }
  function w(v) {
    if (v === null) {
      i && M(), k(0), n2.consume(v);
      return;
    }
    return i = i || t.parser.flow(t.now()), n2.enter("chunkFlow", {
      contentType: "flow",
      previous: l,
      _tokenizer: i
    }), g(v);
  }
  function g(v) {
    if (v === null) {
      y(n2.exit("chunkFlow"), true), k(0), n2.consume(v);
      return;
    }
    return rN(v) ? (n2.consume(v), y(n2.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (n2.consume(v), g);
  }
  function y(v, L) {
    const S = t.sliceStream(v);
    if (L && S.push(null), v.previous = l, l && (l.next = v), l = v, i.defineSkip(v.start), i.write(S), t.parser.lazy[v.start.line]) {
      let x = i.events.length;
      for (; x--; )
        if (
          // The token starts before the line ending…
          i.events[x][1].start.offset < o && // …and either is not ended yet…
          (!i.events[x][1].end || // …or ends after it.
          i.events[x][1].end.offset > o)
        )
          return;
      const R = t.events.length;
      let q = R, X, sn;
      for (; q--; )
        if (t.events[q][0] === "exit" && t.events[q][1].type === "chunkFlow") {
          if (X) {
            sn = t.events[q][1].end;
            break;
          }
          X = true;
        }
      for (k(r), x = R; x < t.events.length; )
        t.events[x][1].end = Object.assign({}, sn), x++;
      Wc(
        t.events,
        q + 1,
        0,
        t.events.slice(R)
      ), t.events.length = x;
    }
  }
  function k(v) {
    let L = e.length;
    for (; L-- > v; ) {
      const S = e[L];
      t.containerState = S[1], S[0].exit.call(t, n2);
    }
    e.length = v;
  }
  function M() {
    i.write([null]), l = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function Xr(n2, t, e) {
  return an(
    n2,
    n2.attempt(this.parser.constructs.document, t, e),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
var ke = {
  name: "attention",
  tokenize: Gr,
  resolveAll: Kr
};
function Kr(n2, t) {
  let e = -1, r, i, l, o, a, c, s, d;
  for (; ++e < n2.length; )
    if (n2[e][0] === "enter" && n2[e][1].type === "attentionSequence" && n2[e][1]._close) {
      for (r = e; r--; )
        if (n2[r][0] === "exit" && n2[r][1].type === "attentionSequence" && n2[r][1]._open && // If the markers are the same:
        t.sliceSerialize(n2[r][1]).charCodeAt(0) === t.sliceSerialize(n2[e][1]).charCodeAt(0)) {
          if ((n2[r][1]._close || n2[e][1]._open) && (n2[e][1].end.offset - n2[e][1].start.offset) % 3 && !((n2[r][1].end.offset - n2[r][1].start.offset + n2[e][1].end.offset - n2[e][1].start.offset) % 3))
            continue;
          c = n2[r][1].end.offset - n2[r][1].start.offset > 1 && n2[e][1].end.offset - n2[e][1].start.offset > 1 ? 2 : 1;
          const p = Object.assign({}, n2[r][1].end), m = Object.assign({}, n2[e][1].start);
          et(p, -c), et(m, c), o = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: p,
            end: Object.assign({}, n2[r][1].end)
          }, a = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, n2[e][1].start),
            end: m
          }, l = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, n2[r][1].end),
            end: Object.assign({}, n2[e][1].start)
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, a.end)
          }, n2[r][1].end = Object.assign({}, o.start), n2[e][1].start = Object.assign({}, a.end), s = [], n2[r][1].end.offset - n2[r][1].start.offset && (s = rl(s, [
            ["enter", n2[r][1], t],
            ["exit", n2[r][1], t]
          ])), s = rl(s, [
            ["enter", i, t],
            ["enter", o, t],
            ["exit", o, t],
            ["enter", l, t]
          ]), s = rl(
            s,
            Im(
              t.parser.constructs.insideSpan.null,
              n2.slice(r + 1, e),
              t
            )
          ), s = rl(s, [
            ["exit", l, t],
            ["enter", a, t],
            ["exit", a, t],
            ["exit", i, t]
          ]), n2[e][1].end.offset - n2[e][1].start.offset ? (d = 2, s = rl(s, [
            ["enter", n2[e][1], t],
            ["exit", n2[e][1], t]
          ])) : d = 0, Wc(n2, r - 1, e - r + 3, s), e = r + s.length - d - 2;
          break;
        }
    }
  for (e = -1; ++e < n2.length; )
    n2[e][1].type === "attentionSequence" && (n2[e][1].type = "data");
  return n2;
}
function Gr(n2, t) {
  const e = this.parser.constructs.attentionMarkers.null, r = this.previous, i = ta(r);
  let l;
  return o;
  function o(c) {
    return l = c, n2.enter("attentionSequence"), a(c);
  }
  function a(c) {
    if (c === l)
      return n2.consume(c), a;
    const s = n2.exit("attentionSequence"), d = ta(c), p = !d || d === 2 && i || e.includes(c), m = !i || i === 2 && d || e.includes(r);
    return s._open = !!(l === 42 ? p : p && (i || !m)), s._close = !!(l === 42 ? m : m && (d || !p)), t(c);
  }
}
function et(n2, t) {
  n2.column += t, n2.offset += t, n2._bufferIndex += t;
}
var Jr = {
  name: "autolink",
  tokenize: Zr
};
function Zr(n2, t, e) {
  let r = 0;
  return i;
  function i(h) {
    return n2.enter("autolink"), n2.enter("autolinkMarker"), n2.consume(h), n2.exit("autolinkMarker"), n2.enter("autolinkProtocol"), l;
  }
  function l(h) {
    return ZC(h) ? (n2.consume(h), o) : s(h);
  }
  function o(h) {
    return h === 43 || h === 45 || h === 46 || Rf(h) ? (r = 1, a(h)) : s(h);
  }
  function a(h) {
    return h === 58 ? (n2.consume(h), r = 0, c) : (h === 43 || h === 45 || h === 46 || Rf(h)) && r++ < 32 ? (n2.consume(h), a) : (r = 0, s(h));
  }
  function c(h) {
    return h === 62 ? (n2.exit("autolinkProtocol"), n2.enter("autolinkMarker"), n2.consume(h), n2.exit("autolinkMarker"), n2.exit("autolink"), t) : h === null || h === 32 || h === 60 || QC(h) ? e(h) : (n2.consume(h), c);
  }
  function s(h) {
    return h === 64 ? (n2.consume(h), d) : XC(h) ? (n2.consume(h), s) : e(h);
  }
  function d(h) {
    return Rf(h) ? p(h) : e(h);
  }
  function p(h) {
    return h === 46 ? (n2.consume(h), r = 0, d) : h === 62 ? (n2.exit("autolinkProtocol").type = "autolinkEmail", n2.enter("autolinkMarker"), n2.consume(h), n2.exit("autolinkMarker"), n2.exit("autolink"), t) : m(h);
  }
  function m(h) {
    if ((h === 45 || Rf(h)) && r++ < 63) {
      const w = h === 45 ? m : p;
      return n2.consume(h), w;
    }
    return e(h);
  }
}
var Gn = {
  tokenize: ni,
  partial: true
};
function ni(n2, t, e) {
  return r;
  function r(l) {
    return iN(l) ? an(n2, i, "linePrefix")(l) : i(l);
  }
  function i(l) {
    return l === null || rN(l) ? t(l) : e(l);
  }
}
var Mt = {
  name: "blockQuote",
  tokenize: ei,
  continuation: {
    tokenize: ti
  },
  exit: ri
};
function ei(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (n2.enter("blockQuote", {
        _container: true
      }), a.open = true), n2.enter("blockQuotePrefix"), n2.enter("blockQuoteMarker"), n2.consume(o), n2.exit("blockQuoteMarker"), l;
    }
    return e(o);
  }
  function l(o) {
    return iN(o) ? (n2.enter("blockQuotePrefixWhitespace"), n2.consume(o), n2.exit("blockQuotePrefixWhitespace"), n2.exit("blockQuotePrefix"), t) : (n2.exit("blockQuotePrefix"), t(o));
  }
}
function ti(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    return iN(o) ? an(
      n2,
      l,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o) : l(o);
  }
  function l(o) {
    return n2.attempt(Mt, t, e)(o);
  }
}
function ri(n2) {
  n2.exit("blockQuote");
}
var Ft = {
  name: "characterEscape",
  tokenize: ii
};
function ii(n2, t, e) {
  return r;
  function r(l) {
    return n2.enter("characterEscape"), n2.enter("escapeMarker"), n2.consume(l), n2.exit("escapeMarker"), i;
  }
  function i(l) {
    return nN(l) ? (n2.enter("characterEscapeValue"), n2.consume(l), n2.exit("characterEscapeValue"), n2.exit("characterEscape"), t) : e(l);
  }
}
var tt = document.createElement("i");
function Oe(n2) {
  const t = "&" + n2 + ";";
  tt.innerHTML = t;
  const e = tt.textContent;
  return e.charCodeAt(e.length - 1) === 59 && n2 !== "semi" || e === t ? false : e;
}
var Dt = {
  name: "characterReference",
  tokenize: li
};
function li(n2, t, e) {
  const r = this;
  let i = 0, l, o;
  return a;
  function a(p) {
    return n2.enter("characterReference"), n2.enter("characterReferenceMarker"), n2.consume(p), n2.exit("characterReferenceMarker"), c;
  }
  function c(p) {
    return p === 35 ? (n2.enter("characterReferenceMarkerNumeric"), n2.consume(p), n2.exit("characterReferenceMarkerNumeric"), s) : (n2.enter("characterReferenceValue"), l = 31, o = Rf, d(p));
  }
  function s(p) {
    return p === 88 || p === 120 ? (n2.enter("characterReferenceMarkerHexadecimal"), n2.consume(p), n2.exit("characterReferenceMarkerHexadecimal"), n2.enter("characterReferenceValue"), l = 6, o = tN, d) : (n2.enter("characterReferenceValue"), l = 7, o = eN, d(p));
  }
  function d(p) {
    if (p === 59 && i) {
      const m = n2.exit("characterReferenceValue");
      return o === Rf && !Oe(r.sliceSerialize(m)) ? e(p) : (n2.enter("characterReferenceMarker"), n2.consume(p), n2.exit("characterReferenceMarker"), n2.exit("characterReference"), t);
    }
    return o(p) && i++ < l ? (n2.consume(p), d) : e(p);
  }
}
var rt = {
  tokenize: ai,
  partial: true
};
var it = {
  name: "codeFenced",
  tokenize: oi,
  concrete: true
};
function oi(n2, t, e) {
  const r = this, i = {
    tokenize: S,
    partial: true
  };
  let l = 0, o = 0, a;
  return c;
  function c(x) {
    return s(x);
  }
  function s(x) {
    const R = r.events[r.events.length - 1];
    return l = R && R[1].type === "linePrefix" ? R[2].sliceSerialize(R[1], true).length : 0, a = x, n2.enter("codeFenced"), n2.enter("codeFencedFence"), n2.enter("codeFencedFenceSequence"), d(x);
  }
  function d(x) {
    return x === a ? (o++, n2.consume(x), d) : o < 3 ? e(x) : (n2.exit("codeFencedFenceSequence"), iN(x) ? an(n2, p, "whitespace")(x) : p(x));
  }
  function p(x) {
    return x === null || rN(x) ? (n2.exit("codeFencedFence"), r.interrupt ? t(x) : n2.check(rt, g, L)(x)) : (n2.enter("codeFencedFenceInfo"), n2.enter("chunkString", {
      contentType: "string"
    }), m(x));
  }
  function m(x) {
    return x === null || rN(x) ? (n2.exit("chunkString"), n2.exit("codeFencedFenceInfo"), p(x)) : iN(x) ? (n2.exit("chunkString"), n2.exit("codeFencedFenceInfo"), an(n2, h, "whitespace")(x)) : x === 96 && x === a ? e(x) : (n2.consume(x), m);
  }
  function h(x) {
    return x === null || rN(x) ? p(x) : (n2.enter("codeFencedFenceMeta"), n2.enter("chunkString", {
      contentType: "string"
    }), w(x));
  }
  function w(x) {
    return x === null || rN(x) ? (n2.exit("chunkString"), n2.exit("codeFencedFenceMeta"), p(x)) : x === 96 && x === a ? e(x) : (n2.consume(x), w);
  }
  function g(x) {
    return n2.attempt(i, L, y)(x);
  }
  function y(x) {
    return n2.enter("lineEnding"), n2.consume(x), n2.exit("lineEnding"), k;
  }
  function k(x) {
    return l > 0 && iN(x) ? an(
      n2,
      M,
      "linePrefix",
      l + 1
    )(x) : M(x);
  }
  function M(x) {
    return x === null || rN(x) ? n2.check(rt, g, L)(x) : (n2.enter("codeFlowValue"), v(x));
  }
  function v(x) {
    return x === null || rN(x) ? (n2.exit("codeFlowValue"), M(x)) : (n2.consume(x), v);
  }
  function L(x) {
    return n2.exit("codeFenced"), t(x);
  }
  function S(x, R, q) {
    let X = 0;
    return sn;
    function sn(Y) {
      return x.enter("lineEnding"), x.consume(Y), x.exit("lineEnding"), _;
    }
    function _(Y) {
      return x.enter("codeFencedFence"), iN(Y) ? an(
        x,
        O,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(Y) : O(Y);
    }
    function O(Y) {
      return Y === a ? (x.enter("codeFencedFenceSequence"), W(Y)) : q(Y);
    }
    function W(Y) {
      return Y === a ? (X++, x.consume(Y), W) : X >= o ? (x.exit("codeFencedFenceSequence"), iN(Y) ? an(x, en, "whitespace")(Y) : en(Y)) : q(Y);
    }
    function en(Y) {
      return Y === null || rN(Y) ? (x.exit("codeFencedFence"), R(Y)) : q(Y);
    }
  }
}
function ai(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n2.enter("lineEnding"), n2.consume(o), n2.exit("lineEnding"), l);
  }
  function l(o) {
    return r.parser.lazy[r.now().line] ? e(o) : t(o);
  }
}
var le = {
  name: "codeIndented",
  tokenize: si
};
var ui = {
  tokenize: ci,
  partial: true
};
function si(n2, t, e) {
  const r = this;
  return i;
  function i(s) {
    return n2.enter("codeIndented"), an(n2, l, "linePrefix", 5)(s);
  }
  function l(s) {
    const d = r.events[r.events.length - 1];
    return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], true).length >= 4 ? o(s) : e(s);
  }
  function o(s) {
    return s === null ? c(s) : rN(s) ? n2.attempt(ui, o, c)(s) : (n2.enter("codeFlowValue"), a(s));
  }
  function a(s) {
    return s === null || rN(s) ? (n2.exit("codeFlowValue"), o(s)) : (n2.consume(s), a);
  }
  function c(s) {
    return n2.exit("codeIndented"), t(s);
  }
}
function ci(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? e(o) : rN(o) ? (n2.enter("lineEnding"), n2.consume(o), n2.exit("lineEnding"), i) : an(n2, l, "linePrefix", 5)(o);
  }
  function l(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], true).length >= 4 ? t(o) : rN(o) ? i(o) : e(o);
  }
}
var fi = {
  name: "codeText",
  tokenize: di,
  resolve: pi,
  previous: hi
};
function pi(n2) {
  let t = n2.length - 4, e = 3, r, i;
  if ((n2[e][1].type === "lineEnding" || n2[e][1].type === "space") && (n2[t][1].type === "lineEnding" || n2[t][1].type === "space")) {
    for (r = e; ++r < t; )
      if (n2[r][1].type === "codeTextData") {
        n2[e][1].type = "codeTextPadding", n2[t][1].type = "codeTextPadding", e += 2, t -= 2;
        break;
      }
  }
  for (r = e - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && n2[r][1].type !== "lineEnding" && (i = r) : (r === t || n2[r][1].type === "lineEnding") && (n2[i][1].type = "codeTextData", r !== i + 2 && (n2[i][1].end = n2[r - 1][1].end, n2.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return n2;
}
function hi(n2) {
  return n2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function di(n2, t, e) {
  let r = 0, i, l;
  return o;
  function o(p) {
    return n2.enter("codeText"), n2.enter("codeTextSequence"), a(p);
  }
  function a(p) {
    return p === 96 ? (n2.consume(p), r++, a) : (n2.exit("codeTextSequence"), c(p));
  }
  function c(p) {
    return p === null ? e(p) : p === 32 ? (n2.enter("space"), n2.consume(p), n2.exit("space"), c) : p === 96 ? (l = n2.enter("codeTextSequence"), i = 0, d(p)) : rN(p) ? (n2.enter("lineEnding"), n2.consume(p), n2.exit("lineEnding"), c) : (n2.enter("codeTextData"), s(p));
  }
  function s(p) {
    return p === null || p === 32 || p === 96 || rN(p) ? (n2.exit("codeTextData"), c(p)) : (n2.consume(p), s);
  }
  function d(p) {
    return p === 96 ? (n2.consume(p), i++, d) : i === r ? (n2.exit("codeTextSequence"), n2.exit("codeText"), t(p)) : (l.type = "codeTextData", s(p));
  }
}
function Bt(n2) {
  const t = {};
  let e = -1, r, i, l, o, a, c, s;
  for (; ++e < n2.length; ) {
    for (; e in t; )
      e = t[e];
    if (r = n2[e], e && r[1].type === "chunkFlow" && n2[e - 1][1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, l = 0, l < c.length && c[l][1].type === "lineEndingBlank" && (l += 2), l < c.length && c[l][1].type === "content"))
      for (; ++l < c.length && c[l][1].type !== "content"; )
        c[l][1].type === "chunkText" && (c[l][1]._isInFirstContentOfListItem = true, l++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, mi(n2, e)), e = t[e], s = true);
    else if (r[1]._container) {
      for (l = e, i = void 0; l-- && (o = n2[l], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (n2[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = l);
      i && (r[1].end = Object.assign({}, n2[i][1].start), a = n2.slice(i, e), a.unshift(r), Wc(n2, i, e - i + 1, a));
    }
  }
  return !s;
}
function mi(n2, t) {
  const e = n2[t][1], r = n2[t][2];
  let i = t - 1;
  const l = [], o = e._tokenizer || r.parser[e.contentType](e.start), a = o.events, c = [], s = {};
  let d, p, m = -1, h = e, w = 0, g = 0;
  const y = [g];
  for (; h; ) {
    for (; n2[++i][1] !== h; )
      ;
    l.push(i), h._tokenizer || (d = r.sliceStream(h), h.next || d.push(null), p && o.defineSkip(h.start), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = true), o.write(d), h._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), p = h, h = h.next;
  }
  for (h = e; ++m < a.length; )
    a[m][0] === "exit" && a[m - 1][0] === "enter" && a[m][1].type === a[m - 1][1].type && a[m][1].start.line !== a[m][1].end.line && (g = m + 1, y.push(g), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (o.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : y.pop(), m = y.length; m--; ) {
    const k = a.slice(y[m], y[m + 1]), M = l.pop();
    c.unshift([M, M + k.length - 1]), Wc(n2, M, 2, k);
  }
  for (m = -1; ++m < c.length; )
    s[w + c[m][0]] = w + c[m][1], w += c[m][1] - c[m][0] - 1;
  return s;
}
var gi = {
  tokenize: bi,
  resolve: xi
};
var yi = {
  tokenize: ki,
  partial: true
};
function xi(n2) {
  return Bt(n2), n2;
}
function bi(n2, t) {
  let e;
  return r;
  function r(a) {
    return n2.enter("content"), e = n2.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? l(a) : rN(a) ? n2.check(
      yi,
      o,
      l
    )(a) : (n2.consume(a), i);
  }
  function l(a) {
    return n2.exit("chunkContent"), n2.exit("content"), t(a);
  }
  function o(a) {
    return n2.consume(a), n2.exit("chunkContent"), e.next = n2.enter("chunkContent", {
      contentType: "content",
      previous: e
    }), e = e.next, i;
  }
}
function ki(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    return n2.exit("chunkContent"), n2.enter("lineEnding"), n2.consume(o), n2.exit("lineEnding"), an(n2, l, "linePrefix");
  }
  function l(o) {
    if (o === null || rN(o))
      return e(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], true).length >= 4 ? t(o) : n2.interrupt(r.parser.constructs.flow, e, t)(o);
  }
}
function jt(n2, t, e, r, i, l, o, a, c) {
  const s = c || Number.POSITIVE_INFINITY;
  let d = 0;
  return p;
  function p(k) {
    return k === 60 ? (n2.enter(r), n2.enter(i), n2.enter(l), n2.consume(k), n2.exit(l), m) : k === null || k === 32 || k === 41 || QC(k) ? e(k) : (n2.enter(r), n2.enter(o), n2.enter(a), n2.enter("chunkString", {
      contentType: "string"
    }), g(k));
  }
  function m(k) {
    return k === 62 ? (n2.enter(l), n2.consume(k), n2.exit(l), n2.exit(i), n2.exit(r), t) : (n2.enter(a), n2.enter("chunkString", {
      contentType: "string"
    }), h(k));
  }
  function h(k) {
    return k === 62 ? (n2.exit("chunkString"), n2.exit(a), m(k)) : k === null || k === 60 || rN(k) ? e(k) : (n2.consume(k), k === 92 ? w : h);
  }
  function w(k) {
    return k === 60 || k === 62 || k === 92 ? (n2.consume(k), h) : h(k);
  }
  function g(k) {
    return !d && (k === null || k === 41 || bm(k)) ? (n2.exit("chunkString"), n2.exit(a), n2.exit(o), n2.exit(r), t(k)) : d < s && k === 40 ? (n2.consume(k), d++, g) : k === 41 ? (n2.consume(k), d--, g) : k === null || k === 32 || k === 40 || QC(k) ? e(k) : (n2.consume(k), k === 92 ? y : g);
  }
  function y(k) {
    return k === 40 || k === 41 || k === 92 ? (n2.consume(k), g) : g(k);
  }
}
function $t(n2, t, e, r, i, l) {
  const o = this;
  let a = 0, c;
  return s;
  function s(h) {
    return n2.enter(r), n2.enter(i), n2.consume(h), n2.exit(i), n2.enter(l), d;
  }
  function d(h) {
    return a > 999 || h === null || h === 91 || h === 93 && !c || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs ? e(h) : h === 93 ? (n2.exit(l), n2.enter(i), n2.consume(h), n2.exit(i), n2.exit(r), t) : rN(h) ? (n2.enter("lineEnding"), n2.consume(h), n2.exit("lineEnding"), d) : (n2.enter("chunkString", {
      contentType: "string"
    }), p(h));
  }
  function p(h) {
    return h === null || h === 91 || h === 93 || rN(h) || a++ > 999 ? (n2.exit("chunkString"), d(h)) : (n2.consume(h), c || (c = !iN(h)), h === 92 ? m : p);
  }
  function m(h) {
    return h === 91 || h === 92 || h === 93 ? (n2.consume(h), a++, p) : p(h);
  }
}
function Nt(n2, t, e, r, i, l) {
  let o;
  return a;
  function a(m) {
    return m === 34 || m === 39 || m === 40 ? (n2.enter(r), n2.enter(i), n2.consume(m), n2.exit(i), o = m === 40 ? 41 : m, c) : e(m);
  }
  function c(m) {
    return m === o ? (n2.enter(i), n2.consume(m), n2.exit(i), n2.exit(r), t) : (n2.enter(l), s(m));
  }
  function s(m) {
    return m === o ? (n2.exit(l), c(o)) : m === null ? e(m) : rN(m) ? (n2.enter("lineEnding"), n2.consume(m), n2.exit("lineEnding"), an(n2, s, "linePrefix")) : (n2.enter("chunkString", {
      contentType: "string"
    }), d(m));
  }
  function d(m) {
    return m === o || m === null || rN(m) ? (n2.exit("chunkString"), s(m)) : (n2.consume(m), m === 92 ? p : d);
  }
  function p(m) {
    return m === o || m === 92 ? (n2.consume(m), d) : d(m);
  }
}
function Un(n2, t) {
  let e;
  return r;
  function r(i) {
    return rN(i) ? (n2.enter("lineEnding"), n2.consume(i), n2.exit("lineEnding"), e = true, r) : iN(i) ? an(
      n2,
      r,
      e ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
function Mn(n2) {
  return n2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
var Si = {
  name: "definition",
  tokenize: Ei
};
var wi = {
  tokenize: vi,
  partial: true
};
function Ei(n2, t, e) {
  const r = this;
  let i;
  return l;
  function l(h) {
    return n2.enter("definition"), o(h);
  }
  function o(h) {
    return $t.call(
      r,
      n2,
      a,
      // Note: we don’t need to reset the way `markdown-rs` does.
      e,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function a(h) {
    return i = Mn(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), h === 58 ? (n2.enter("definitionMarker"), n2.consume(h), n2.exit("definitionMarker"), c) : e(h);
  }
  function c(h) {
    return bm(h) ? Un(n2, s)(h) : s(h);
  }
  function s(h) {
    return jt(
      n2,
      d,
      // Note: we don’t need to reset the way `markdown-rs` does.
      e,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function d(h) {
    return n2.attempt(wi, p, p)(h);
  }
  function p(h) {
    return iN(h) ? an(n2, m, "whitespace")(h) : m(h);
  }
  function m(h) {
    return h === null || rN(h) ? (n2.exit("definition"), r.parser.defined.push(i), t(h)) : e(h);
  }
}
function vi(n2, t, e) {
  return r;
  function r(a) {
    return bm(a) ? Un(n2, i)(a) : e(a);
  }
  function i(a) {
    return Nt(
      n2,
      l,
      e,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(a);
  }
  function l(a) {
    return iN(a) ? an(n2, o, "whitespace")(a) : o(a);
  }
  function o(a) {
    return a === null || rN(a) ? t(a) : e(a);
  }
}
var Ci = {
  name: "hardBreakEscape",
  tokenize: Ti
};
function Ti(n2, t, e) {
  return r;
  function r(l) {
    return n2.enter("hardBreakEscape"), n2.consume(l), i;
  }
  function i(l) {
    return rN(l) ? (n2.exit("hardBreakEscape"), t(l)) : e(l);
  }
}
var Pi = {
  name: "headingAtx",
  tokenize: Ii,
  resolve: Oi
};
function Oi(n2, t) {
  let e = n2.length - 2, r = 3, i, l;
  return n2[r][1].type === "whitespace" && (r += 2), e - 2 > r && n2[e][1].type === "whitespace" && (e -= 2), n2[e][1].type === "atxHeadingSequence" && (r === e - 1 || e - 4 > r && n2[e - 2][1].type === "whitespace") && (e -= r + 1 === e ? 2 : 4), e > r && (i = {
    type: "atxHeadingText",
    start: n2[r][1].start,
    end: n2[e][1].end
  }, l = {
    type: "chunkText",
    start: n2[r][1].start,
    end: n2[e][1].end,
    contentType: "text"
  }, Wc(n2, r, e - r + 1, [
    ["enter", i, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", i, t]
  ])), n2;
}
function Ii(n2, t, e) {
  let r = 0;
  return i;
  function i(d) {
    return n2.enter("atxHeading"), l(d);
  }
  function l(d) {
    return n2.enter("atxHeadingSequence"), o(d);
  }
  function o(d) {
    return d === 35 && r++ < 6 ? (n2.consume(d), o) : d === null || bm(d) ? (n2.exit("atxHeadingSequence"), a(d)) : e(d);
  }
  function a(d) {
    return d === 35 ? (n2.enter("atxHeadingSequence"), c(d)) : d === null || rN(d) ? (n2.exit("atxHeading"), t(d)) : iN(d) ? an(n2, a, "whitespace")(d) : (n2.enter("atxHeadingText"), s(d));
  }
  function c(d) {
    return d === 35 ? (n2.consume(d), c) : (n2.exit("atxHeadingSequence"), a(d));
  }
  function s(d) {
    return d === null || d === 35 || bm(d) ? (n2.exit("atxHeadingText"), a(d)) : (n2.consume(d), s);
  }
}
var Ai = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var lt = ["pre", "script", "style", "textarea"];
var Ri = {
  name: "htmlFlow",
  tokenize: Mi,
  resolveTo: zi,
  concrete: true
};
var _i = {
  tokenize: Di,
  partial: true
};
var Li = {
  tokenize: Fi,
  partial: true
};
function zi(n2) {
  let t = n2.length;
  for (; t-- && !(n2[t][0] === "enter" && n2[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && n2[t - 2][1].type === "linePrefix" && (n2[t][1].start = n2[t - 2][1].start, n2[t + 1][1].start = n2[t - 2][1].start, n2.splice(t - 2, 2)), n2;
}
function Mi(n2, t, e) {
  const r = this;
  let i, l, o, a, c;
  return s;
  function s(f) {
    return d(f);
  }
  function d(f) {
    return n2.enter("htmlFlow"), n2.enter("htmlFlowData"), n2.consume(f), p;
  }
  function p(f) {
    return f === 33 ? (n2.consume(f), m) : f === 47 ? (n2.consume(f), l = true, g) : f === 63 ? (n2.consume(f), i = 3, r.interrupt ? t : u) : ZC(f) ? (n2.consume(f), o = String.fromCharCode(f), y) : e(f);
  }
  function m(f) {
    return f === 45 ? (n2.consume(f), i = 2, h) : f === 91 ? (n2.consume(f), i = 5, a = 0, w) : ZC(f) ? (n2.consume(f), i = 4, r.interrupt ? t : u) : e(f);
  }
  function h(f) {
    return f === 45 ? (n2.consume(f), r.interrupt ? t : u) : e(f);
  }
  function w(f) {
    const z = "CDATA[";
    return f === z.charCodeAt(a++) ? (n2.consume(f), a === z.length ? r.interrupt ? t : O : w) : e(f);
  }
  function g(f) {
    return ZC(f) ? (n2.consume(f), o = String.fromCharCode(f), y) : e(f);
  }
  function y(f) {
    if (f === null || f === 47 || f === 62 || bm(f)) {
      const z = f === 47, H = o.toLowerCase();
      return !z && !l && lt.includes(H) ? (i = 1, r.interrupt ? t(f) : O(f)) : Ai.includes(o.toLowerCase()) ? (i = 6, z ? (n2.consume(f), k) : r.interrupt ? t(f) : O(f)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? e(f) : l ? M(f) : v(f));
    }
    return f === 45 || Rf(f) ? (n2.consume(f), o += String.fromCharCode(f), y) : e(f);
  }
  function k(f) {
    return f === 62 ? (n2.consume(f), r.interrupt ? t : O) : e(f);
  }
  function M(f) {
    return iN(f) ? (n2.consume(f), M) : sn(f);
  }
  function v(f) {
    return f === 47 ? (n2.consume(f), sn) : f === 58 || f === 95 || ZC(f) ? (n2.consume(f), L) : iN(f) ? (n2.consume(f), v) : sn(f);
  }
  function L(f) {
    return f === 45 || f === 46 || f === 58 || f === 95 || Rf(f) ? (n2.consume(f), L) : S(f);
  }
  function S(f) {
    return f === 61 ? (n2.consume(f), x) : iN(f) ? (n2.consume(f), S) : v(f);
  }
  function x(f) {
    return f === null || f === 60 || f === 61 || f === 62 || f === 96 ? e(f) : f === 34 || f === 39 ? (n2.consume(f), c = f, R) : iN(f) ? (n2.consume(f), x) : q(f);
  }
  function R(f) {
    return f === c ? (n2.consume(f), c = null, X) : f === null || rN(f) ? e(f) : (n2.consume(f), R);
  }
  function q(f) {
    return f === null || f === 34 || f === 39 || f === 47 || f === 60 || f === 61 || f === 62 || f === 96 || bm(f) ? S(f) : (n2.consume(f), q);
  }
  function X(f) {
    return f === 47 || f === 62 || iN(f) ? v(f) : e(f);
  }
  function sn(f) {
    return f === 62 ? (n2.consume(f), _) : e(f);
  }
  function _(f) {
    return f === null || rN(f) ? O(f) : iN(f) ? (n2.consume(f), _) : e(f);
  }
  function O(f) {
    return f === 45 && i === 2 ? (n2.consume(f), tn) : f === 60 && i === 1 ? (n2.consume(f), ln) : f === 62 && i === 4 ? (n2.consume(f), T) : f === 63 && i === 3 ? (n2.consume(f), u) : f === 93 && i === 5 ? (n2.consume(f), mn) : rN(f) && (i === 6 || i === 7) ? (n2.exit("htmlFlowData"), n2.check(
      _i,
      F,
      W
    )(f)) : f === null || rN(f) ? (n2.exit("htmlFlowData"), W(f)) : (n2.consume(f), O);
  }
  function W(f) {
    return n2.check(
      Li,
      en,
      F
    )(f);
  }
  function en(f) {
    return n2.enter("lineEnding"), n2.consume(f), n2.exit("lineEnding"), Y;
  }
  function Y(f) {
    return f === null || rN(f) ? W(f) : (n2.enter("htmlFlowData"), O(f));
  }
  function tn(f) {
    return f === 45 ? (n2.consume(f), u) : O(f);
  }
  function ln(f) {
    return f === 47 ? (n2.consume(f), o = "", hn) : O(f);
  }
  function hn(f) {
    if (f === 62) {
      const z = o.toLowerCase();
      return lt.includes(z) ? (n2.consume(f), T) : O(f);
    }
    return ZC(f) && o.length < 8 ? (n2.consume(f), o += String.fromCharCode(f), hn) : O(f);
  }
  function mn(f) {
    return f === 93 ? (n2.consume(f), u) : O(f);
  }
  function u(f) {
    return f === 62 ? (n2.consume(f), T) : f === 45 && i === 2 ? (n2.consume(f), u) : O(f);
  }
  function T(f) {
    return f === null || rN(f) ? (n2.exit("htmlFlowData"), F(f)) : (n2.consume(f), T);
  }
  function F(f) {
    return n2.exit("htmlFlow"), t(f);
  }
}
function Fi(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    return rN(o) ? (n2.enter("lineEnding"), n2.consume(o), n2.exit("lineEnding"), l) : e(o);
  }
  function l(o) {
    return r.parser.lazy[r.now().line] ? e(o) : t(o);
  }
}
function Di(n2, t, e) {
  return r;
  function r(i) {
    return n2.enter("lineEnding"), n2.consume(i), n2.exit("lineEnding"), n2.attempt(Gn, t, e);
  }
}
var Bi = {
  name: "htmlText",
  tokenize: ji
};
function ji(n2, t, e) {
  const r = this;
  let i, l, o;
  return a;
  function a(u) {
    return n2.enter("htmlText"), n2.enter("htmlTextData"), n2.consume(u), c;
  }
  function c(u) {
    return u === 33 ? (n2.consume(u), s) : u === 47 ? (n2.consume(u), S) : u === 63 ? (n2.consume(u), v) : ZC(u) ? (n2.consume(u), q) : e(u);
  }
  function s(u) {
    return u === 45 ? (n2.consume(u), d) : u === 91 ? (n2.consume(u), l = 0, w) : ZC(u) ? (n2.consume(u), M) : e(u);
  }
  function d(u) {
    return u === 45 ? (n2.consume(u), h) : e(u);
  }
  function p(u) {
    return u === null ? e(u) : u === 45 ? (n2.consume(u), m) : rN(u) ? (o = p, ln(u)) : (n2.consume(u), p);
  }
  function m(u) {
    return u === 45 ? (n2.consume(u), h) : p(u);
  }
  function h(u) {
    return u === 62 ? tn(u) : u === 45 ? m(u) : p(u);
  }
  function w(u) {
    const T = "CDATA[";
    return u === T.charCodeAt(l++) ? (n2.consume(u), l === T.length ? g : w) : e(u);
  }
  function g(u) {
    return u === null ? e(u) : u === 93 ? (n2.consume(u), y) : rN(u) ? (o = g, ln(u)) : (n2.consume(u), g);
  }
  function y(u) {
    return u === 93 ? (n2.consume(u), k) : g(u);
  }
  function k(u) {
    return u === 62 ? tn(u) : u === 93 ? (n2.consume(u), k) : g(u);
  }
  function M(u) {
    return u === null || u === 62 ? tn(u) : rN(u) ? (o = M, ln(u)) : (n2.consume(u), M);
  }
  function v(u) {
    return u === null ? e(u) : u === 63 ? (n2.consume(u), L) : rN(u) ? (o = v, ln(u)) : (n2.consume(u), v);
  }
  function L(u) {
    return u === 62 ? tn(u) : v(u);
  }
  function S(u) {
    return ZC(u) ? (n2.consume(u), x) : e(u);
  }
  function x(u) {
    return u === 45 || Rf(u) ? (n2.consume(u), x) : R(u);
  }
  function R(u) {
    return rN(u) ? (o = R, ln(u)) : iN(u) ? (n2.consume(u), R) : tn(u);
  }
  function q(u) {
    return u === 45 || Rf(u) ? (n2.consume(u), q) : u === 47 || u === 62 || bm(u) ? X(u) : e(u);
  }
  function X(u) {
    return u === 47 ? (n2.consume(u), tn) : u === 58 || u === 95 || ZC(u) ? (n2.consume(u), sn) : rN(u) ? (o = X, ln(u)) : iN(u) ? (n2.consume(u), X) : tn(u);
  }
  function sn(u) {
    return u === 45 || u === 46 || u === 58 || u === 95 || Rf(u) ? (n2.consume(u), sn) : _(u);
  }
  function _(u) {
    return u === 61 ? (n2.consume(u), O) : rN(u) ? (o = _, ln(u)) : iN(u) ? (n2.consume(u), _) : X(u);
  }
  function O(u) {
    return u === null || u === 60 || u === 61 || u === 62 || u === 96 ? e(u) : u === 34 || u === 39 ? (n2.consume(u), i = u, W) : rN(u) ? (o = O, ln(u)) : iN(u) ? (n2.consume(u), O) : (n2.consume(u), en);
  }
  function W(u) {
    return u === i ? (n2.consume(u), i = void 0, Y) : u === null ? e(u) : rN(u) ? (o = W, ln(u)) : (n2.consume(u), W);
  }
  function en(u) {
    return u === null || u === 34 || u === 39 || u === 60 || u === 61 || u === 96 ? e(u) : u === 47 || u === 62 || bm(u) ? X(u) : (n2.consume(u), en);
  }
  function Y(u) {
    return u === 47 || u === 62 || bm(u) ? X(u) : e(u);
  }
  function tn(u) {
    return u === 62 ? (n2.consume(u), n2.exit("htmlTextData"), n2.exit("htmlText"), t) : e(u);
  }
  function ln(u) {
    return n2.exit("htmlTextData"), n2.enter("lineEnding"), n2.consume(u), n2.exit("lineEnding"), hn;
  }
  function hn(u) {
    return iN(u) ? an(
      n2,
      mn,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(u) : mn(u);
  }
  function mn(u) {
    return n2.enter("htmlTextData"), o(u);
  }
}
var Ie = {
  name: "labelEnd",
  tokenize: Vi,
  resolveTo: Hi,
  resolveAll: Ui
};
var $i = {
  tokenize: Yi
};
var Ni = {
  tokenize: Wi
};
var qi = {
  tokenize: Qi
};
function Ui(n2) {
  let t = -1;
  for (; ++t < n2.length; ) {
    const e = n2[t][1];
    (e.type === "labelImage" || e.type === "labelLink" || e.type === "labelEnd") && (n2.splice(t + 1, e.type === "labelImage" ? 4 : 2), e.type = "data", t++);
  }
  return n2;
}
function Hi(n2, t) {
  let e = n2.length, r = 0, i, l, o, a;
  for (; e--; )
    if (i = n2[e][1], l) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n2[e][0] === "enter" && i.type === "labelLink" && (i._inactive = true);
    } else if (o) {
      if (n2[e][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (l = e, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (o = e);
  const c = {
    type: n2[l][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, n2[l][1].start),
    end: Object.assign({}, n2[n2.length - 1][1].end)
  }, s = {
    type: "label",
    start: Object.assign({}, n2[l][1].start),
    end: Object.assign({}, n2[o][1].end)
  }, d = {
    type: "labelText",
    start: Object.assign({}, n2[l + r + 2][1].end),
    end: Object.assign({}, n2[o - 2][1].start)
  };
  return a = [
    ["enter", c, t],
    ["enter", s, t]
  ], a = rl(a, n2.slice(l + 1, l + r + 3)), a = rl(a, [["enter", d, t]]), a = rl(
    a,
    Im(
      t.parser.constructs.insideSpan.null,
      n2.slice(l + r + 4, o - 3),
      t
    )
  ), a = rl(a, [
    ["exit", d, t],
    n2[o - 2],
    n2[o - 1],
    ["exit", s, t]
  ]), a = rl(a, n2.slice(o + 1)), a = rl(a, [["exit", c, t]]), Wc(n2, l, n2.length, a), n2;
}
function Vi(n2, t, e) {
  const r = this;
  let i = r.events.length, l, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      l = r.events[i][1];
      break;
    }
  return a;
  function a(m) {
    return l ? l._inactive ? p(m) : (o = r.parser.defined.includes(
      Mn(
        r.sliceSerialize({
          start: l.end,
          end: r.now()
        })
      )
    ), n2.enter("labelEnd"), n2.enter("labelMarker"), n2.consume(m), n2.exit("labelMarker"), n2.exit("labelEnd"), c) : e(m);
  }
  function c(m) {
    return m === 40 ? n2.attempt(
      $i,
      d,
      o ? d : p
    )(m) : m === 91 ? n2.attempt(
      Ni,
      d,
      o ? s : p
    )(m) : o ? d(m) : p(m);
  }
  function s(m) {
    return n2.attempt(
      qi,
      d,
      p
    )(m);
  }
  function d(m) {
    return t(m);
  }
  function p(m) {
    return l._balanced = true, e(m);
  }
}
function Yi(n2, t, e) {
  return r;
  function r(p) {
    return n2.enter("resource"), n2.enter("resourceMarker"), n2.consume(p), n2.exit("resourceMarker"), i;
  }
  function i(p) {
    return bm(p) ? Un(n2, l)(p) : l(p);
  }
  function l(p) {
    return p === 41 ? d(p) : jt(
      n2,
      o,
      a,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(p);
  }
  function o(p) {
    return bm(p) ? Un(n2, c)(p) : d(p);
  }
  function a(p) {
    return e(p);
  }
  function c(p) {
    return p === 34 || p === 39 || p === 40 ? Nt(
      n2,
      s,
      e,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(p) : d(p);
  }
  function s(p) {
    return bm(p) ? Un(n2, d)(p) : d(p);
  }
  function d(p) {
    return p === 41 ? (n2.enter("resourceMarker"), n2.consume(p), n2.exit("resourceMarker"), n2.exit("resource"), t) : e(p);
  }
}
function Wi(n2, t, e) {
  const r = this;
  return i;
  function i(a) {
    return $t.call(
      r,
      n2,
      l,
      o,
      "reference",
      "referenceMarker",
      "referenceString"
    )(a);
  }
  function l(a) {
    return r.parser.defined.includes(
      Mn(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(a) : e(a);
  }
  function o(a) {
    return e(a);
  }
}
function Qi(n2, t, e) {
  return r;
  function r(l) {
    return n2.enter("reference"), n2.enter("referenceMarker"), n2.consume(l), n2.exit("referenceMarker"), i;
  }
  function i(l) {
    return l === 93 ? (n2.enter("referenceMarker"), n2.consume(l), n2.exit("referenceMarker"), n2.exit("reference"), t) : e(l);
  }
}
var Xi = {
  name: "labelStartImage",
  tokenize: Ki,
  resolveAll: Ie.resolveAll
};
function Ki(n2, t, e) {
  const r = this;
  return i;
  function i(a) {
    return n2.enter("labelImage"), n2.enter("labelImageMarker"), n2.consume(a), n2.exit("labelImageMarker"), l;
  }
  function l(a) {
    return a === 91 ? (n2.enter("labelMarker"), n2.consume(a), n2.exit("labelMarker"), n2.exit("labelImage"), o) : e(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(a) : t(a);
  }
}
var Gi = {
  name: "labelStartLink",
  tokenize: Ji,
  resolveAll: Ie.resolveAll
};
function Ji(n2, t, e) {
  const r = this;
  return i;
  function i(o) {
    return n2.enter("labelLink"), n2.enter("labelMarker"), n2.consume(o), n2.exit("labelMarker"), n2.exit("labelLink"), l;
  }
  function l(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? e(o) : t(o);
  }
}
var oe = {
  name: "lineEnding",
  tokenize: Zi
};
function Zi(n2, t) {
  return e;
  function e(r) {
    return n2.enter("lineEnding"), n2.consume(r), n2.exit("lineEnding"), an(n2, t, "linePrefix");
  }
}
var Kn = {
  name: "thematicBreak",
  tokenize: nl
};
function nl(n2, t, e) {
  let r = 0, i;
  return l;
  function l(s) {
    return n2.enter("thematicBreak"), o(s);
  }
  function o(s) {
    return i = s, a(s);
  }
  function a(s) {
    return s === i ? (n2.enter("thematicBreakSequence"), c(s)) : r >= 3 && (s === null || rN(s)) ? (n2.exit("thematicBreak"), t(s)) : e(s);
  }
  function c(s) {
    return s === i ? (n2.consume(s), r++, c) : (n2.exit("thematicBreakSequence"), iN(s) ? an(n2, a, "whitespace")(s) : a(s));
  }
}
var yn = {
  name: "list",
  tokenize: rl2,
  continuation: {
    tokenize: il
  },
  exit: ol
};
var el = {
  tokenize: al2,
  partial: true
};
var tl = {
  tokenize: ll,
  partial: true
};
function rl2(n2, t, e) {
  const r = this, i = r.events[r.events.length - 1];
  let l = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], true).length : 0, o = 0;
  return a;
  function a(h) {
    const w = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : eN(h)) {
      if (r.containerState.type || (r.containerState.type = w, n2.enter(w, {
        _container: true
      })), w === "listUnordered")
        return n2.enter("listItemPrefix"), h === 42 || h === 45 ? n2.check(Kn, e, s)(h) : s(h);
      if (!r.interrupt || h === 49)
        return n2.enter("listItemPrefix"), n2.enter("listItemValue"), c(h);
    }
    return e(h);
  }
  function c(h) {
    return eN(h) && ++o < 10 ? (n2.consume(h), c) : (!r.interrupt || o < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (n2.exit("listItemValue"), s(h)) : e(h);
  }
  function s(h) {
    return n2.enter("listItemMarker"), n2.consume(h), n2.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, n2.check(
      Gn,
      // Can’t be empty when interrupting.
      r.interrupt ? e : d,
      n2.attempt(
        el,
        m,
        p
      )
    );
  }
  function d(h) {
    return r.containerState.initialBlankLine = true, l++, m(h);
  }
  function p(h) {
    return iN(h) ? (n2.enter("listItemPrefixWhitespace"), n2.consume(h), n2.exit("listItemPrefixWhitespace"), m) : e(h);
  }
  function m(h) {
    return r.containerState.size = l + r.sliceSerialize(n2.exit("listItemPrefix"), true).length, t(h);
  }
}
function il(n2, t, e) {
  const r = this;
  return r.containerState._closeFlow = void 0, n2.check(Gn, i, l);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, an(
      n2,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(a);
  }
  function l(a) {
    return r.containerState.furtherBlankLines || !iN(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n2.attempt(tl, t, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = true, r.interrupt = void 0, an(
      n2,
      n2.attempt(yn, t, e),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a);
  }
}
function ll(n2, t, e) {
  const r = this;
  return an(
    n2,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], true).length === r.containerState.size ? t(l) : e(l);
  }
}
function ol(n2) {
  n2.exit(this.containerState.type);
}
function al2(n2, t, e) {
  const r = this;
  return an(
    n2,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function i(l) {
    const o = r.events[r.events.length - 1];
    return !iN(l) && o && o[1].type === "listItemPrefixWhitespace" ? t(l) : e(l);
  }
}
var ot = {
  name: "setextUnderline",
  tokenize: sl,
  resolveTo: ul
};
function ul(n2, t) {
  let e = n2.length, r, i, l;
  for (; e--; )
    if (n2[e][0] === "enter") {
      if (n2[e][1].type === "content") {
        r = e;
        break;
      }
      n2[e][1].type === "paragraph" && (i = e);
    } else
      n2[e][1].type === "content" && n2.splice(e, 1), !l && n2[e][1].type === "definition" && (l = e);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, n2[i][1].start),
    end: Object.assign({}, n2[n2.length - 1][1].end)
  };
  return n2[i][1].type = "setextHeadingText", l ? (n2.splice(i, 0, ["enter", o, t]), n2.splice(l + 1, 0, ["exit", n2[r][1], t]), n2[r][1].end = Object.assign({}, n2[l][1].end)) : n2[r][1] = o, n2.push(["exit", o, t]), n2;
}
function sl(n2, t, e) {
  const r = this;
  let i;
  return l;
  function l(s) {
    let d = r.events.length, p;
    for (; d--; )
      if (r.events[d][1].type !== "lineEnding" && r.events[d][1].type !== "linePrefix" && r.events[d][1].type !== "content") {
        p = r.events[d][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (n2.enter("setextHeadingLine"), i = s, o(s)) : e(s);
  }
  function o(s) {
    return n2.enter("setextHeadingLineSequence"), a(s);
  }
  function a(s) {
    return s === i ? (n2.consume(s), a) : (n2.exit("setextHeadingLineSequence"), iN(s) ? an(n2, c, "lineSuffix")(s) : c(s));
  }
  function c(s) {
    return s === null || rN(s) ? (n2.exit("setextHeadingLine"), t(s)) : e(s);
  }
}
var cl = {
  tokenize: fl
};
function fl(n2) {
  const t = this, e = n2.attempt(
    // Try to parse a blank line.
    Gn,
    r,
    // Try to parse initial flow (essentially, only code).
    n2.attempt(
      this.parser.constructs.flowInitial,
      i,
      an(
        n2,
        n2.attempt(
          this.parser.constructs.flow,
          i,
          n2.attempt(gi, i)
        ),
        "linePrefix"
      )
    )
  );
  return e;
  function r(l) {
    if (l === null) {
      n2.consume(l);
      return;
    }
    return n2.enter("lineEndingBlank"), n2.consume(l), n2.exit("lineEndingBlank"), t.currentConstruct = void 0, e;
  }
  function i(l) {
    if (l === null) {
      n2.consume(l);
      return;
    }
    return n2.enter("lineEnding"), n2.consume(l), n2.exit("lineEnding"), t.currentConstruct = void 0, e;
  }
}
var pl = {
  resolveAll: Ut()
};
var hl = qt("string");
var dl = qt("text");
function qt(n2) {
  return {
    tokenize: t,
    resolveAll: Ut(
      n2 === "text" ? ml : void 0
    )
  };
  function t(e) {
    const r = this, i = this.parser.constructs[n2], l = e.attempt(i, o, a);
    return o;
    function o(d) {
      return s(d) ? l(d) : a(d);
    }
    function a(d) {
      if (d === null) {
        e.consume(d);
        return;
      }
      return e.enter("data"), e.consume(d), c;
    }
    function c(d) {
      return s(d) ? (e.exit("data"), l(d)) : (e.consume(d), c);
    }
    function s(d) {
      if (d === null)
        return true;
      const p = i[d];
      let m = -1;
      if (p)
        for (; ++m < p.length; ) {
          const h = p[m];
          if (!h.previous || h.previous.call(r, r.previous))
            return true;
        }
      return false;
    }
  }
}
function Ut(n2) {
  return t;
  function t(e, r) {
    let i = -1, l;
    for (; ++i <= e.length; )
      l === void 0 ? e[i] && e[i][1].type === "data" && (l = i, i++) : (!e[i] || e[i][1].type !== "data") && (i !== l + 2 && (e[l][1].end = e[i - 1][1].end, e.splice(l + 2, i - l - 2), i = l + 2), l = void 0);
    return n2 ? n2(e, r) : e;
  }
}
function ml(n2, t) {
  let e = 0;
  for (; ++e <= n2.length; )
    if ((e === n2.length || n2[e][1].type === "lineEnding") && n2[e - 1][1].type === "data") {
      const r = n2[e - 1][1], i = t.sliceStream(r);
      let l = i.length, o = -1, a = 0, c;
      for (; l--; ) {
        const s = i[l];
        if (typeof s == "string") {
          for (o = s.length; s.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o)
            break;
          o = -1;
        } else if (s === -2)
          c = true, a++;
        else if (s !== -1) {
          l++;
          break;
        }
      }
      if (a) {
        const s = {
          type: e === n2.length || c || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a,
            _index: r.start._index + l,
            _bufferIndex: l ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, s.start), r.start.offset === r.end.offset ? Object.assign(r, s) : (n2.splice(
          e,
          0,
          ["enter", s, t],
          ["exit", s, t]
        ), e += 2);
      }
      e++;
    }
  return n2;
}
function gl(n2, t, e) {
  let r = Object.assign(
    e ? Object.assign({}, e) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, l = [];
  let o = [], a = [];
  const c = {
    consume: M,
    enter: v,
    exit: L,
    attempt: R(S),
    check: R(x),
    interrupt: R(x, {
      interrupt: true
    })
  }, s = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: n2,
    sliceStream: h,
    sliceSerialize: m,
    now: w,
    defineSkip: g,
    write: p
  };
  let d = t.tokenize.call(s, c);
  return t.resolveAll && l.push(t), s;
  function p(_) {
    return o = rl(o, _), y(), o[o.length - 1] !== null ? [] : (q(t, 0), s.events = Im(l, s.events, s), s.events);
  }
  function m(_, O) {
    return xl(h(_), O);
  }
  function h(_) {
    return yl(o, _);
  }
  function w() {
    const { line: _, column: O, offset: W, _index: en, _bufferIndex: Y } = r;
    return {
      line: _,
      column: O,
      offset: W,
      _index: en,
      _bufferIndex: Y
    };
  }
  function g(_) {
    i[_.line] = _.column, sn();
  }
  function y() {
    let _;
    for (; r._index < o.length; ) {
      const O = o[r._index];
      if (typeof O == "string")
        for (_ = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === _ && r._bufferIndex < O.length; )
          k(O.charCodeAt(r._bufferIndex));
      else
        k(O);
    }
  }
  function k(_) {
    d = d(_);
  }
  function M(_) {
    rN(_) ? (r.line++, r.column = 1, r.offset += _ === -3 ? 2 : 1, sn()) : _ !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), s.previous = _;
  }
  function v(_, O) {
    const W = O || {};
    return W.type = _, W.start = w(), s.events.push(["enter", W, s]), a.push(W), W;
  }
  function L(_) {
    const O = a.pop();
    return O.end = w(), s.events.push(["exit", O, s]), O;
  }
  function S(_, O) {
    q(_, O.from);
  }
  function x(_, O) {
    O.restore();
  }
  function R(_, O) {
    return W;
    function W(en, Y, tn) {
      let ln, hn, mn, u;
      return Array.isArray(en) ? F(en) : "tokenize" in en ? (
        // @ts-expect-error Looks like a construct.
        F([en])
      ) : T(en);
      function T(I) {
        return B;
        function B(j) {
          const Q = j !== null && I[j], V = j !== null && I.null, fn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Q) ? Q : Q ? [Q] : [],
            ...Array.isArray(V) ? V : V ? [V] : []
          ];
          return F(fn)(j);
        }
      }
      function F(I) {
        return ln = I, hn = 0, I.length === 0 ? tn : f(I[hn]);
      }
      function f(I) {
        return B;
        function B(j) {
          return u = X(), mn = I, I.partial || (s.currentConstruct = I), I.name && s.parser.constructs.disable.null.includes(I.name) ? H() : I.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            O ? Object.assign(Object.create(s), O) : s,
            c,
            z,
            H
          )(j);
        }
      }
      function z(I) {
        return _(mn, u), Y;
      }
      function H(I) {
        return u.restore(), ++hn < ln.length ? f(ln[hn]) : tn;
      }
    }
  }
  function q(_, O) {
    _.resolveAll && !l.includes(_) && l.push(_), _.resolve && Wc(
      s.events,
      O,
      s.events.length - O,
      _.resolve(s.events.slice(O), s)
    ), _.resolveTo && (s.events = _.resolveTo(s.events, s));
  }
  function X() {
    const _ = w(), O = s.previous, W = s.currentConstruct, en = s.events.length, Y = Array.from(a);
    return {
      restore: tn,
      from: en
    };
    function tn() {
      r = _, s.previous = O, s.currentConstruct = W, s.events.length = en, a = Y, sn();
    }
  }
  function sn() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function yl(n2, t) {
  const e = t.start._index, r = t.start._bufferIndex, i = t.end._index, l = t.end._bufferIndex;
  let o;
  if (e === i)
    o = [n2[e].slice(r, l)];
  else {
    if (o = n2.slice(e, i), r > -1) {
      const a = o[0];
      typeof a == "string" ? o[0] = a.slice(r) : o.shift();
    }
    l > 0 && o.push(n2[i].slice(0, l));
  }
  return o;
}
function xl(n2, t) {
  let e = -1;
  const r = [];
  let i;
  for (; ++e < n2.length; ) {
    const l = n2[e];
    let o;
    if (typeof l == "string")
      o = l;
    else
      switch (l) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(l);
      }
    i = l === -2, r.push(o);
  }
  return r.join("");
}
var bl = {
  42: yn,
  43: yn,
  45: yn,
  48: yn,
  49: yn,
  50: yn,
  51: yn,
  52: yn,
  53: yn,
  54: yn,
  55: yn,
  56: yn,
  57: yn,
  62: Mt
};
var kl = {
  91: Si
};
var Sl = {
  [-2]: le,
  [-1]: le,
  32: le
};
var wl = {
  35: Pi,
  42: Kn,
  45: [ot, Kn],
  60: Ri,
  61: ot,
  95: Kn,
  96: it,
  126: it
};
var El = {
  38: Dt,
  92: Ft
};
var vl = {
  [-5]: oe,
  [-4]: oe,
  [-3]: oe,
  33: Xi,
  38: Dt,
  42: ke,
  60: [Jr, Bi],
  91: Gi,
  92: [Ci, Ft],
  93: Ie,
  95: ke,
  96: fi
};
var Cl = {
  null: [ke, pl]
};
var Tl = {
  null: [42, 95]
};
var Pl = {
  null: []
};
var Ol = Object.freeze(Object.defineProperty({
  __proto__: null,
  attentionMarkers: Tl,
  contentInitial: kl,
  disable: Pl,
  document: bl,
  flow: wl,
  flowInitial: Sl,
  insideSpan: Cl,
  string: El,
  text: vl
}, Symbol.toStringTag, { value: "Module" }));
function Il(n2) {
  const e = (
    /** @type {FullNormalizedExtension} */
    Nm([Ol, ...(n2 || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: e,
    content: i(Vr),
    document: i(Wr),
    flow: i(cl),
    string: i(hl),
    text: i(dl)
  };
  return r;
  function i(l) {
    return o;
    function o(a) {
      return gl(r, l, a);
    }
  }
}
var at = /[\0\t\n\r]/g;
function Al() {
  let n2 = 1, t = "", e = true, r;
  return i;
  function i(l, o, a) {
    const c = [];
    let s, d, p, m, h;
    for (l = t + l.toString(o), p = 0, t = "", e && (l.charCodeAt(0) === 65279 && p++, e = void 0); p < l.length; ) {
      if (at.lastIndex = p, s = at.exec(l), m = s && s.index !== void 0 ? s.index : l.length, h = l.charCodeAt(m), !s) {
        t = l.slice(p);
        break;
      }
      if (h === 10 && p === m && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), p < m && (c.push(l.slice(p, m)), n2 += m - p), h) {
          case 0: {
            c.push(65533), n2++;
            break;
          }
          case 9: {
            for (d = Math.ceil(n2 / 4) * 4, c.push(-2); n2++ < d; )
              c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), n2 = 1;
            break;
          }
          default:
            r = true, n2 = 1;
        }
      p = m + 1;
    }
    return a && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
function Rl(n2) {
  for (; !Bt(n2); )
    ;
  return n2;
}
function Ht(n2, t) {
  const e = Number.parseInt(n2, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    e < 9 || e === 11 || e > 13 && e < 32 || // Control character (DEL) of C0, and C1 controls.
    e > 126 && e < 160 || // Lone high surrogates and low surrogates.
    e > 55295 && e < 57344 || // Noncharacters.
    e > 64975 && e < 65008 || (e & 65535) === 65535 || (e & 65535) === 65534 || // Out of range
    e > 1114111 ? "�" : String.fromCharCode(e)
  );
}
var _l = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Ll(n2) {
  return n2.replace(_l, zl);
}
function zl(n2, t, e) {
  if (t)
    return t;
  if (e.charCodeAt(0) === 35) {
    const i = e.charCodeAt(1), l = i === 120 || i === 88;
    return Ht(e.slice(l ? 2 : 1), l ? 16 : 10);
  }
  return Oe(e) || n2;
}
var Se = {}.hasOwnProperty;
var Ml = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options) => Root) &
   *   ((value: Value, options?: Options) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding} [encoding]
   * @param {Options} [options]
   * @returns {Root}
   */
  function(n2, t, e) {
    return typeof t != "string" && (e = t, t = void 0), Fl(e)(
      Rl(
        Il(e).document().write(Al()(n2, t, true))
      )
    );
  }
);
function Fl(n2 = {}) {
  const t = Vt(
    {
      transforms: [],
      canContainEols: [
        "emphasis",
        "fragment",
        "heading",
        "paragraph",
        "strong"
      ],
      enter: {
        autolink: c(Me),
        autolinkProtocol: O,
        autolinkEmail: O,
        atxHeading: c(Bn),
        blockQuote: c(P),
        characterEscape: O,
        characterReference: O,
        codeFenced: c(gn),
        codeFencedFenceInfo: s,
        codeFencedFenceMeta: s,
        codeIndented: c(gn, s),
        codeText: c(A, s),
        codeTextData: O,
        data: O,
        codeFlowValue: O,
        definition: c(On),
        definitionDestinationString: s,
        definitionLabelString: s,
        definitionTitleString: s,
        emphasis: c(_n),
        hardBreakEscape: c(Le),
        hardBreakTrailing: c(Le),
        htmlFlow: c(ze, s),
        htmlFlowData: O,
        htmlText: c(ze, s),
        htmlTextData: O,
        image: c(ir),
        label: s,
        link: c(Me),
        listItem: c(lr),
        listItemValue: g,
        listOrdered: c(Fe, w),
        listUnordered: c(Fe),
        paragraph: c(or),
        reference: I,
        referenceString: s,
        resourceDestinationString: s,
        resourceTitleString: s,
        setextHeading: c(Bn),
        strong: c(ar),
        thematicBreak: c(sr)
      },
      exit: {
        atxHeading: p(),
        atxHeadingSequence: q,
        autolink: p(),
        autolinkEmail: fn,
        autolinkProtocol: V,
        blockQuote: p(),
        characterEscapeValue: W,
        characterReferenceMarkerHexadecimal: j,
        characterReferenceMarkerNumeric: j,
        characterReferenceValue: Q,
        codeFenced: p(v),
        codeFencedFence: M,
        codeFencedFenceInfo: y,
        codeFencedFenceMeta: k,
        codeFlowValue: W,
        codeIndented: p(L),
        codeText: p(hn),
        codeTextData: W,
        data: W,
        definition: p(),
        definitionDestinationString: R,
        definitionLabelString: S,
        definitionTitleString: x,
        emphasis: p(),
        hardBreakEscape: p(Y),
        hardBreakTrailing: p(Y),
        htmlFlow: p(tn),
        htmlFlowData: W,
        htmlText: p(ln),
        htmlTextData: W,
        image: p(u),
        label: F,
        labelText: T,
        lineEnding: en,
        link: p(mn),
        listItem: p(),
        listOrdered: p(),
        listUnordered: p(),
        paragraph: p(),
        referenceString: B,
        resourceDestinationString: f,
        resourceTitleString: z,
        resource: H,
        setextHeading: p(_),
        setextHeadingLineSequence: sn,
        setextHeadingText: X,
        strong: p(),
        thematicBreak: p()
      }
    },
    n2.mdastExtensions || []
  ), e = {};
  return r;
  function r(b) {
    let C = {
      type: "root",
      children: []
    };
    const N = [C], rn = [], kn = [], jn = {
      stack: N,
      tokenStack: rn,
      config: t,
      enter: d,
      exit: m,
      buffer: s,
      resume: h,
      setData: l,
      getData: o
    };
    let un = -1;
    for (; ++un < b.length; )
      if (b[un][1].type === "listOrdered" || b[un][1].type === "listUnordered")
        if (b[un][0] === "enter")
          kn.push(un);
        else {
          const dn = kn.pop();
          un = i(b, dn, un);
        }
    for (un = -1; ++un < b.length; ) {
      const dn = t[b[un][0]];
      Se.call(dn, b[un][1].type) && dn[b[un][1].type].call(
        Object.assign(
          {
            sliceSerialize: b[un][2].sliceSerialize
          },
          jn
        ),
        b[un][1]
      );
    }
    if (rn.length > 0) {
      const dn = rn[rn.length - 1];
      (dn[1] || ut).call(jn, void 0, dn[0]);
    }
    for (C.position = {
      start: a(
        b.length > 0 ? b[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: a(
        b.length > 0 ? b[b.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, un = -1; ++un < t.transforms.length; )
      C = t.transforms[un](C) || C;
    return C;
  }
  function i(b, C, N) {
    let rn = C - 1, kn = -1, jn = false, un, dn, Ln, $n;
    for (; ++rn <= N; ) {
      const cn = b[rn];
      if (cn[1].type === "listUnordered" || cn[1].type === "listOrdered" || cn[1].type === "blockQuote" ? (cn[0] === "enter" ? kn++ : kn--, $n = void 0) : cn[1].type === "lineEndingBlank" ? cn[0] === "enter" && (un && !$n && !kn && !Ln && (Ln = rn), $n = void 0) : cn[1].type === "linePrefix" || cn[1].type === "listItemValue" || cn[1].type === "listItemMarker" || cn[1].type === "listItemPrefix" || cn[1].type === "listItemPrefixWhitespace" || ($n = void 0), !kn && cn[0] === "enter" && cn[1].type === "listItemPrefix" || kn === -1 && cn[0] === "exit" && (cn[1].type === "listUnordered" || cn[1].type === "listOrdered")) {
        if (un) {
          let Jn = rn;
          for (dn = void 0; Jn--; ) {
            const Pn = b[Jn];
            if (Pn[1].type === "lineEnding" || Pn[1].type === "lineEndingBlank") {
              if (Pn[0] === "exit")
                continue;
              dn && (b[dn][1].type = "lineEndingBlank", jn = true), Pn[1].type = "lineEnding", dn = Jn;
            } else if (!(Pn[1].type === "linePrefix" || Pn[1].type === "blockQuotePrefix" || Pn[1].type === "blockQuotePrefixWhitespace" || Pn[1].type === "blockQuoteMarker" || Pn[1].type === "listItemIndent"))
              break;
          }
          Ln && (!dn || Ln < dn) && (un._spread = true), un.end = Object.assign(
            {},
            dn ? b[dn][1].start : cn[1].end
          ), b.splice(dn || rn, 0, ["exit", un, cn[2]]), rn++, N++;
        }
        cn[1].type === "listItemPrefix" && (un = {
          type: "listItem",
          // @ts-expect-error Patched
          _spread: false,
          start: Object.assign({}, cn[1].start)
        }, b.splice(rn, 0, ["enter", un, cn[2]]), rn++, N++, Ln = void 0, $n = true);
      }
    }
    return b[C][1]._spread = jn, N;
  }
  function l(b, C) {
    e[b] = C;
  }
  function o(b) {
    return e[b];
  }
  function a(b) {
    return {
      line: b.line,
      column: b.column,
      offset: b.offset
    };
  }
  function c(b, C) {
    return N;
    function N(rn) {
      d.call(this, b(rn), rn), C && C.call(this, rn);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function d(b, C, N) {
    return this.stack[this.stack.length - 1].children.push(b), this.stack.push(b), this.tokenStack.push([C, N]), b.position = {
      start: a(C.start)
    }, b;
  }
  function p(b) {
    return C;
    function C(N) {
      b && b.call(this, N), m.call(this, N);
    }
  }
  function m(b, C) {
    const N = this.stack.pop(), rn = this.tokenStack.pop();
    if (rn)
      rn[0].type !== b.type && (C ? C.call(this, b, rn[0]) : (rn[1] || ut).call(this, b, rn[0]));
    else
      throw new Error(
        "Cannot close `" + b.type + "` (" + qn({
          start: b.start,
          end: b.end
        }) + "): it’s not open"
      );
    return N.position.end = a(b.end), N;
  }
  function h() {
    return Ur(this.stack.pop());
  }
  function w() {
    l("expectingFirstListItemValue", true);
  }
  function g(b) {
    if (o("expectingFirstListItemValue")) {
      const C = (
        /** @type {List} */
        this.stack[this.stack.length - 2]
      );
      C.start = Number.parseInt(this.sliceSerialize(b), 10), l("expectingFirstListItemValue");
    }
  }
  function y() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.lang = b;
  }
  function k() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.meta = b;
  }
  function M() {
    o("flowCodeInside") || (this.buffer(), l("flowCodeInside", true));
  }
  function v() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.value = b.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), l("flowCodeInside");
  }
  function L() {
    const b = this.resume(), C = (
      /** @type {Code} */
      this.stack[this.stack.length - 1]
    );
    C.value = b.replace(/(\r?\n|\r)$/g, "");
  }
  function S(b) {
    const C = this.resume(), N = (
      /** @type {Definition} */
      this.stack[this.stack.length - 1]
    );
    N.label = C, N.identifier = Mn(
      this.sliceSerialize(b)
    ).toLowerCase();
  }
  function x() {
    const b = this.resume(), C = (
      /** @type {Definition} */
      this.stack[this.stack.length - 1]
    );
    C.title = b;
  }
  function R() {
    const b = this.resume(), C = (
      /** @type {Definition} */
      this.stack[this.stack.length - 1]
    );
    C.url = b;
  }
  function q(b) {
    const C = (
      /** @type {Heading} */
      this.stack[this.stack.length - 1]
    );
    if (!C.depth) {
      const N = this.sliceSerialize(b).length;
      C.depth = N;
    }
  }
  function X() {
    l("setextHeadingSlurpLineEnding", true);
  }
  function sn(b) {
    const C = (
      /** @type {Heading} */
      this.stack[this.stack.length - 1]
    );
    C.depth = this.sliceSerialize(b).charCodeAt(0) === 61 ? 1 : 2;
  }
  function _() {
    l("setextHeadingSlurpLineEnding");
  }
  function O(b) {
    const C = (
      /** @type {Parent} */
      this.stack[this.stack.length - 1]
    );
    let N = C.children[C.children.length - 1];
    (!N || N.type !== "text") && (N = ur(), N.position = {
      start: a(b.start)
    }, C.children.push(N)), this.stack.push(N);
  }
  function W(b) {
    const C = this.stack.pop();
    C.value += this.sliceSerialize(b), C.position.end = a(b.end);
  }
  function en(b) {
    const C = this.stack[this.stack.length - 1];
    if (o("atHardBreak")) {
      const N = C.children[C.children.length - 1];
      N.position.end = a(b.end), l("atHardBreak");
      return;
    }
    !o("setextHeadingSlurpLineEnding") && t.canContainEols.includes(C.type) && (O.call(this, b), W.call(this, b));
  }
  function Y() {
    l("atHardBreak", true);
  }
  function tn() {
    const b = this.resume(), C = (
      /** @type {HTML} */
      this.stack[this.stack.length - 1]
    );
    C.value = b;
  }
  function ln() {
    const b = this.resume(), C = (
      /** @type {HTML} */
      this.stack[this.stack.length - 1]
    );
    C.value = b;
  }
  function hn() {
    const b = this.resume(), C = (
      /** @type {InlineCode} */
      this.stack[this.stack.length - 1]
    );
    C.value = b;
  }
  function mn() {
    const b = (
      /** @type {Link & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]
    );
    o("inReference") ? (b.type += "Reference", b.referenceType = o("referenceType") || "shortcut", delete b.url, delete b.title) : (delete b.identifier, delete b.label), l("referenceType");
  }
  function u() {
    const b = (
      /** @type {Image & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]
    );
    o("inReference") ? (b.type += "Reference", b.referenceType = o("referenceType") || "shortcut", delete b.url, delete b.title) : (delete b.identifier, delete b.label), l("referenceType");
  }
  function T(b) {
    const C = (
      /** @type {(Link|Image) & {identifier: string, label: string}} */
      this.stack[this.stack.length - 2]
    ), N = this.sliceSerialize(b);
    C.label = Ll(N), C.identifier = Mn(N).toLowerCase();
  }
  function F() {
    const b = (
      /** @type {Fragment} */
      this.stack[this.stack.length - 1]
    ), C = this.resume(), N = (
      /** @type {(Link|Image) & {identifier: string, label: string}} */
      this.stack[this.stack.length - 1]
    );
    l("inReference", true), N.type === "link" ? N.children = b.children : N.alt = C;
  }
  function f() {
    const b = this.resume(), C = (
      /** @type {Link|Image} */
      this.stack[this.stack.length - 1]
    );
    C.url = b;
  }
  function z() {
    const b = this.resume(), C = (
      /** @type {Link|Image} */
      this.stack[this.stack.length - 1]
    );
    C.title = b;
  }
  function H() {
    l("inReference");
  }
  function I() {
    l("referenceType", "collapsed");
  }
  function B(b) {
    const C = this.resume(), N = (
      /** @type {LinkReference|ImageReference} */
      this.stack[this.stack.length - 1]
    );
    N.label = C, N.identifier = Mn(
      this.sliceSerialize(b)
    ).toLowerCase(), l("referenceType", "full");
  }
  function j(b) {
    l("characterReferenceType", b.type);
  }
  function Q(b) {
    const C = this.sliceSerialize(b), N = o("characterReferenceType");
    let rn;
    N ? (rn = Ht(
      C,
      N === "characterReferenceMarkerNumeric" ? 10 : 16
    ), l("characterReferenceType")) : rn = Oe(C);
    const kn = this.stack.pop();
    kn.value += rn, kn.position.end = a(b.end);
  }
  function V(b) {
    W.call(this, b);
    const C = (
      /** @type {Link} */
      this.stack[this.stack.length - 1]
    );
    C.url = this.sliceSerialize(b);
  }
  function fn(b) {
    W.call(this, b);
    const C = (
      /** @type {Link} */
      this.stack[this.stack.length - 1]
    );
    C.url = "mailto:" + this.sliceSerialize(b);
  }
  function P() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function gn() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function A() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function On() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function _n() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Bn() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function Le() {
    return {
      type: "break"
    };
  }
  function ze() {
    return {
      type: "html",
      value: ""
    };
  }
  function ir() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Me() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Fe(b) {
    return {
      type: "list",
      ordered: b.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: b._spread,
      children: []
    };
  }
  function lr(b) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: b._spread,
      checked: null,
      children: []
    };
  }
  function or() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ar() {
    return {
      type: "strong",
      children: []
    };
  }
  function ur() {
    return {
      type: "text",
      value: ""
    };
  }
  function sr() {
    return {
      type: "thematicBreak"
    };
  }
}
function Vt(n2, t) {
  let e = -1;
  for (; ++e < t.length; ) {
    const r = t[e];
    Array.isArray(r) ? Vt(n2, r) : Dl(n2, r);
  }
  return n2;
}
function Dl(n2, t) {
  let e;
  for (e in t)
    if (Se.call(t, e)) {
      const r = e === "canContainEols" || e === "transforms", l = (Se.call(n2, e) ? n2[e] : void 0) || (n2[e] = r ? [] : {}), o = t[e];
      o && (r ? n2[e] = [...l, ...o] : Object.assign(l, o));
    }
}
function ut(n2, t) {
  throw n2 ? new Error(
    "Cannot close `" + n2.type + "` (" + qn({
      start: n2.start,
      end: n2.end
    }) + "): a different token (`" + t.type + "`, " + qn({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + qn({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function Bl(n2) {
  Object.assign(this, { Parser: (e) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return Ml(
      e,
      Object.assign({}, r, n2, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
var we = { exports: {} };
var ae;
var st;
function Ae() {
  if (st)
    return ae;
  st = 1;
  var n2 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ae = n2, ae;
}
var Wn = { exports: {} };
var G = {};
var ft;
function $l() {
  return ft || (ft = 1, function() {
    var n2 = typeof Symbol == "function" && Symbol.for, t = n2 ? Symbol.for("react.element") : 60103, e = n2 ? Symbol.for("react.portal") : 60106, r = n2 ? Symbol.for("react.fragment") : 60107, i = n2 ? Symbol.for("react.strict_mode") : 60108, l = n2 ? Symbol.for("react.profiler") : 60114, o = n2 ? Symbol.for("react.provider") : 60109, a = n2 ? Symbol.for("react.context") : 60110, c = n2 ? Symbol.for("react.async_mode") : 60111, s = n2 ? Symbol.for("react.concurrent_mode") : 60111, d = n2 ? Symbol.for("react.forward_ref") : 60112, p = n2 ? Symbol.for("react.suspense") : 60113, m = n2 ? Symbol.for("react.suspense_list") : 60120, h = n2 ? Symbol.for("react.memo") : 60115, w = n2 ? Symbol.for("react.lazy") : 60116, g = n2 ? Symbol.for("react.block") : 60121, y = n2 ? Symbol.for("react.fundamental") : 60117, k = n2 ? Symbol.for("react.responder") : 60118, M = n2 ? Symbol.for("react.scope") : 60119;
    function v(P) {
      return typeof P == "string" || typeof P == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      P === r || P === s || P === l || P === i || P === p || P === m || typeof P == "object" && P !== null && (P.$$typeof === w || P.$$typeof === h || P.$$typeof === o || P.$$typeof === a || P.$$typeof === d || P.$$typeof === y || P.$$typeof === k || P.$$typeof === M || P.$$typeof === g);
    }
    function L(P) {
      if (typeof P == "object" && P !== null) {
        var gn = P.$$typeof;
        switch (gn) {
          case t:
            var A = P.type;
            switch (A) {
              case c:
              case s:
              case r:
              case l:
              case i:
              case p:
                return A;
              default:
                var On = A && A.$$typeof;
                switch (On) {
                  case a:
                  case d:
                  case w:
                  case h:
                  case o:
                    return On;
                  default:
                    return gn;
                }
            }
          case e:
            return gn;
        }
      }
    }
    var S = c, x = s, R = a, q = o, X = t, sn = d, _ = r, O = w, W = h, en = e, Y = l, tn = i, ln = p, hn = false;
    function mn(P) {
      return hn || (hn = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), u(P) || L(P) === c;
    }
    function u(P) {
      return L(P) === s;
    }
    function T(P) {
      return L(P) === a;
    }
    function F(P) {
      return L(P) === o;
    }
    function f(P) {
      return typeof P == "object" && P !== null && P.$$typeof === t;
    }
    function z(P) {
      return L(P) === d;
    }
    function H(P) {
      return L(P) === r;
    }
    function I(P) {
      return L(P) === w;
    }
    function B(P) {
      return L(P) === h;
    }
    function j(P) {
      return L(P) === e;
    }
    function Q(P) {
      return L(P) === l;
    }
    function V(P) {
      return L(P) === i;
    }
    function fn(P) {
      return L(P) === p;
    }
    G.AsyncMode = S, G.ConcurrentMode = x, G.ContextConsumer = R, G.ContextProvider = q, G.Element = X, G.ForwardRef = sn, G.Fragment = _, G.Lazy = O, G.Memo = W, G.Portal = en, G.Profiler = Y, G.StrictMode = tn, G.Suspense = ln, G.isAsyncMode = mn, G.isConcurrentMode = u, G.isContextConsumer = T, G.isContextProvider = F, G.isElement = f, G.isForwardRef = z, G.isFragment = H, G.isLazy = I, G.isMemo = B, G.isPortal = j, G.isProfiler = Q, G.isStrictMode = V, G.isSuspense = fn, G.isValidElementType = v, G.typeOf = L;
  }()), G;
}
var ht;
function Yt() {
  return ht || (ht = 1, false ? Wn.exports = Nl() : Wn.exports = $l()), Wn.exports;
}
var se;
var dt;
function ql() {
  if (dt)
    return se;
  dt = 1;
  var n2 = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
  function r(l) {
    if (l == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(l);
  }
  function i() {
    try {
      if (!Object.assign)
        return false;
      var l = new String("abc");
      if (l[5] = "de", Object.getOwnPropertyNames(l)[0] === "5")
        return false;
      for (var o = {}, a = 0; a < 10; a++)
        o["_" + String.fromCharCode(a)] = a;
      var c = Object.getOwnPropertyNames(o).map(function(d) {
        return o[d];
      });
      if (c.join("") !== "0123456789")
        return false;
      var s = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(d) {
        s[d] = d;
      }), Object.keys(Object.assign({}, s)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return false;
    }
  }
  return se = i() ? Object.assign : function(l, o) {
    for (var a, c = r(l), s, d = 1; d < arguments.length; d++) {
      a = Object(arguments[d]);
      for (var p in a)
        t.call(a, p) && (c[p] = a[p]);
      if (n2) {
        s = n2(a);
        for (var m = 0; m < s.length; m++)
          e.call(a, s[m]) && (c[s[m]] = a[s[m]]);
      }
    }
    return c;
  }, se;
}
var ce;
var mt;
function Wt() {
  return mt || (mt = 1, ce = Function.call.bind(Object.prototype.hasOwnProperty)), ce;
}
var fe;
var gt;
function Ul() {
  if (gt)
    return fe;
  gt = 1;
  var n2 = function() {
  };
  if (true) {
    var t = Ae(), e = {}, r = Wt();
    n2 = function(l) {
      var o = "Warning: " + l;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(l, o, a, c, s) {
    if (true) {
      for (var d in l)
        if (r(l, d)) {
          var p;
          try {
            if (typeof l[d] != "function") {
              var m = Error(
                (c || "React class") + ": " + a + " type `" + d + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof l[d] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw m.name = "Invariant Violation", m;
            }
            p = l[d](o, d, c, a, null, t);
          } catch (w) {
            p = w;
          }
          if (p && !(p instanceof Error) && n2(
            (c || "React class") + ": type specification of " + a + " `" + d + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in e)) {
            e[p.message] = true;
            var h = s ? s() : "";
            n2(
              "Failed " + a + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    e = {};
  }, fe = i, fe;
}
var pe;
var yt;
function Hl() {
  if (yt)
    return pe;
  yt = 1;
  var n2 = Yt(), t = ql(), e = Ae(), r = Wt(), i = Ul(), l = function() {
  };
  l = function(a) {
    var c = "Warning: " + a;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  };
  function o() {
    return null;
  }
  return pe = function(a, c) {
    var s = typeof Symbol == "function" && Symbol.iterator, d = "@@iterator";
    function p(u) {
      var T = u && (s && u[s] || u[d]);
      if (typeof T == "function")
        return T;
    }
    var m = "<<anonymous>>", h = {
      array: k("array"),
      bigint: k("bigint"),
      bool: k("boolean"),
      func: k("function"),
      number: k("number"),
      object: k("object"),
      string: k("string"),
      symbol: k("symbol"),
      any: M(),
      arrayOf: v,
      element: L(),
      elementType: S(),
      instanceOf: x,
      node: sn(),
      objectOf: q,
      oneOf: R,
      oneOfType: X,
      shape: O,
      exact: W
    };
    function w(u, T) {
      return u === T ? u !== 0 || 1 / u === 1 / T : u !== u && T !== T;
    }
    function g(u, T) {
      this.message = u, this.data = T && typeof T == "object" ? T : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function y(u) {
      if (true)
        var T = {}, F = 0;
      function f(H, I, B, j, Q, V, fn) {
        if (j = j || m, V = V || B, fn !== e) {
          if (c) {
            var P = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw P.name = "Invariant Violation", P;
          } else if (typeof console < "u") {
            var gn = j + ":" + B;
            !T[gn] && // Avoid spamming the console because they are often not actionable except for lib authors
            F < 3 && (l(
              "You are manually calling a React.PropTypes validation function for the `" + V + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), T[gn] = true, F++);
          }
        }
        return I[B] == null ? H ? I[B] === null ? new g("The " + Q + " `" + V + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new g("The " + Q + " `" + V + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : u(I, B, j, Q, V);
      }
      var z = f.bind(null, false);
      return z.isRequired = f.bind(null, true), z;
    }
    function k(u) {
      function T(F, f, z, H, I, B) {
        var j = F[f], Q = tn(j);
        if (Q !== u) {
          var V = ln(j);
          return new g(
            "Invalid " + H + " `" + I + "` of type " + ("`" + V + "` supplied to `" + z + "`, expected ") + ("`" + u + "`."),
            { expectedType: u }
          );
        }
        return null;
      }
      return y(T);
    }
    function M() {
      return y(o);
    }
    function v(u) {
      function T(F, f, z, H, I) {
        if (typeof u != "function")
          return new g("Property `" + I + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var B = F[f];
        if (!Array.isArray(B)) {
          var j = tn(B);
          return new g("Invalid " + H + " `" + I + "` of type " + ("`" + j + "` supplied to `" + z + "`, expected an array."));
        }
        for (var Q = 0; Q < B.length; Q++) {
          var V = u(B, Q, z, H, I + "[" + Q + "]", e);
          if (V instanceof Error)
            return V;
        }
        return null;
      }
      return y(T);
    }
    function L() {
      function u(T, F, f, z, H) {
        var I = T[F];
        if (!a(I)) {
          var B = tn(I);
          return new g("Invalid " + z + " `" + H + "` of type " + ("`" + B + "` supplied to `" + f + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(u);
    }
    function S() {
      function u(T, F, f, z, H) {
        var I = T[F];
        if (!n2.isValidElementType(I)) {
          var B = tn(I);
          return new g("Invalid " + z + " `" + H + "` of type " + ("`" + B + "` supplied to `" + f + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(u);
    }
    function x(u) {
      function T(F, f, z, H, I) {
        if (!(F[f] instanceof u)) {
          var B = u.name || m, j = mn(F[f]);
          return new g("Invalid " + H + " `" + I + "` of type " + ("`" + j + "` supplied to `" + z + "`, expected ") + ("instance of `" + B + "`."));
        }
        return null;
      }
      return y(T);
    }
    function R(u) {
      if (!Array.isArray(u))
        return arguments.length > 1 ? l(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : l("Invalid argument supplied to oneOf, expected an array."), o;
      function T(F, f, z, H, I) {
        for (var B = F[f], j = 0; j < u.length; j++)
          if (w(B, u[j]))
            return null;
        var Q = JSON.stringify(u, function(fn, P) {
          var gn = ln(P);
          return gn === "symbol" ? String(P) : P;
        });
        return new g("Invalid " + H + " `" + I + "` of value `" + String(B) + "` " + ("supplied to `" + z + "`, expected one of " + Q + "."));
      }
      return y(T);
    }
    function q(u) {
      function T(F, f, z, H, I) {
        if (typeof u != "function")
          return new g("Property `" + I + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var B = F[f], j = tn(B);
        if (j !== "object")
          return new g("Invalid " + H + " `" + I + "` of type " + ("`" + j + "` supplied to `" + z + "`, expected an object."));
        for (var Q in B)
          if (r(B, Q)) {
            var V = u(B, Q, z, H, I + "." + Q, e);
            if (V instanceof Error)
              return V;
          }
        return null;
      }
      return y(T);
    }
    function X(u) {
      if (!Array.isArray(u))
        return l("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var T = 0; T < u.length; T++) {
        var F = u[T];
        if (typeof F != "function")
          return l(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + hn(F) + " at index " + T + "."
          ), o;
      }
      function f(z, H, I, B, j) {
        for (var Q = [], V = 0; V < u.length; V++) {
          var fn = u[V], P = fn(z, H, I, B, j, e);
          if (P == null)
            return null;
          P.data && r(P.data, "expectedType") && Q.push(P.data.expectedType);
        }
        var gn = Q.length > 0 ? ", expected one of type [" + Q.join(", ") + "]" : "";
        return new g("Invalid " + B + " `" + j + "` supplied to " + ("`" + I + "`" + gn + "."));
      }
      return y(f);
    }
    function sn() {
      function u(T, F, f, z, H) {
        return en(T[F]) ? null : new g("Invalid " + z + " `" + H + "` supplied to " + ("`" + f + "`, expected a ReactNode."));
      }
      return y(u);
    }
    function _(u, T, F, f, z) {
      return new g(
        (u || "React class") + ": " + T + " type `" + F + "." + f + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function O(u) {
      function T(F, f, z, H, I) {
        var B = F[f], j = tn(B);
        if (j !== "object")
          return new g("Invalid " + H + " `" + I + "` of type `" + j + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var Q in u) {
          var V = u[Q];
          if (typeof V != "function")
            return _(z, H, I, Q, ln(V));
          var fn = V(B, Q, z, H, I + "." + Q, e);
          if (fn)
            return fn;
        }
        return null;
      }
      return y(T);
    }
    function W(u) {
      function T(F, f, z, H, I) {
        var B = F[f], j = tn(B);
        if (j !== "object")
          return new g("Invalid " + H + " `" + I + "` of type `" + j + "` " + ("supplied to `" + z + "`, expected `object`."));
        var Q = t({}, F[f], u);
        for (var V in Q) {
          var fn = u[V];
          if (r(u, V) && typeof fn != "function")
            return _(z, H, I, V, ln(fn));
          if (!fn)
            return new g(
              "Invalid " + H + " `" + I + "` key `" + V + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(F[f], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(u), null, "  ")
            );
          var P = fn(B, V, z, H, I + "." + V, e);
          if (P)
            return P;
        }
        return null;
      }
      return y(T);
    }
    function en(u) {
      switch (typeof u) {
        case "number":
        case "string":
        case "undefined":
          return true;
        case "boolean":
          return !u;
        case "object":
          if (Array.isArray(u))
            return u.every(en);
          if (u === null || a(u))
            return true;
          var T = p(u);
          if (T) {
            var F = T.call(u), f;
            if (T !== u.entries) {
              for (; !(f = F.next()).done; )
                if (!en(f.value))
                  return false;
            } else
              for (; !(f = F.next()).done; ) {
                var z = f.value;
                if (z && !en(z[1]))
                  return false;
              }
          } else
            return false;
          return true;
        default:
          return false;
      }
    }
    function Y(u, T) {
      return u === "symbol" ? true : T ? T["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && T instanceof Symbol : false;
    }
    function tn(u) {
      var T = typeof u;
      return Array.isArray(u) ? "array" : u instanceof RegExp ? "object" : Y(T, u) ? "symbol" : T;
    }
    function ln(u) {
      if (typeof u > "u" || u === null)
        return "" + u;
      var T = tn(u);
      if (T === "object") {
        if (u instanceof Date)
          return "date";
        if (u instanceof RegExp)
          return "regexp";
      }
      return T;
    }
    function hn(u) {
      var T = ln(u);
      switch (T) {
        case "array":
        case "object":
          return "an " + T;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + T;
        default:
          return T;
      }
    }
    function mn(u) {
      return !u.constructor || !u.constructor.name ? m : u.constructor.name;
    }
    return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
  }, pe;
}
if (true) {
  Vl = Yt(), Yl = true;
  we.exports = Hl()(Vl.isElement, Yl);
} else
  we.exports = jl()();
var Vl;
var Yl;
var Wl = we.exports;
var $ = bc(Wl);
var Yn = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, e, r) {
    this.property = t, this.normal = e, r && (this.space = r);
  }
};
Yn.prototype.property = {};
Yn.prototype.normal = {};
Yn.prototype.space = null;
function Qt(n2, t) {
  const e = {}, r = {};
  let i = -1;
  for (; ++i < n2.length; )
    Object.assign(e, n2[i].property), Object.assign(r, n2[i].normal);
  return new Yn(e, r, t);
}
function Ee(n2) {
  return n2.toLowerCase();
}
var En = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, e) {
    this.property = t, this.attribute = e;
  }
};
En.prototype.space = null;
En.prototype.boolean = false;
En.prototype.booleanish = false;
En.prototype.overloadedBoolean = false;
En.prototype.number = false;
En.prototype.commaSeparated = false;
En.prototype.spaceSeparated = false;
En.prototype.commaOrSpaceSeparated = false;
En.prototype.mustUseProperty = false;
En.prototype.defined = false;
var Ql = 0;
var U = Rn();
var pn = Rn();
var Xt = Rn();
var E = Rn();
var on = Rn();
var Fn = Rn();
var xn = Rn();
function Rn() {
  return 2 ** ++Ql;
}
var ve = Object.freeze(Object.defineProperty({
  __proto__: null,
  boolean: U,
  booleanish: pn,
  commaOrSpaceSeparated: xn,
  commaSeparated: Fn,
  number: E,
  overloadedBoolean: Xt,
  spaceSeparated: on
}, Symbol.toStringTag, { value: "Module" }));
var he = Object.keys(ve);
var Re = class extends En {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, e, r, i) {
    let l = -1;
    if (super(t, e), xt(this, "space", i), typeof r == "number")
      for (; ++l < he.length; ) {
        const o = he[l];
        xt(this, he[l], (r & ve[o]) === ve[o]);
      }
  }
};
Re.prototype.defined = true;
function xt(n2, t, e) {
  e && (n2[t] = e);
}
var Xl = {}.hasOwnProperty;
function Dn(n2) {
  const t = {}, e = {};
  let r;
  for (r in n2.properties)
    if (Xl.call(n2.properties, r)) {
      const i = n2.properties[r], l = new Re(
        r,
        n2.transform(n2.attributes || {}, r),
        i,
        n2.space
      );
      n2.mustUseProperty && n2.mustUseProperty.includes(r) && (l.mustUseProperty = true), t[r] = l, e[Ee(r)] = r, e[Ee(l.attribute)] = r;
    }
  return new Yn(t, e, n2.space);
}
var Kt = Dn({
  space: "xlink",
  transform(n2, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
var Gt = Dn({
  space: "xml",
  transform(n2, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Jt(n2, t) {
  return t in n2 ? n2[t] : t;
}
function Zt(n2, t) {
  return Jt(n2, t.toLowerCase());
}
var nr = Dn({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Zt,
  properties: { xmlns: null, xmlnsXLink: null }
});
var er = Dn({
  transform(n2, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: pn,
    ariaAutoComplete: null,
    ariaBusy: pn,
    ariaChecked: pn,
    ariaColCount: E,
    ariaColIndex: E,
    ariaColSpan: E,
    ariaControls: on,
    ariaCurrent: null,
    ariaDescribedBy: on,
    ariaDetails: null,
    ariaDisabled: pn,
    ariaDropEffect: on,
    ariaErrorMessage: null,
    ariaExpanded: pn,
    ariaFlowTo: on,
    ariaGrabbed: pn,
    ariaHasPopup: null,
    ariaHidden: pn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: on,
    ariaLevel: E,
    ariaLive: null,
    ariaModal: pn,
    ariaMultiLine: pn,
    ariaMultiSelectable: pn,
    ariaOrientation: null,
    ariaOwns: on,
    ariaPlaceholder: null,
    ariaPosInSet: E,
    ariaPressed: pn,
    ariaReadOnly: pn,
    ariaRelevant: null,
    ariaRequired: pn,
    ariaRoleDescription: on,
    ariaRowCount: E,
    ariaRowIndex: E,
    ariaRowSpan: E,
    ariaSelected: pn,
    ariaSetSize: E,
    ariaSort: null,
    ariaValueMax: E,
    ariaValueMin: E,
    ariaValueNow: E,
    ariaValueText: null,
    role: null
  }
});
var Kl = Dn({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Zt,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Fn,
    acceptCharset: on,
    accessKey: on,
    action: null,
    allow: null,
    allowFullScreen: U,
    allowPaymentRequest: U,
    allowUserMedia: U,
    alt: null,
    as: null,
    async: U,
    autoCapitalize: null,
    autoComplete: on,
    autoFocus: U,
    autoPlay: U,
    blocking: on,
    capture: U,
    charSet: null,
    checked: U,
    cite: null,
    className: on,
    cols: E,
    colSpan: null,
    content: null,
    contentEditable: pn,
    controls: U,
    controlsList: on,
    coords: E | Fn,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: U,
    defer: U,
    dir: null,
    dirName: null,
    disabled: U,
    download: Xt,
    draggable: pn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: U,
    formTarget: null,
    headers: on,
    height: E,
    hidden: U,
    high: E,
    href: null,
    hrefLang: null,
    htmlFor: on,
    httpEquiv: on,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: U,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: U,
    itemId: null,
    itemProp: on,
    itemRef: on,
    itemScope: U,
    itemType: on,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: U,
    low: E,
    manifest: null,
    max: null,
    maxLength: E,
    media: null,
    method: null,
    min: null,
    minLength: E,
    multiple: U,
    muted: U,
    name: null,
    nonce: null,
    noModule: U,
    noValidate: U,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: U,
    optimum: E,
    pattern: null,
    ping: on,
    placeholder: null,
    playsInline: U,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: U,
    referrerPolicy: null,
    rel: on,
    required: U,
    reversed: U,
    rows: E,
    rowSpan: E,
    sandbox: on,
    scope: null,
    scoped: U,
    seamless: U,
    selected: U,
    shadowRootDelegatesFocus: U,
    shadowRootMode: null,
    shape: null,
    size: E,
    sizes: null,
    slot: null,
    span: E,
    spellCheck: pn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: E,
    step: null,
    style: null,
    tabIndex: E,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: U,
    useMap: null,
    value: pn,
    width: E,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: on,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: E,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: E,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: U,
    // Lists. Use CSS to reduce space between items instead
    declare: U,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: E,
    // `<img>` and `<object>`
    leftMargin: E,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: E,
    // `<body>`
    marginWidth: E,
    // `<body>`
    noResize: U,
    // `<frame>`
    noHref: U,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: U,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: U,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: E,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: pn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: E,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: E,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: U,
    disableRemotePlayback: U,
    prefix: null,
    property: null,
    results: E,
    security: null,
    unselectable: null
  }
});
var Gl = Dn({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Jt,
  properties: {
    about: xn,
    accentHeight: E,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: E,
    amplitude: E,
    arabicForm: null,
    ascent: E,
    attributeName: null,
    attributeType: null,
    azimuth: E,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: E,
    by: null,
    calcMode: null,
    capHeight: E,
    className: on,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: E,
    diffuseConstant: E,
    direction: null,
    display: null,
    dur: null,
    divisor: E,
    dominantBaseline: null,
    download: U,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: E,
    enableBackground: null,
    end: null,
    event: null,
    exponent: E,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: E,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Fn,
    g2: Fn,
    glyphName: Fn,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: E,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: E,
    horizOriginX: E,
    horizOriginY: E,
    id: null,
    ideographic: E,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: E,
    k: E,
    k1: E,
    k2: E,
    k3: E,
    k4: E,
    kernelMatrix: xn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: E,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: E,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: E,
    overlineThickness: E,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: E,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: on,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: E,
    pointsAtY: E,
    pointsAtZ: E,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: xn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: xn,
    rev: xn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: xn,
    requiredFeatures: xn,
    requiredFonts: xn,
    requiredFormats: xn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: E,
    specularExponent: E,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: E,
    strikethroughThickness: E,
    string: null,
    stroke: null,
    strokeDashArray: xn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: E,
    strokeOpacity: E,
    strokeWidth: null,
    style: null,
    surfaceScale: E,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: xn,
    tabIndex: E,
    tableValues: null,
    target: null,
    targetX: E,
    targetY: E,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: xn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: E,
    underlineThickness: E,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: E,
    values: null,
    vAlphabetic: E,
    vMathematical: E,
    vectorEffect: null,
    vHanging: E,
    vIdeographic: E,
    version: null,
    vertAdvY: E,
    vertOriginX: E,
    vertOriginY: E,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: E,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var Jl = /^data[-\w.:]+$/i;
var bt = /-[a-z]/g;
var Zl = /[A-Z]/g;
function no(n2, t) {
  const e = Ee(t);
  let r = t, i = En;
  if (e in n2.normal)
    return n2.property[n2.normal[e]];
  if (e.length > 4 && e.slice(0, 4) === "data" && Jl.test(t)) {
    if (t.charAt(4) === "-") {
      const l = t.slice(5).replace(bt, to);
      r = "data" + l.charAt(0).toUpperCase() + l.slice(1);
    } else {
      const l = t.slice(4);
      if (!bt.test(l)) {
        let o = l.replace(Zl, eo);
        o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o;
      }
    }
    i = Re;
  }
  return new i(r, t);
}
function eo(n2) {
  return "-" + n2.toLowerCase();
}
function to(n2) {
  return n2.charAt(1).toUpperCase();
}
var kt = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
var ro = Qt([Gt, Kt, nr, er, Kl], "html");
var io = Qt([Gt, Kt, nr, er, Gl], "svg");
function lo(n2) {
  if (n2.allowedElements && n2.disallowedElements)
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  if (n2.allowedElements || n2.disallowedElements || n2.allowElement)
    return (t) => {
      Kh(t, "element", (e, r, i) => {
        const l = (
          /** @type {Element|Root} */
          i
        );
        let o;
        if (n2.allowedElements ? o = !n2.allowedElements.includes(e.tagName) : n2.disallowedElements && (o = n2.disallowedElements.includes(e.tagName)), !o && n2.allowElement && typeof r == "number" && (o = !n2.allowElement(e, r, l)), o && typeof r == "number")
          return n2.unwrapDisallowed && e.children ? l.children.splice(r, 1, ...e.children) : l.children.splice(r, 1), r;
      });
    };
}
var Ce = { exports: {} };
var Z = {};
var St;
function oo() {
  return St || (St = 1, function() {
    var n2 = Symbol.for("react.element"), t = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), o = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), s = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), w = false, g = false, y = false, k = false, M = false, v;
    v = Symbol.for("react.module.reference");
    function L(A) {
      return !!(typeof A == "string" || typeof A == "function" || A === e || A === i || M || A === r || A === s || A === d || k || A === h || w || g || y || typeof A == "object" && A !== null && (A.$$typeof === m || A.$$typeof === p || A.$$typeof === l || A.$$typeof === o || A.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      A.$$typeof === v || A.getModuleId !== void 0));
    }
    function S(A) {
      if (typeof A == "object" && A !== null) {
        var On = A.$$typeof;
        switch (On) {
          case n2:
            var _n = A.type;
            switch (_n) {
              case e:
              case i:
              case r:
              case s:
              case d:
                return _n;
              default:
                var Bn = _n && _n.$$typeof;
                switch (Bn) {
                  case a:
                  case o:
                  case c:
                  case m:
                  case p:
                  case l:
                    return Bn;
                  default:
                    return On;
                }
            }
          case t:
            return On;
        }
      }
    }
    var x = o, R = l, q = n2, X = c, sn = e, _ = m, O = p, W = t, en = i, Y = r, tn = s, ln = d, hn = false, mn = false;
    function u(A) {
      return hn || (hn = true, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function T(A) {
      return mn || (mn = true, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), false;
    }
    function F(A) {
      return S(A) === o;
    }
    function f(A) {
      return S(A) === l;
    }
    function z(A) {
      return typeof A == "object" && A !== null && A.$$typeof === n2;
    }
    function H(A) {
      return S(A) === c;
    }
    function I(A) {
      return S(A) === e;
    }
    function B(A) {
      return S(A) === m;
    }
    function j(A) {
      return S(A) === p;
    }
    function Q(A) {
      return S(A) === t;
    }
    function V(A) {
      return S(A) === i;
    }
    function fn(A) {
      return S(A) === r;
    }
    function P(A) {
      return S(A) === s;
    }
    function gn(A) {
      return S(A) === d;
    }
    Z.ContextConsumer = x, Z.ContextProvider = R, Z.Element = q, Z.ForwardRef = X, Z.Fragment = sn, Z.Lazy = _, Z.Memo = O, Z.Portal = W, Z.Profiler = en, Z.StrictMode = Y, Z.Suspense = tn, Z.SuspenseList = ln, Z.isAsyncMode = u, Z.isConcurrentMode = T, Z.isContextConsumer = F, Z.isContextProvider = f, Z.isElement = z, Z.isForwardRef = H, Z.isFragment = I, Z.isLazy = B, Z.isMemo = j, Z.isPortal = Q, Z.isProfiler = V, Z.isStrictMode = fn, Z.isSuspense = P, Z.isSuspenseList = gn, Z.isValidElementType = L, Z.typeOf = S;
  }()), Z;
}
false ? Ce.exports = ao() : Ce.exports = oo();
var uo = Ce.exports;
var so = bc(uo);
function co(n2) {
  const t = (
    // @ts-expect-error looks like a node.
    n2 && typeof n2 == "object" && n2.type === "text" ? (
      // @ts-expect-error looks like a text.
      n2.value || ""
    ) : n2
  );
  return typeof t == "string" && t.replace(/[ \t\n\f\r]/g, "") === "";
}
function fo(n2) {
  return n2.join(" ").trim();
}
function po(n2, t) {
  const e = t || {};
  return (n2[n2.length - 1] === "" ? [...n2, ""] : n2).join(
    (e.padRight ? " " : "") + "," + (e.padLeft === false ? "" : " ")
  ).trim();
}
var _e = { exports: {} };
var Et = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var ho = /\n/g;
var mo = /^\s*/;
var go = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var yo = /^:\s*/;
var xo = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var bo = /^[;\s]*/;
var ko = /^\s+|\s+$/g;
var So = `
`;
var vt = "/";
var Ct = "*";
var An = "";
var wo = "comment";
var Eo = "declaration";
var vo = function(n2, t) {
  if (typeof n2 != "string")
    throw new TypeError("First argument must be a string");
  if (!n2)
    return [];
  t = t || {};
  var e = 1, r = 1;
  function i(w) {
    var g = w.match(ho);
    g && (e += g.length);
    var y = w.lastIndexOf(So);
    r = ~y ? w.length - y : r + w.length;
  }
  function l() {
    var w = { line: e, column: r };
    return function(g) {
      return g.position = new o(w), s(), g;
    };
  }
  function o(w) {
    this.start = w, this.end = { line: e, column: r }, this.source = t.source;
  }
  o.prototype.content = n2;
  function a(w) {
    var g = new Error(
      t.source + ":" + e + ":" + r + ": " + w
    );
    if (g.reason = w, g.filename = t.source, g.line = e, g.column = r, g.source = n2, !t.silent)
      throw g;
  }
  function c(w) {
    var g = w.exec(n2);
    if (g) {
      var y = g[0];
      return i(y), n2 = n2.slice(y.length), g;
    }
  }
  function s() {
    c(mo);
  }
  function d(w) {
    var g;
    for (w = w || []; g = p(); )
      g !== false && w.push(g);
    return w;
  }
  function p() {
    var w = l();
    if (!(vt != n2.charAt(0) || Ct != n2.charAt(1))) {
      for (var g = 2; An != n2.charAt(g) && (Ct != n2.charAt(g) || vt != n2.charAt(g + 1)); )
        ++g;
      if (g += 2, An === n2.charAt(g - 1))
        return a("End of comment missing");
      var y = n2.slice(2, g - 2);
      return r += 2, i(y), n2 = n2.slice(g), r += 2, w({
        type: wo,
        comment: y
      });
    }
  }
  function m() {
    var w = l(), g = c(go);
    if (g) {
      if (p(), !c(yo))
        return a("property missing ':'");
      var y = c(xo), k = w({
        type: Eo,
        property: Tt(g[0].replace(Et, An)),
        value: y ? Tt(y[0].replace(Et, An)) : An
      });
      return c(bo), k;
    }
  }
  function h() {
    var w = [];
    d(w);
    for (var g; g = m(); )
      g !== false && (w.push(g), d(w));
    return w;
  }
  return s(), h();
};
function Tt(n2) {
  return n2 ? n2.replace(ko, An) : An;
}
var Co = vo;
function tr(n2, t) {
  var e = null;
  if (!n2 || typeof n2 != "string")
    return e;
  for (var r, i = Co(n2), l = typeof t == "function", o, a, c = 0, s = i.length; c < s; c++)
    r = i[c], o = r.property, a = r.value, l ? t(o, a, r) : a && (e || (e = {}), e[o] = a);
  return e;
}
_e.exports = tr;
_e.exports.default = tr;
var To = _e.exports;
var Po = bc(To);
var Te = {}.hasOwnProperty;
var Oo = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function rr(n2, t) {
  const e = [];
  let r = -1, i;
  for (; ++r < t.children.length; )
    i = t.children[r], i.type === "element" ? e.push(Io(n2, i, r, t)) : i.type === "text" ? (t.type !== "element" || !Oo.has(t.tagName) || !co(i)) && e.push(i.value) : i.type === "raw" && !n2.options.skipHtml && e.push(i.value);
  return e;
}
function Io(n2, t, e, r) {
  const i = n2.options, l = i.transformLinkUri === void 0 ? wr : i.transformLinkUri, o = n2.schema, a = t.tagName, c = {};
  let s = o, d;
  if (o.space === "html" && a === "svg" && (s = io, n2.schema = s), t.properties)
    for (d in t.properties)
      Te.call(t.properties, d) && Ro(c, d, t.properties[d], n2);
  (a === "ol" || a === "ul") && n2.listDepth++;
  const p = rr(n2, t);
  (a === "ol" || a === "ul") && n2.listDepth--, n2.schema = o;
  const m = t.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  }, h = i.components && Te.call(i.components, a) ? i.components[a] : a, w = typeof h == "string" || h === import_react.default.Fragment;
  if (!so.isValidElementType(h))
    throw new TypeError(
      `Component for name \`${a}\` not defined or is not renderable`
    );
  if (c.key = e, a === "a" && i.linkTarget && (c.target = typeof i.linkTarget == "function" ? i.linkTarget(
    String(c.href || ""),
    t.children,
    typeof c.title == "string" ? c.title : null
  ) : i.linkTarget), a === "a" && l && (c.href = l(
    String(c.href || ""),
    t.children,
    typeof c.title == "string" ? c.title : null
  )), !w && a === "code" && r.type === "element" && r.tagName !== "pre" && (c.inline = true), !w && (a === "h1" || a === "h2" || a === "h3" || a === "h4" || a === "h5" || a === "h6") && (c.level = Number.parseInt(a.charAt(1), 10)), a === "img" && i.transformImageUri && (c.src = i.transformImageUri(
    String(c.src || ""),
    String(c.alt || ""),
    typeof c.title == "string" ? c.title : null
  )), !w && a === "li" && r.type === "element") {
    const g = Ao(t);
    c.checked = g && g.properties ? !!g.properties.checked : null, c.index = de(r, t), c.ordered = r.tagName === "ol";
  }
  return !w && (a === "ol" || a === "ul") && (c.ordered = a === "ol", c.depth = n2.listDepth), (a === "td" || a === "th") && (c.align && (c.style || (c.style = {}), c.style.textAlign = c.align, delete c.align), w || (c.isHeader = a === "th")), !w && a === "tr" && r.type === "element" && (c.isHeader = r.tagName === "thead"), i.sourcePos && (c["data-sourcepos"] = zo(m)), !w && i.rawSourcePos && (c.sourcePosition = t.position), !w && i.includeElementIndex && (c.index = de(r, t), c.siblingCount = de(r)), w || (c.node = t), p.length > 0 ? import_react.default.createElement(h, c, p) : import_react.default.createElement(h, c);
}
function Ao(n2) {
  let t = -1;
  for (; ++t < n2.children.length; ) {
    const e = n2.children[t];
    if (e.type === "element" && e.tagName === "input")
      return e;
  }
  return null;
}
function de(n2, t) {
  let e = -1, r = 0;
  for (; ++e < n2.children.length && n2.children[e] !== t; )
    n2.children[e].type === "element" && r++;
  return r;
}
function Ro(n2, t, e, r) {
  const i = no(r.schema, t);
  let l = e;
  l == null || l !== l || (Array.isArray(l) && (l = i.commaSeparated ? po(l) : fo(l)), i.property === "style" && typeof l == "string" && (l = _o(l)), i.space && i.property ? n2[Te.call(kt, i.property) ? kt[i.property] : i.property] = l : i.attribute && (n2[i.attribute] = l));
}
function _o(n2) {
  const t = {};
  try {
    Po(n2, e);
  } catch {
  }
  return t;
  function e(r, i) {
    const l = r.slice(0, 4) === "-ms-" ? `ms-${r.slice(4)}` : r;
    t[l.replace(/-([a-z])/g, Lo)] = i;
  }
}
function Lo(n2, t) {
  return t.toUpperCase();
}
function zo(n2) {
  return [
    n2.start.line,
    ":",
    n2.start.column,
    "-",
    n2.end.line,
    ":",
    n2.end.column
  ].map(String).join("");
}
var Pt = {}.hasOwnProperty;
var Mo = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var Qn = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function Fo(n2) {
  for (const l in Qn)
    if (Pt.call(Qn, l) && Pt.call(n2, l)) {
      const o = Qn[l];
      console.warn(
        `[react-markdown] Warning: please ${o.to ? `use \`${o.to}\` instead of` : "remove"} \`${l}\` (see <${Mo}#${o.id}> for more info)`
      ), delete Qn[l];
    }
  const t = Br().use(Bl).use(n2.remarkPlugins || []).use(br, {
    ...n2.remarkRehypeOptions,
    allowDangerousHtml: true
  }).use(n2.rehypePlugins || []).use(lo, n2), e = new At();
  typeof n2.children == "string" ? e.value = n2.children : n2.children !== void 0 && n2.children !== null && console.warn(
    `[react-markdown] Warning: please pass a string as \`children\` (not: \`${n2.children}\`)`
  );
  const r = t.runSync(t.parse(e), e);
  if (r.type !== "root")
    throw new TypeError("Expected a `root` node");
  let i = import_react.default.createElement(
    import_react.default.Fragment,
    {},
    rr({ options: n2, schema: ro, listDepth: 0 }, r)
  );
  return n2.className && (i = import_react.default.createElement("div", { className: n2.className }, i)), i;
}
Fo.propTypes = {
  // Core options:
  children: $.string,
  // Layout options:
  className: $.string,
  // Filter options:
  allowElement: $.func,
  allowedElements: $.arrayOf($.string),
  disallowedElements: $.arrayOf($.string),
  unwrapDisallowed: $.bool,
  // Plugin options:
  remarkPlugins: $.arrayOf(
    $.oneOfType([
      $.object,
      $.func,
      $.arrayOf(
        $.oneOfType([
          $.bool,
          $.string,
          $.object,
          $.func,
          $.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            $.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: $.arrayOf(
    $.oneOfType([
      $.object,
      $.func,
      $.arrayOf(
        $.oneOfType([
          $.bool,
          $.string,
          $.object,
          $.func,
          $.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            $.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: $.bool,
  rawSourcePos: $.bool,
  skipHtml: $.bool,
  includeElementIndex: $.bool,
  transformLinkUri: $.oneOfType([$.func, $.bool]),
  linkTarget: $.oneOfType([$.func, $.string]),
  transformImageUri: $.func,
  components: $.object
};
export {
  Fo as default,
  wr as uriTransformer
};
/*! Bundled license information:

@yext/pages-components/dist/index--cy1NwMF.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@yext/pages-components/dist/index--cy1NwMF.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@yext/pages-components/dist/index--cy1NwMF.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@yext/pages-components/dist/index--cy1NwMF.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@yext/pages-components/dist/index--cy1NwMF.js:
  (**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=index--cy1NwMF-WBJN3FPP.js.map
