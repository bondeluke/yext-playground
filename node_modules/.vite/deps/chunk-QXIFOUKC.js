"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  require_react_dom
} from "./chunk-JEFOHQZM.js";
import {
  require_react
} from "./chunk-OMIYRWQL.js";
import {
  __toESM,
  require_dist
} from "./chunk-T67JVKC2.js";

// node_modules/@yext/pages-components/dist/index-i0mhhNq7.js
var import_dist = __toESM(require_dist(), 1);
var Og = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var Sg = Object.defineProperty;
var wg = (e, t, r) => t in e ? Sg(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var Ln = (e, t, r) => (wg(e, typeof t != "symbol" ? t + "" : t, r), r);
var Cc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Nc = { exports: {} };
var Zs = {};
var Nu;
function bg() {
  return Nu || (Nu = 1, function() {
    var e = import_react.default, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), T = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), x = Symbol.for("react.suspense_list"), D = Symbol.for("react.memo"), k = Symbol.for("react.lazy"), H = Symbol.for("react.offscreen"), N = Symbol.iterator, v = "@@iterator";
    function F(ye) {
      if (ye === null || typeof ye != "object")
        return null;
      var Ge = N && ye[N] || ye[v];
      return typeof Ge == "function" ? Ge : null;
    }
    var U = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(ye) {
      {
        for (var Ge = arguments.length, et = new Array(Ge > 1 ? Ge - 1 : 0), _t = 1; _t < Ge; _t++)
          et[_t - 1] = arguments[_t];
        K("error", ye, et);
      }
    }
    function K(ye, Ge, et) {
      {
        var _t = U.ReactDebugCurrentFrame, It = _t.getStackAddendum();
        It !== "" && (Ge += "%s", et = et.concat([It]));
        var Ft = et.map(function(Lt) {
          return String(Lt);
        });
        Ft.unshift("Warning: " + Ge), Function.prototype.apply.call(console[ye], console, Ft);
      }
    }
    var B = false, z = false, te = false, re = false, de = false, V;
    V = Symbol.for("react.module.reference");
    function G(ye) {
      return !!(typeof ye == "string" || typeof ye == "function" || ye === o || ye === h || de || ye === f || ye === S || ye === x || re || ye === H || B || z || te || typeof ye == "object" && ye !== null && (ye.$$typeof === k || ye.$$typeof === D || ye.$$typeof === C || ye.$$typeof === T || ye.$$typeof === O || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ye.$$typeof === V || ye.getModuleId !== void 0));
    }
    function q(ye, Ge, et) {
      var _t = ye.displayName;
      if (_t)
        return _t;
      var It = Ge.displayName || Ge.name || "";
      return It !== "" ? et + "(" + It + ")" : et;
    }
    function me(ye) {
      return ye.displayName || "Context";
    }
    function pe(ye) {
      if (ye == null)
        return null;
      if (typeof ye.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ye == "function")
        return ye.displayName || ye.name || null;
      if (typeof ye == "string")
        return ye;
      switch (ye) {
        case o:
          return "Fragment";
        case r:
          return "Portal";
        case h:
          return "Profiler";
        case f:
          return "StrictMode";
        case S:
          return "Suspense";
        case x:
          return "SuspenseList";
      }
      if (typeof ye == "object")
        switch (ye.$$typeof) {
          case T:
            var Ge = ye;
            return me(Ge) + ".Consumer";
          case C:
            var et = ye;
            return me(et._context) + ".Provider";
          case O:
            return q(ye, ye.render, "ForwardRef");
          case D:
            var _t = ye.displayName || null;
            return _t !== null ? _t : pe(ye.type) || "Memo";
          case k: {
            var It = ye, Ft = It._payload, Lt = It._init;
            try {
              return pe(Lt(Ft));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Z = Object.assign, ee = 0, P, w, j, ne, Y, W, Q;
    function b() {
    }
    b.__reactDisabledLog = true;
    function g() {
      {
        if (ee === 0) {
          P = console.log, w = console.info, j = console.warn, ne = console.error, Y = console.group, W = console.groupCollapsed, Q = console.groupEnd;
          var ye = {
            configurable: true,
            enumerable: true,
            value: b,
            writable: true
          };
          Object.defineProperties(console, {
            info: ye,
            log: ye,
            warn: ye,
            error: ye,
            group: ye,
            groupCollapsed: ye,
            groupEnd: ye
          });
        }
        ee++;
      }
    }
    function _() {
      {
        if (ee--, ee === 0) {
          var ye = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: Z({}, ye, {
              value: P
            }),
            info: Z({}, ye, {
              value: w
            }),
            warn: Z({}, ye, {
              value: j
            }),
            error: Z({}, ye, {
              value: ne
            }),
            group: Z({}, ye, {
              value: Y
            }),
            groupCollapsed: Z({}, ye, {
              value: W
            }),
            groupEnd: Z({}, ye, {
              value: Q
            })
          });
        }
        ee < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var A = U.ReactCurrentDispatcher, J;
    function ce(ye, Ge, et) {
      {
        if (J === void 0)
          try {
            throw Error();
          } catch (It) {
            var _t = It.stack.trim().match(/\n( *(at )?)/);
            J = _t && _t[1] || "";
          }
        return `
` + J + ye;
      }
    }
    var ge = false, ae;
    {
      var Te = typeof WeakMap == "function" ? WeakMap : Map;
      ae = new Te();
    }
    function Me(ye, Ge) {
      if (!ye || ge)
        return "";
      {
        var et = ae.get(ye);
        if (et !== void 0)
          return et;
      }
      var _t;
      ge = true;
      var It = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ft;
      Ft = A.current, A.current = null, g();
      try {
        if (Ge) {
          var Lt = function() {
            throw Error();
          };
          if (Object.defineProperty(Lt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Lt, []);
            } catch (Kn) {
              _t = Kn;
            }
            Reflect.construct(ye, [], Lt);
          } else {
            try {
              Lt.call();
            } catch (Kn) {
              _t = Kn;
            }
            ye.call(Lt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Kn) {
            _t = Kn;
          }
          ye();
        }
      } catch (Kn) {
        if (Kn && _t && typeof Kn.stack == "string") {
          for (var Mt = Kn.stack.split(`
`), cn = _t.stack.split(`
`), Zt = Mt.length - 1, jt = cn.length - 1; Zt >= 1 && jt >= 0 && Mt[Zt] !== cn[jt]; )
            jt--;
          for (; Zt >= 1 && jt >= 0; Zt--, jt--)
            if (Mt[Zt] !== cn[jt]) {
              if (Zt !== 1 || jt !== 1)
                do
                  if (Zt--, jt--, jt < 0 || Mt[Zt] !== cn[jt]) {
                    var Rn = `
` + Mt[Zt].replace(" at new ", " at ");
                    return ye.displayName && Rn.includes("<anonymous>") && (Rn = Rn.replace("<anonymous>", ye.displayName)), typeof ye == "function" && ae.set(ye, Rn), Rn;
                  }
                while (Zt >= 1 && jt >= 0);
              break;
            }
        }
      } finally {
        ge = false, A.current = Ft, _(), Error.prepareStackTrace = It;
      }
      var ir = ye ? ye.displayName || ye.name : "", Xr = ir ? ce(ir) : "";
      return typeof ye == "function" && ae.set(ye, Xr), Xr;
    }
    function ze(ye, Ge, et) {
      return Me(ye, false);
    }
    function oe(ye) {
      var Ge = ye.prototype;
      return !!(Ge && Ge.isReactComponent);
    }
    function ie(ye, Ge, et) {
      if (ye == null)
        return "";
      if (typeof ye == "function")
        return Me(ye, oe(ye));
      if (typeof ye == "string")
        return ce(ye);
      switch (ye) {
        case S:
          return ce("Suspense");
        case x:
          return ce("SuspenseList");
      }
      if (typeof ye == "object")
        switch (ye.$$typeof) {
          case O:
            return ze(ye.render);
          case D:
            return ie(ye.type, Ge, et);
          case k: {
            var _t = ye, It = _t._payload, Ft = _t._init;
            try {
              return ie(Ft(It), Ge, et);
            } catch {
            }
          }
        }
      return "";
    }
    var ue = Object.prototype.hasOwnProperty, we = {}, Le = U.ReactDebugCurrentFrame;
    function Be(ye) {
      if (ye) {
        var Ge = ye._owner, et = ie(ye.type, ye._source, Ge ? Ge.type : null);
        Le.setExtraStackFrame(et);
      } else
        Le.setExtraStackFrame(null);
    }
    function Ye(ye, Ge, et, _t, It) {
      {
        var Ft = Function.call.bind(ue);
        for (var Lt in ye)
          if (Ft(ye, Lt)) {
            var Mt = void 0;
            try {
              if (typeof ye[Lt] != "function") {
                var cn = Error((_t || "React class") + ": " + et + " type `" + Lt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ye[Lt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw cn.name = "Invariant Violation", cn;
              }
              Mt = ye[Lt](Ge, Lt, _t, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Zt) {
              Mt = Zt;
            }
            Mt && !(Mt instanceof Error) && (Be(It), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _t || "React class", et, Lt, typeof Mt), Be(null)), Mt instanceof Error && !(Mt.message in we) && (we[Mt.message] = true, Be(It), I("Failed %s type: %s", et, Mt.message), Be(null));
          }
      }
    }
    var st = Array.isArray;
    function pt(ye) {
      return st(ye);
    }
    function at(ye) {
      {
        var Ge = typeof Symbol == "function" && Symbol.toStringTag, et = Ge && ye[Symbol.toStringTag] || ye.constructor.name || "Object";
        return et;
      }
    }
    function ve(ye) {
      try {
        return se(ye), false;
      } catch {
        return true;
      }
    }
    function se(ye) {
      return "" + ye;
    }
    function he(ye) {
      if (ve(ye))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", at(ye)), se(ye);
    }
    var Oe = U.ReactCurrentOwner, be = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, Re, He, Ve;
    Ve = {};
    function Qe(ye) {
      if (ue.call(ye, "ref")) {
        var Ge = Object.getOwnPropertyDescriptor(ye, "ref").get;
        if (Ge && Ge.isReactWarning)
          return false;
      }
      return ye.ref !== void 0;
    }
    function ct(ye) {
      if (ue.call(ye, "key")) {
        var Ge = Object.getOwnPropertyDescriptor(ye, "key").get;
        if (Ge && Ge.isReactWarning)
          return false;
      }
      return ye.key !== void 0;
    }
    function At(ye, Ge) {
      if (typeof ye.ref == "string" && Oe.current && Ge && Oe.current.stateNode !== Ge) {
        var et = pe(Oe.current.type);
        Ve[et] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', pe(Oe.current.type), ye.ref), Ve[et] = true);
      }
    }
    function je(ye, Ge) {
      {
        var et = function() {
          Re || (Re = true, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ge));
        };
        et.isReactWarning = true, Object.defineProperty(ye, "key", {
          get: et,
          configurable: true
        });
      }
    }
    function qe(ye, Ge) {
      {
        var et = function() {
          He || (He = true, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ge));
        };
        et.isReactWarning = true, Object.defineProperty(ye, "ref", {
          get: et,
          configurable: true
        });
      }
    }
    var nt = function(ye, Ge, et, _t, It, Ft, Lt) {
      var Mt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: ye,
        key: Ge,
        ref: et,
        props: Lt,
        // Record the component responsible for creating this element.
        _owner: Ft
      };
      return Mt._store = {}, Object.defineProperty(Mt._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(Mt, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: _t
      }), Object.defineProperty(Mt, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: It
      }), Object.freeze && (Object.freeze(Mt.props), Object.freeze(Mt)), Mt;
    };
    function gt(ye, Ge, et, _t, It) {
      {
        var Ft, Lt = {}, Mt = null, cn = null;
        et !== void 0 && (he(et), Mt = "" + et), ct(Ge) && (he(Ge.key), Mt = "" + Ge.key), Qe(Ge) && (cn = Ge.ref, At(Ge, It));
        for (Ft in Ge)
          ue.call(Ge, Ft) && !be.hasOwnProperty(Ft) && (Lt[Ft] = Ge[Ft]);
        if (ye && ye.defaultProps) {
          var Zt = ye.defaultProps;
          for (Ft in Zt)
            Lt[Ft] === void 0 && (Lt[Ft] = Zt[Ft]);
        }
        if (Mt || cn) {
          var jt = typeof ye == "function" ? ye.displayName || ye.name || "Unknown" : ye;
          Mt && je(Lt, jt), cn && qe(Lt, jt);
        }
        return nt(ye, Mt, cn, It, _t, Oe.current, Lt);
      }
    }
    var Ct = U.ReactCurrentOwner, xt = U.ReactDebugCurrentFrame;
    function St(ye) {
      if (ye) {
        var Ge = ye._owner, et = ie(ye.type, ye._source, Ge ? Ge.type : null);
        xt.setExtraStackFrame(et);
      } else
        xt.setExtraStackFrame(null);
    }
    var wt;
    wt = false;
    function Et(ye) {
      return typeof ye == "object" && ye !== null && ye.$$typeof === t;
    }
    function Yt() {
      {
        if (Ct.current) {
          var ye = pe(Ct.current.type);
          if (ye)
            return `

Check the render method of \`` + ye + "`.";
        }
        return "";
      }
    }
    function Dt(ye) {
      {
        if (ye !== void 0) {
          var Ge = ye.fileName.replace(/^.*[\\\/]/, ""), et = ye.lineNumber;
          return `

Check your code at ` + Ge + ":" + et + ".";
        }
        return "";
      }
    }
    var Kt = {};
    function bt(ye) {
      {
        var Ge = Yt();
        if (!Ge) {
          var et = typeof ye == "string" ? ye : ye.displayName || ye.name;
          et && (Ge = `

Check the top-level render call using <` + et + ">.");
        }
        return Ge;
      }
    }
    function nr(ye, Ge) {
      {
        if (!ye._store || ye._store.validated || ye.key != null)
          return;
        ye._store.validated = true;
        var et = bt(Ge);
        if (Kt[et])
          return;
        Kt[et] = true;
        var _t = "";
        ye && ye._owner && ye._owner !== Ct.current && (_t = " It was passed a child from " + pe(ye._owner.type) + "."), St(ye), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, _t), St(null);
      }
    }
    function gr(ye, Ge) {
      {
        if (typeof ye != "object")
          return;
        if (pt(ye))
          for (var et = 0; et < ye.length; et++) {
            var _t = ye[et];
            Et(_t) && nr(_t, Ge);
          }
        else if (Et(ye))
          ye._store && (ye._store.validated = true);
        else if (ye) {
          var It = F(ye);
          if (typeof It == "function" && It !== ye.entries)
            for (var Ft = It.call(ye), Lt; !(Lt = Ft.next()).done; )
              Et(Lt.value) && nr(Lt.value, Ge);
        }
      }
    }
    function Ci(ye) {
      {
        var Ge = ye.type;
        if (Ge == null || typeof Ge == "string")
          return;
        var et;
        if (typeof Ge == "function")
          et = Ge.propTypes;
        else if (typeof Ge == "object" && (Ge.$$typeof === O || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ge.$$typeof === D))
          et = Ge.propTypes;
        else
          return;
        if (et) {
          var _t = pe(Ge);
          Ye(et, ye.props, "prop", _t, ye);
        } else if (Ge.PropTypes !== void 0 && !wt) {
          wt = true;
          var It = pe(Ge);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", It || "Unknown");
        }
        typeof Ge.getDefaultProps == "function" && !Ge.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ho(ye) {
      {
        for (var Ge = Object.keys(ye.props), et = 0; et < Ge.length; et++) {
          var _t = Ge[et];
          if (_t !== "children" && _t !== "key") {
            St(ye), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _t), St(null);
            break;
          }
        }
        ye.ref !== null && (St(ye), I("Invalid attribute `ref` supplied to `React.Fragment`."), St(null));
      }
    }
    function Uo(ye, Ge, et, _t, It, Ft) {
      {
        var Lt = G(ye);
        if (!Lt) {
          var Mt = "";
          (ye === void 0 || typeof ye == "object" && ye !== null && Object.keys(ye).length === 0) && (Mt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var cn = Dt(It);
          cn ? Mt += cn : Mt += Yt();
          var Zt;
          ye === null ? Zt = "null" : pt(ye) ? Zt = "array" : ye !== void 0 && ye.$$typeof === t ? (Zt = "<" + (pe(ye.type) || "Unknown") + " />", Mt = " Did you accidentally export a JSX literal instead of a component?") : Zt = typeof ye, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Zt, Mt);
        }
        var jt = gt(ye, Ge, et, It, Ft);
        if (jt == null)
          return jt;
        if (Lt) {
          var Rn = Ge.children;
          if (Rn !== void 0)
            if (_t)
              if (pt(Rn)) {
                for (var ir = 0; ir < Rn.length; ir++)
                  gr(Rn[ir], ye);
                Object.freeze && Object.freeze(Rn);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              gr(Rn, ye);
        }
        return ye === o ? Ho(jt) : Ci(jt), jt;
      }
    }
    function on(ye, Ge, et) {
      return Uo(ye, Ge, et, true);
    }
    function rr(ye, Ge, et) {
      return Uo(ye, Ge, et, false);
    }
    var Fr = rr, Wo = on;
    Zs.Fragment = o, Zs.jsx = Fr, Zs.jsxs = Wo;
  }()), Zs;
}
false ? Nc.exports = Mg() : Nc.exports = bg();
var yt = Nc.exports;
function Lg(e) {
  switch (e) {
    case "AD":
    case "AM":
    case "AT":
    case "AX":
    case "AZ":
    case "BA":
    case "BY":
    case "CY":
    case "CZ":
    case "DK":
    case "DZ":
    case "EC":
    case "EH":
    case "ET":
    case "FI":
    case "FR":
    case "GE":
    case "GF":
    case "GI":
    case "GP":
    case "GW":
    case "HT":
    case "KE":
    case "KV":
    case "KW":
    case "LA":
    case "LU":
    case "MC":
    case "MD":
    case "ME":
    case "MG":
    case "MK":
    case "MQ":
    case "MZ":
    case "NC":
    case "NL":
    case "NO":
    case "PL":
    case "PT":
    case "PY":
    case "RE":
    case "RS":
    case "SA":
    case "SE":
    case "SJ":
    case "SM":
    case "SN":
    case "TC":
    case "TJ":
    case "TM":
    case "TN":
    case "TZ":
    case "UY":
    case "VG":
    case "ZM":
      return [["line1"], ["line2"], ["postalCode", "city"], ["countryCode"]];
    case "AF":
    case "IR":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "AG":
    case "AO":
    case "AW":
    case "BJ":
    case "BO":
    case "BS":
    case "BZ":
    case "CI":
    case "CW":
    case "DJ":
    case "FJ":
    case "GA":
    case "GH":
    case "GM":
    case "GY":
    case "JM":
    case "KI":
    case "LY":
    case "MW":
    case "NA":
    case "NR":
    case "PS":
    case "QA":
    case "RW":
    case "SC":
    case "SR":
    case "SX":
    case "TG":
    case "TT":
    case "UG":
    case "VU":
      return [["line1"], ["line2"], ["city"], ["countryCode"]];
    case "AL":
    case "EE":
    case "IS":
      return [["line1"], ["line2"], ["postalCode", "city"]];
    case "AR":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "AS":
    case "BB":
    case "BD":
    case "BM":
    case "BN":
    case "BT":
    case "CR":
    case "DO":
    case "FK":
    case "FM":
    case "GR":
    case "GU":
    case "JO":
    case "KZ":
    case "LB":
    case "LK":
    case "LS":
    case "MA":
    case "MH":
    case "MM":
    case "MR":
    case "MT":
    case "MV":
    case "NG":
    case "PG":
    case "PK":
    case "PR":
    case "RO":
    case "SG":
    case "VC":
    case "WS":
      return [["line1"], ["line2"], ["city", "postalCode"], ["countryCode"]];
    case "AU":
    case "CA":
    case "SZ":
    case "US":
    case "VI":
      return [
        ["line1"],
        ["line2"],
        ["city", ",", "region", "postalCode"],
        ["countryCode"]
      ];
    case "BE":
    case "PE":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "sublocality", "city"],
        ["countryCode"]
      ];
    case "BF":
    case "BI":
    case "BQ":
    case "BW":
    case "CF":
    case "CG":
    case "CM":
    case "DM":
    case "ER":
    case "GQ":
    case "KM":
    case "ML":
    case "SY":
    case "TD":
    case "ZW":
      return [["line1"], ["line2"], ["city"], ["region"], ["countryCode"]];
    case "BG":
      return [["line1"], ["postalCode", "region"], ["countryCode"]];
    case "BH":
      return [["line1"], ["line2"], ["sublocality", "city"], ["countryCode"]];
    case "BR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "CH":
    case "DE":
    case "GT":
    case "IT":
    case "LI":
    case "MY":
    case "NI":
    case "OM":
    case "SK":
    case "VA":
      return [
        ["line1"],
        ["line2"],
        ["postalCode", "city", "region"],
        ["countryCode"]
      ];
    case "CL":
    case "PF":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode", "region"],
        ["countryCode"]
      ];
    case "CN":
      return [
        ["region", "city", "sublocality"],
        ["line1"],
        ["line2"],
        ["countryCode"]
      ];
    case "CO":
    case "ID":
    case "IQ":
    case "KH":
    case "MP":
    case "NP":
    case "PW":
    case "UA":
      return [
        ["line1"],
        ["line2"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "EG":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "ES":
    case "IL":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "GB":
    case "MN":
    case "ZA":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city", "postalCode"],
        ["countryCode"]
      ];
    case "GG":
    case "IM":
    case "JE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "GN":
      return [["line1", "line2", "city"], ["countryCode"]];
    case "HK":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "HR":
      return [["line1"], ["postalCode", "city", "region"], ["countryCode"]];
    case "HU":
    case "SI":
      return [["postalCode", "city"], ["line1"], ["line2"], ["countryCode"]];
    case "IE":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city", "region", "postalCode"],
        ["countryCode"]
      ];
    case "IN":
    case "VE":
      return [
        ["line1"],
        ["line2"],
        ["city", "postalCode"],
        ["region"],
        ["countryCode"]
      ];
    case "JP":
      return [
        ["line2"],
        ["line1", "sublocality"],
        ["city", "region"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "KR":
      return [
        ["countryCode"],
        ["region", "city", "sublocality", "line1"],
        ["line2"],
        ["postalCode"]
      ];
    case "KY":
      return [["line1"], ["line2"], ["postalCode"], ["countryCode"]];
    case "LT":
      return [
        ["line1"],
        ["postalCode", "city", "sublocality", "region"],
        ["countryCode"]
      ];
    case "LV":
      return [["line1"], ["city", ",", "postalCode"], ["countryCode"]];
    case "MO":
      return [["line1"], ["line2"], ["sublocality"], ["city"], ["countryCode"]];
    case "MU":
      return [
        ["line1"],
        ["line2"],
        ["city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "MX":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city", ",", "region"],
        ["countryCode"]
      ];
    case "NE":
    case "SD":
      return [
        ["line1"],
        ["line2"],
        ["postalCode"],
        ["city"],
        ["region"],
        ["countryCode"]
      ];
    case "NZ":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["city"],
        ["postalCode"],
        ["countryCode"]
      ];
    case "PH":
    case "TW":
    case "VN":
      return [
        ["line1"],
        ["line2"],
        ["sublocality", "city"],
        ["region", "postalCode"],
        ["countryCode"]
      ];
    case "RU":
      return [["line1"], ["line2"], ["city"], ["postalCode"], ["countryCode"]];
    case "SB":
    case "SL":
    case "ST":
    case "TL":
    case "TO":
    case "TV":
      return [["line1"], ["line2"], ["city", ",", "region"], ["countryCode"]];
    case "TH":
    case "TR":
      return [
        ["line1"],
        ["line2"],
        ["sublocality"],
        ["postalCode", "city"],
        ["countryCode"]
      ];
    case "UZ":
      return [["line1"], ["line2"], ["region", "postalCode"], ["countryCode"]];
  }
  return [
    ["line1", "line2"],
    ["city", "region", "postalCode"],
    ["countryCode"]
  ];
}
var Pg = {
  GOOGLEMYBUSINESS: "GOOGLEMYBUSINESS"
};
var Tu = {
  GOOGLE: "google",
  APPLE: "apple",
  BING: "bing"
};
var Ig = (e, t) => {
  const o = {
    region: "localizedRegionName",
    countryCode: "localizedCountryName"
  }[e];
  return o && t[o];
};
var $C = (e, t = [], r, o = {
  route: false
}) => {
  const f = "Failed to construct query for maps service.";
  let h = e && xu([
    e.line1,
    e.line2,
    e.city,
    e.region,
    e.postalCode,
    e.countryCode
  ]);
  switch (o.provider) {
    case Tu.APPLE: {
      if (!h) {
        console.warn(
          `${f} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return kg(h, o.route);
    }
    case Tu.BING: {
      if (h = e && xu([
        e.line1,
        e.city,
        e.region,
        e.postalCode
      ]), !h) {
        console.warn(
          `${f} Check that you've provided a valid Yext Address.`
        );
        break;
      }
      return $g(h, o.route);
    }
    default: {
      const C = t.find(
        (T) => {
          var O;
          return ((O = T == null ? void 0 : T.publisher) == null ? void 0 : O.toUpperCase()) === Pg.GOOGLEMYBUSINESS;
        }
      );
      if (C != null && C.listingUrl)
        return C.listingUrl;
      if (r)
        return Fg(r, h, o.route);
      if (!h) {
        console.warn(
          `${f} Check that you've provided a valid Yext Address, Yext ListingType, or Google Place ID.`
        );
        break;
      }
      return Bg(h, o.route);
    }
  }
};
var kg = (e, t) => t ? `https://maps.apple.com/?daddr=${e}` : `https://maps.apple.com/?address=${e}`;
var $g = (e, t) => t ? `https://bing.com/maps/default.aspx?rtp=adr.${e}` : `https://bing.com/maps/default.aspx?where1=${e}`;
var Fg = (e, t, r) => {
  const o = t ? `&query=${t}` : "";
  return r ? `https://maps.google.com/maps/dir/?api=1${o}&destination_place_id=${e}&destination=direct` : o ? `https://maps.google.com/maps/search/?api=1${o}&query_place_id=${e}` : `https://maps.google.com/maps/dir/?api=1&destination_place_id=${e}&destination=direct`;
};
var Bg = (e, t) => t ? `https://maps.google.com/maps/dir/?api=1&destination=${e}` : `https://maps.google.com/maps/search/?api=1&query=${e}`;
var xu = (e = []) => {
  if (!e.length)
    return "";
  const t = e.filter(Boolean).join(", ");
  return encodeURI(t);
};
var FC = ({
  address: e,
  lines: t,
  separator: r = ",",
  ...o
}) => {
  const f = (t || Lg(e.countryCode)).map(
    (h) => yt.jsx(
      Kg,
      {
        address: e,
        line: h,
        separator: r
      },
      h.toString()
    )
  );
  return (0, import_react.createElement)("div", { ...o, key: e.toString() }, f);
};
var Kg = ({
  address: e,
  line: t,
  separator: r
}) => {
  const o = [];
  for (const f of t) {
    if (f === ",") {
      o.push(yt.jsx("span", { children: r }, f));
      continue;
    }
    const h = e[f];
    if (!h)
      continue;
    const C = Ig(f, e);
    if (C) {
      o.push(
        yt.jsxs(Og.Fragment, { children: [
          " ",
          yt.jsx("abbr", { title: C, children: h })
        ] }, f)
      );
      continue;
    }
    o.push(yt.jsx("span", { children: " " + h }, f));
  }
  return yt.jsx("div", { className: "address-line", children: o });
};
var Cs = {};
Object.defineProperty(Cs, "__esModule", {
  value: true
});
var Hg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
  return typeof e;
} : function(e) {
  return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
};
var Ug = typeof window < "u" && typeof window.document < "u";
var Wg = typeof process < "u" && process.versions != null && process.versions.node != null;
var zg = (typeof self > "u" ? "undefined" : Hg(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
var Gg = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
var Yg = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u";
var vu = Cs.isBrowser = Ug;
Cs.isWebWorker = zg;
var jg = Cs.isNode = Wg;
Cs.isJsDom = Gg;
var qg = Cs.isDeno = Yg;
var Vg = class {
  constructor() {
    Ln(this, "name");
    Ln(this, "isServerSide");
    Ln(this, "version");
    var t;
    qg ? (this.name = "deno", this.version = "", vu && (this.version = ((t = window.Deno) == null ? void 0 : t.version.deno) || ""), this.isServerSide = true) : jg ? (this.name = "node", this.version = process.versions.node, this.isServerSide = true) : vu ? (this.name = "browser", this.version = navigator.userAgent, this.isServerSide = false) : (this.name = "unknown", this.version = "", this.isServerSide = false);
  }
  getNodeMajorVersion() {
    if (this.name !== "node")
      throw new Error("Not running in Node.");
    return +this.version.split(".")[0];
  }
};
var ys = () => new Vg();
var Jg = (...e) => {
  var o;
  if (ys().name !== "browser")
    return false;
  const r = (o = window == null ? void 0 : window.location) == null ? void 0 : o.hostname;
  return e.length === 0 ? r !== "localhost" && !r.includes("preview.pagescdn.com") : e.some((f) => f == null ? void 0 : f.includes(r));
};
var Ec = { exports: {} };
(function(e, t) {
  var r = typeof self < "u" ? self : Cc, o = function() {
    function h() {
      this.fetch = false, this.DOMException = r.DOMException;
    }
    return h.prototype = r, new h();
  }();
  (function(h) {
    (function(C) {
      var T = {
        searchParams: "URLSearchParams" in h,
        iterable: "Symbol" in h && "iterator" in Symbol,
        blob: "FileReader" in h && "Blob" in h && function() {
          try {
            return new Blob(), true;
          } catch {
            return false;
          }
        }(),
        formData: "FormData" in h,
        arrayBuffer: "ArrayBuffer" in h
      };
      function O(Z) {
        return Z && DataView.prototype.isPrototypeOf(Z);
      }
      if (T.arrayBuffer)
        var S = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], x = ArrayBuffer.isView || function(Z) {
          return Z && S.indexOf(Object.prototype.toString.call(Z)) > -1;
        };
      function D(Z) {
        if (typeof Z != "string" && (Z = String(Z)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(Z))
          throw new TypeError("Invalid character in header field name");
        return Z.toLowerCase();
      }
      function k(Z) {
        return typeof Z != "string" && (Z = String(Z)), Z;
      }
      function H(Z) {
        var ee = {
          next: function() {
            var P = Z.shift();
            return { done: P === void 0, value: P };
          }
        };
        return T.iterable && (ee[Symbol.iterator] = function() {
          return ee;
        }), ee;
      }
      function N(Z) {
        this.map = {}, Z instanceof N ? Z.forEach(function(ee, P) {
          this.append(P, ee);
        }, this) : Array.isArray(Z) ? Z.forEach(function(ee) {
          this.append(ee[0], ee[1]);
        }, this) : Z && Object.getOwnPropertyNames(Z).forEach(function(ee) {
          this.append(ee, Z[ee]);
        }, this);
      }
      N.prototype.append = function(Z, ee) {
        Z = D(Z), ee = k(ee);
        var P = this.map[Z];
        this.map[Z] = P ? P + ", " + ee : ee;
      }, N.prototype.delete = function(Z) {
        delete this.map[D(Z)];
      }, N.prototype.get = function(Z) {
        return Z = D(Z), this.has(Z) ? this.map[Z] : null;
      }, N.prototype.has = function(Z) {
        return this.map.hasOwnProperty(D(Z));
      }, N.prototype.set = function(Z, ee) {
        this.map[D(Z)] = k(ee);
      }, N.prototype.forEach = function(Z, ee) {
        for (var P in this.map)
          this.map.hasOwnProperty(P) && Z.call(ee, this.map[P], P, this);
      }, N.prototype.keys = function() {
        var Z = [];
        return this.forEach(function(ee, P) {
          Z.push(P);
        }), H(Z);
      }, N.prototype.values = function() {
        var Z = [];
        return this.forEach(function(ee) {
          Z.push(ee);
        }), H(Z);
      }, N.prototype.entries = function() {
        var Z = [];
        return this.forEach(function(ee, P) {
          Z.push([P, ee]);
        }), H(Z);
      }, T.iterable && (N.prototype[Symbol.iterator] = N.prototype.entries);
      function v(Z) {
        if (Z.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        Z.bodyUsed = true;
      }
      function F(Z) {
        return new Promise(function(ee, P) {
          Z.onload = function() {
            ee(Z.result);
          }, Z.onerror = function() {
            P(Z.error);
          };
        });
      }
      function U(Z) {
        var ee = new FileReader(), P = F(ee);
        return ee.readAsArrayBuffer(Z), P;
      }
      function I(Z) {
        var ee = new FileReader(), P = F(ee);
        return ee.readAsText(Z), P;
      }
      function K(Z) {
        for (var ee = new Uint8Array(Z), P = new Array(ee.length), w = 0; w < ee.length; w++)
          P[w] = String.fromCharCode(ee[w]);
        return P.join("");
      }
      function B(Z) {
        if (Z.slice)
          return Z.slice(0);
        var ee = new Uint8Array(Z.byteLength);
        return ee.set(new Uint8Array(Z)), ee.buffer;
      }
      function z() {
        return this.bodyUsed = false, this._initBody = function(Z) {
          this._bodyInit = Z, Z ? typeof Z == "string" ? this._bodyText = Z : T.blob && Blob.prototype.isPrototypeOf(Z) ? this._bodyBlob = Z : T.formData && FormData.prototype.isPrototypeOf(Z) ? this._bodyFormData = Z : T.searchParams && URLSearchParams.prototype.isPrototypeOf(Z) ? this._bodyText = Z.toString() : T.arrayBuffer && T.blob && O(Z) ? (this._bodyArrayBuffer = B(Z.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : T.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(Z) || x(Z)) ? this._bodyArrayBuffer = B(Z) : this._bodyText = Z = Object.prototype.toString.call(Z) : this._bodyText = "", this.headers.get("content-type") || (typeof Z == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : T.searchParams && URLSearchParams.prototype.isPrototypeOf(Z) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, T.blob && (this.blob = function() {
          var Z = v(this);
          if (Z)
            return Z;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? v(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(U);
        }), this.text = function() {
          var Z = v(this);
          if (Z)
            return Z;
          if (this._bodyBlob)
            return I(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(K(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, T.formData && (this.formData = function() {
          return this.text().then(V);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function re(Z) {
        var ee = Z.toUpperCase();
        return te.indexOf(ee) > -1 ? ee : Z;
      }
      function de(Z, ee) {
        ee = ee || {};
        var P = ee.body;
        if (Z instanceof de) {
          if (Z.bodyUsed)
            throw new TypeError("Already read");
          this.url = Z.url, this.credentials = Z.credentials, ee.headers || (this.headers = new N(Z.headers)), this.method = Z.method, this.mode = Z.mode, this.signal = Z.signal, !P && Z._bodyInit != null && (P = Z._bodyInit, Z.bodyUsed = true);
        } else
          this.url = String(Z);
        if (this.credentials = ee.credentials || this.credentials || "same-origin", (ee.headers || !this.headers) && (this.headers = new N(ee.headers)), this.method = re(ee.method || this.method || "GET"), this.mode = ee.mode || this.mode || null, this.signal = ee.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && P)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(P);
      }
      de.prototype.clone = function() {
        return new de(this, { body: this._bodyInit });
      };
      function V(Z) {
        var ee = new FormData();
        return Z.trim().split("&").forEach(function(P) {
          if (P) {
            var w = P.split("="), j = w.shift().replace(/\+/g, " "), ne = w.join("=").replace(/\+/g, " ");
            ee.append(decodeURIComponent(j), decodeURIComponent(ne));
          }
        }), ee;
      }
      function G(Z) {
        var ee = new N(), P = Z.replace(/\r?\n[\t ]+/g, " ");
        return P.split(/\r?\n/).forEach(function(w) {
          var j = w.split(":"), ne = j.shift().trim();
          if (ne) {
            var Y = j.join(":").trim();
            ee.append(ne, Y);
          }
        }), ee;
      }
      z.call(de.prototype);
      function q(Z, ee) {
        ee || (ee = {}), this.type = "default", this.status = ee.status === void 0 ? 200 : ee.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in ee ? ee.statusText : "OK", this.headers = new N(ee.headers), this.url = ee.url || "", this._initBody(Z);
      }
      z.call(q.prototype), q.prototype.clone = function() {
        return new q(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new N(this.headers),
          url: this.url
        });
      }, q.error = function() {
        var Z = new q(null, { status: 0, statusText: "" });
        return Z.type = "error", Z;
      };
      var me = [301, 302, 303, 307, 308];
      q.redirect = function(Z, ee) {
        if (me.indexOf(ee) === -1)
          throw new RangeError("Invalid status code");
        return new q(null, { status: ee, headers: { location: Z } });
      }, C.DOMException = h.DOMException;
      try {
        new C.DOMException();
      } catch {
        C.DOMException = function(ee, P) {
          this.message = ee, this.name = P;
          var w = Error(ee);
          this.stack = w.stack;
        }, C.DOMException.prototype = Object.create(Error.prototype), C.DOMException.prototype.constructor = C.DOMException;
      }
      function pe(Z, ee) {
        return new Promise(function(P, w) {
          var j = new de(Z, ee);
          if (j.signal && j.signal.aborted)
            return w(new C.DOMException("Aborted", "AbortError"));
          var ne = new XMLHttpRequest();
          function Y() {
            ne.abort();
          }
          ne.onload = function() {
            var W = {
              status: ne.status,
              statusText: ne.statusText,
              headers: G(ne.getAllResponseHeaders() || "")
            };
            W.url = "responseURL" in ne ? ne.responseURL : W.headers.get("X-Request-URL");
            var Q = "response" in ne ? ne.response : ne.responseText;
            P(new q(Q, W));
          }, ne.onerror = function() {
            w(new TypeError("Network request failed"));
          }, ne.ontimeout = function() {
            w(new TypeError("Network request failed"));
          }, ne.onabort = function() {
            w(new C.DOMException("Aborted", "AbortError"));
          }, ne.open(j.method, j.url, true), j.credentials === "include" ? ne.withCredentials = true : j.credentials === "omit" && (ne.withCredentials = false), "responseType" in ne && T.blob && (ne.responseType = "blob"), j.headers.forEach(function(W, Q) {
            ne.setRequestHeader(Q, W);
          }), j.signal && (j.signal.addEventListener("abort", Y), ne.onreadystatechange = function() {
            ne.readyState === 4 && j.signal.removeEventListener("abort", Y);
          }), ne.send(typeof j._bodyInit > "u" ? null : j._bodyInit);
        });
      }
      return pe.polyfill = true, h.fetch || (h.fetch = pe, h.Headers = N, h.Request = de, h.Response = q), C.Headers = N, C.Request = de, C.Response = q, C.fetch = pe, Object.defineProperty(C, "__esModule", { value: true }), C;
    })({});
  })(o), o.fetch.ponyfill = true, delete o.fetch.polyfill;
  var f = o;
  t = f.fetch, t.default = f.fetch, t.fetch = f.fetch, t.Headers = f.Headers, t.Request = f.Request, t.Response = f.Response, e.exports = t;
})(Ec, Ec.exports);
var Zg = Ec.exports;
var Su = bc(Zg);
var Xg = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.post = function(t, r, o) {
      var f = JSON.stringify(r), h = {
        method: "POST",
        headers: o,
        body: f,
        keepalive: true
      };
      return typeof window < "u" && window.fetch ? window.fetch(t, h) : Su(t, h);
    }, e.prototype.get = function(t) {
      var r = {
        method: "GET",
        mode: "no-cors",
        keepalive: true
      };
      return typeof window < "u" && window.fetch ? window.fetch(t, r) : Su(t, r);
    }, e;
  }()
);
var Qg = {
  US: {
    PRODUCTION: "https://us.yextevents.com",
    SANDBOX: "https://sbx.us.yextevents.com"
  },
  EU: {
    PRODUCTION: "https://eu.yextevents.com",
    SANDBOX: void 0
  }
};
var ep = {
  US: {
    PRODUCTION: "https://realtimeanalytics.yext.com",
    SANDBOX: "https://sandbox-realtimeanalytics.yext.com"
  },
  EU: {
    PRODUCTION: void 0,
    SANDBOX: void 0
  }
};
function tp(e, t) {
  var r = t ? Mc(e) : ip(e);
  return "".concat(r, "/store_pagespixel");
}
function np() {
  var e = Mc("US", "PRODUCTION");
  return "".concat(e, "/conversiontracking/conversion");
}
function rp() {
  var e = Mc("US", "PRODUCTION");
  return "".concat(e, "/listings");
}
function Mc(e, t) {
  return Uf(ep, e, t, true);
}
function ip(e, t) {
  return Uf(Qg, e, t);
}
function Uf(e, t, r, o) {
  t === void 0 && (t = "US"), r === void 0 && (r = "PRODUCTION"), o === void 0 && (o = false);
  var f = e[t][r];
  if (!f)
    throw Error('The combination of the environment: "'.concat(r, '", region: "').concat(t, '",') + 'and conversionTrackingEnabled: "'.concat(o, '" is unsupported.'));
  return f;
}
var wu;
(function(e) {
  e.AllTabNavigation = "ALL_TAB_NAVIGATION", e.VerticalTabNavigation = "VERTICAL_TAB_NAVIGATION", e.ScrollToBottomOfPage = "SCROLL_TO_BOTTOM_OF_PAGE", e.QuestionFocus = "QUESTION_FOCUS", e.QuestionSubmit = "QUESTION_SUBMIT", e.RowExpand = "ROW_EXPAND", e.RowCollapse = "ROW_COLLAPSE", e.ThumbsUp = "THUMBS_UP", e.ThumbsDown = "THUMBS_DOWN", e.VoiceStart = "VOICE_START", e.VoiceStop = "VOICE_STOP", e.SearchBarImpression = "SEARCH_BAR_IMPRESSION", e.SearchClearButton = "SEARCH_CLEAR_BUTTON", e.Paginate = "PAGINATE", e.AutocompleteSelection = "AUTO_COMPLETE_SELECTION", e.VerticalViewAll = "VERTICAL_VIEW_ALL", e.CtaClick = "CTA_CLICK", e.TitleClick = "TITLE_CLICK", e.TapToCall = "TAP_TO_CALL", e.OrderNow = "ORDER_NOW", e.AddToCart = "ADD_TO_CART", e.ApplyNow = "APPLY_NOW", e.DrivingDirections = "DRIVING_DIRECTIONS", e.ViewWebsite = "VIEW_WEBSITE", e.Email = "EMAIL", e.BookAppointment = "BOOK_APPOINTMENT", e.Rsvp = "RSVP", e.ResultsHidden = "RESULTS_HIDDEN", e.ResultsUnhidden = "RESULTS_UNHIDDEN", e.FollowUpQuery = "FOLLOW_UP_QUERY";
})(wu || (wu = {}));
var $r;
(function(e) {
  e.PageView = "PAGE_VIEW", e.CTA = "CTA_CLICK", e.Website = "WEBSITE", e.DrivingDirection = "DRIVING_DIRECTIONS", e.PhoneCall = "CALL";
})($r || ($r = {}));
$r.CTA;
$r.Website;
$r.DrivingDirection;
var op = {
  eventType: $r.PageView
};
$r.PhoneCall;
var Ou;
(function(e) {
  e.Production = "PRODUCTION", e.Sandbox = "SANDBOX";
})(Ou || (Ou = {}));
var Ru;
(function(e) {
  e.US = "US", e.EU = "EU";
})(Ru || (Ru = {}));
var ol = "_yfpc";
var Aa = "__temp__";
var Wf = "y_source";
function zf() {
  return Date.now() + Math.floor(1e3 * Math.random());
}
var ba = function(e, t, r, o) {
  function f(h) {
    return h instanceof r ? h : new r(function(C) {
      C(h);
    });
  }
  return new (r || (r = Promise))(function(h, C) {
    function T(x) {
      try {
        S(o.next(x));
      } catch (D) {
        C(D);
      }
    }
    function O(x) {
      try {
        S(o.throw(x));
      } catch (D) {
        C(D);
      }
    }
    function S(x) {
      x.done ? h(x.value) : f(x.value).then(T, O);
    }
    S((o = o.apply(e, t || [])).next());
  });
};
var Ma = function(e, t) {
  var r = { label: 0, sent: function() {
    if (h[0] & 1)
      throw h[1];
    return h[1];
  }, trys: [], ops: [] }, o, f, h, C;
  return C = { next: T(0), throw: T(1), return: T(2) }, typeof Symbol == "function" && (C[Symbol.iterator] = function() {
    return this;
  }), C;
  function T(S) {
    return function(x) {
      return O([S, x]);
    };
  }
  function O(S) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (o = 1, f && (h = S[0] & 2 ? f.return : S[0] ? f.throw || ((h = f.return) && h.call(f), 0) : f.next) && !(h = h.call(f, S[1])).done)
          return h;
        switch (f = 0, h && (S = [S[0] & 2, h.value]), S[0]) {
          case 0:
          case 1:
            h = S;
            break;
          case 4:
            return r.label++, { value: S[1], done: false };
          case 5:
            r.label++, f = S[1], S = [0];
            continue;
          case 7:
            S = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (h = r.trys, !(h = h.length > 0 && h[h.length - 1]) && (S[0] === 6 || S[0] === 2)) {
              r = 0;
              continue;
            }
            if (S[0] === 3 && (!h || S[1] > h[0] && S[1] < h[3])) {
              r.label = S[1];
              break;
            }
            if (S[0] === 6 && r.label < h[1]) {
              r.label = h[1], h = S;
              break;
            }
            if (h && r.label < h[2]) {
              r.label = h[2], r.ops.push(S);
              break;
            }
            h[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        S = t.call(e, r);
      } catch (x) {
        S = [6, x], f = 0;
      } finally {
        o = h = 0;
      }
    if (S[0] & 5)
      throw S[1];
    return { value: S[0] ? S[1] : void 0, done: true };
  }
};
var sp = (
  /** @class */
  function() {
    function e(t, r) {
      this.httpRequesterService = t, this.debug = r, this._debug = r, this._conversionTrackingEndpoint = np(), this._conversionTrackingListingsEndpoint = rp();
    }
    return e.prototype.printEvent = function(t, r) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked ".concat(r, " event: ").concat(t), "background: white; color: blue;", "");
    }, e.prototype.handleRequest = function(t) {
      return ba(this, void 0, void 0, function() {
        var r, o;
        return Ma(this, function(f) {
          switch (f.label) {
            case 0:
              return [4, this.httpRequesterService.get(t.toString())];
            case 1:
              return r = f.sent(), r.status !== 200 && !(r.type === "opaqueredirect" || r.type === "opaque") ? [4, r.text()] : [3, 3];
            case 2:
              throw o = f.sent(), new Error(o);
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.formatBaseEvent = function(t, r) {
      r.set(ol, t.cookieId), t.referrer && r.set("referrer", t.referrer), r.set("v", zf().toString()), r.set("location", t.location);
    }, e.prototype.trackConversion = function(t) {
      return ba(this, void 0, void 0, function() {
        var r, o;
        return Ma(this, function(f) {
          switch (f.label) {
            case 0:
              return r = new URL(this._conversionTrackingEndpoint), o = new URLSearchParams(), o.set("cid", t.cid), t.cv && o.set("cv", t.cv), e.formatBaseEvent(t, o), r.search = o.toString(), [4, this.handleRequest(r.toString())];
            case 1:
              return f.sent(), this.printEvent(t.cid, "Conversion"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.trackListings = function(t) {
      return ba(this, void 0, void 0, function() {
        var r, o;
        return Ma(this, function(f) {
          switch (f.label) {
            case 0:
              return r = new URL(this._conversionTrackingListingsEndpoint), o = new URLSearchParams(), o.set(Wf, t.source), e.formatBaseEvent(t, o), r.search = o.toString(), [4, this.handleRequest(r.toString())];
            case 1:
              return f.sent(), this.printEvent(t.source, "Listings Click"), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.setDebugEnabled = function(t) {
      this._debug = t;
    }, e;
  }()
);
var Du = function(e, t, r, o) {
  function f(h) {
    return h instanceof r ? h : new r(function(C) {
      C(h);
    });
  }
  return new (r || (r = Promise))(function(h, C) {
    function T(x) {
      try {
        S(o.next(x));
      } catch (D) {
        C(D);
      }
    }
    function O(x) {
      try {
        S(o.throw(x));
      } catch (D) {
        C(D);
      }
    }
    function S(x) {
      x.done ? h(x.value) : f(x.value).then(T, O);
    }
    S((o = o.apply(e, t || [])).next());
  });
};
var Au = function(e, t) {
  var r = { label: 0, sent: function() {
    if (h[0] & 1)
      throw h[1];
    return h[1];
  }, trys: [], ops: [] }, o, f, h, C;
  return C = { next: T(0), throw: T(1), return: T(2) }, typeof Symbol == "function" && (C[Symbol.iterator] = function() {
    return this;
  }), C;
  function T(S) {
    return function(x) {
      return O([S, x]);
    };
  }
  function O(S) {
    if (o)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (o = 1, f && (h = S[0] & 2 ? f.return : S[0] ? f.throw || ((h = f.return) && h.call(f), 0) : f.next) && !(h = h.call(f, S[1])).done)
          return h;
        switch (f = 0, h && (S = [S[0] & 2, h.value]), S[0]) {
          case 0:
          case 1:
            h = S;
            break;
          case 4:
            return r.label++, { value: S[1], done: false };
          case 5:
            r.label++, f = S[1], S = [0];
            continue;
          case 7:
            S = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (h = r.trys, !(h = h.length > 0 && h[h.length - 1]) && (S[0] === 6 || S[0] === 2)) {
              r = 0;
              continue;
            }
            if (S[0] === 3 && (!h || S[1] > h[0] && S[1] < h[3])) {
              r.label = S[1];
              break;
            }
            if (S[0] === 6 && r.label < h[1]) {
              r.label = h[1], h = S;
              break;
            }
            if (h && r.label < h[2]) {
              r.label = h[2], r.ops.push(S);
              break;
            }
            h[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        S = t.call(e, r);
      } catch (x) {
        S = [6, x], f = 0;
      } finally {
        o = h = 0;
      }
    if (S[0] & 5)
      throw S[1];
    return { value: S[0] ? S[1] : void 0, done: true };
  }
};
var lp = "sites";
var xn;
(function(e) {
  e.BusinessId = "businessids", e.Product = "product", e.SiteId = "siteId", e.IsStaging = "isStaging", e.CacheBuster = "v", e.UrlPath = "pageurl", e.Referrer = "pagesReferrer", e.EventType = "eventType", e.PageSetId = "pageSetId", e.EntityInternalId = "ids", e.DirectoryId = "directoryId", e.SearchId = "searchId", e.StaticPageId = "staticPageId", e.PageType = "pageType", e.VisitorId = "visitorId", e.VisitorMethod = "visitorIdMethod", e.PageDomain = "pageDomain";
})(xn || (xn = {}));
var Ns = /* @__PURE__ */ new Map();
Ns.set($r.PageView, "pageview");
Ns.set($r.CTA, "calltoactionclick");
Ns.set($r.PhoneCall, "phonecall");
Ns.set($r.DrivingDirection, "drivingdirection");
Ns.set($r.Website, "clicktowebsite");
function ap(e) {
  var t = Ns.get(e);
  return typeof t == "string" ? t : e;
}
var cp = (
  /** @class */
  function() {
    function e(t, r) {
      this.config = t, this.httpRequesterService = r, this.setVisitor(t.visitor), this._debug = t.debug, this._conversionTracker = new sp(this.httpRequesterService, this._debug), this._hasTrackedListings = false, this._region = t.region;
      try {
        this._pageUrl = new URL(t.pageUrl);
      } catch {
        throw new Error("pageUrl property must be a valid URL, was: '".concat(t.pageUrl, "'"));
      }
      if (t.pageDomain)
        try {
          this._pageDomain = new URL(t.pageDomain);
        } catch {
          console.warn("pageDomain '".concat(t.pageDomain, "' is not a valid URL."), "It will not be included as a query param sent to the API.");
        }
    }
    return e.prototype.printEvent = function(t) {
      this._debug && console.log("%c[YextAnalytics]%c- Tracked Pages event: ".concat(t.eventType), "background: white; color: blue;", "");
    }, e.prototype.urlParameters = function(t) {
      var r = new URLSearchParams();
      return r.set(xn.BusinessId, this.config.businessId.toString()), r.set(xn.Product, lp), r.set(xn.SiteId, this.config.siteId.toString()), r.set(xn.IsStaging, (!this.config.production).toString()), r.set(xn.EventType, ap(t.eventType)), r.set(xn.PageType, this.config.pageType.name), this.config.pageType.name === "entity" ? (r.set(xn.PageSetId, this.config.pageType.pageSetId), r.set(xn.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "directory" ? (r.set(xn.DirectoryId, this.config.pageType.directoryId), r.set(xn.EntityInternalId, this.config.pageType.id.toString())) : this.config.pageType.name === "locator" ? r.set(xn.SearchId, this.config.pageType.searchId) : xn.StaticPageId in this.config.pageType && r.set(xn.StaticPageId, this.config.pageType.staticPageId), r.set(xn.CacheBuster, zf().toString()), r.set(xn.UrlPath, this._pageUrl.pathname), r.set(xn.Referrer, this.config.referrer), this._pageDomain && r.set(xn.PageDomain, this._pageDomain.toString()), this._conversionTrackingEnabled && this._cookieID && r.set(ol, this._cookieID), this._visitor && (r.set(xn.VisitorId, this._visitor.id), this._visitor.idMethod && r.set(xn.VisitorMethod, this._visitor.idMethod)), r;
    }, e.prototype.pageView = function() {
      return Du(this, void 0, void 0, function() {
        var t;
        return Au(this, function(r) {
          switch (r.label) {
            case 0:
              return t = this._pageUrl.searchParams.get(Wf), this._conversionTrackingEnabled && this._cookieID && !this._hasTrackedListings && t ? [4, this._conversionTracker.trackListings({
                cookieId: this._cookieID,
                location: this._pageUrl.toString(),
                source: t
              })] : [3, 2];
            case 1:
              r.sent(), this._hasTrackedListings = true, r.label = 2;
            case 2:
              return [2, this.track(op)];
          }
        });
      });
    }, e.prototype.track = function(t, r) {
      return Du(this, void 0, void 0, function() {
        var o, f, h, C;
        return Au(this, function(T) {
          switch (T.label) {
            case 0:
              return o = tp(this._region, this._conversionTrackingEnabled), f = new URL(o), f.search = this.urlParameters(t).toString(), [4, this.httpRequesterService.get(f.toString())];
            case 1:
              return h = T.sent(), h.status !== 200 && !(h.type == "opaque" || h.type == "opaqueredirect") ? [4, h.text()] : [3, 3];
            case 2:
              throw C = T.sent(), new Error(C);
            case 3:
              return this.printEvent(t), this._conversionTrackingEnabled && this._cookieID && r ? [4, this._conversionTracker.trackConversion({
                cid: r.cid,
                cv: r.cv,
                cookieId: this._cookieID,
                location: this._pageUrl.toString()
              })] : [3, 5];
            case 4:
              T.sent(), T.label = 5;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }, e.prototype.setDebugEnabled = function(t) {
      this._debug = t, this._conversionTracker && this._conversionTracker.setDebugEnabled(t);
    }, e.prototype.setVisitor = function(t) {
      this._visitor = t;
    }, e.prototype.setConversionTrackingEnabled = function(t, r) {
      this._conversionTrackingEnabled = t, this._cookieID = r;
    }, e;
  }()
);
var up = (
  /** @class */
  function() {
    function e(t, r) {
      t === void 0 && (t = window), r === void 0 && (r = document), this._outerWindow = t, this._outerDocument = r;
    }
    return e.prototype.setAndGetYextCookie = function() {
      var t = this.fetchCookie();
      return t || (t = e.generateRandomCookie().toString()), this.setCookieAndRemoveOldCookies(t), t;
    }, e.generateRandomCookie = function() {
      return Math.floor(Math.random() * (/* @__PURE__ */ new Date()).getTime());
    }, e.prototype.fetchCookie = function() {
      var t = this, r = "", o = function(f) {
        if (t.canSetCookieWithDomain(f)) {
          var h = t.removeCookieByDomain(f);
          return h && (r = h, t.setCookie(r, f)), true;
        }
      };
      return this.forEachDomainIncreasingSpecificity(o), r || o(""), r;
    }, e.prototype.forEachDomainIncreasingSpecificity = function(t) {
      for (var r = false, o = this._outerDocument.location.hostname.split(".").reverse(), f = "", h = 0; h < o.length; h++)
        if (f = "." + o[h] + f, t(f)) {
          r = true;
          break;
        }
      r || t("");
    }, e.prototype.removeCookieByDomain = function(t) {
      var r = this.persistentCookies();
      this.clearCookie(t);
      var o = this.persistentCookies();
      return o.length < r.length && e.listDifference(r, o)[0] || "";
    }, e.listDifference = function(t, r) {
      for (var o = Array.from(t), f = 0; f < r.length; f++) {
        var h = o.indexOf(r[f]);
        h !== -1 && o.splice(h, 1);
      }
      return o;
    }, e.prototype.persistentCookies = function() {
      return this.allCookies().filter(function(t) {
        return t !== Aa;
      });
    }, e.prototype.allCookies = function() {
      var t = [];
      return this.forEachCookieNameValue(function(r, o) {
        r === ol && t.push(o);
      }), t;
    }, e.prototype.forEachCookieNameValue = function(t) {
      this._outerDocument.cookie.split(";").forEach(function(r) {
        var o = r.split("="), f = o[0], h = o[1];
        f && h && t(f.trim(), h.trim());
      });
    }, e.prototype.setCookieAndRemoveOldCookies = function(t) {
      var r = this, o = false, f = this.allCookies().length, h = 0;
      this.forEachDomainIncreasingSpecificity(function(C) {
        if (o ? r.removeCookieByDomain(C) && h++ : r.canSetCookieWithDomain(C) && (r.removeCookieByDomain(C) && h++, r.setCookie(t, C), o = true), h >= f && o)
          return true;
      });
    }, e.prototype.canSetCookieWithDomain = function(t) {
      var r = this.removeCookieByDomain(t), o = this.allCookies();
      this.setCookie(Aa, t);
      var f = this.allCookies();
      return o.length < f.length ? (r ? this.setCookie(r, t) : this.clearCookie(t), true) : false;
    }, e.prototype.setCookie = function(t, r) {
      this._outerDocument.cookie = this.formatCookie(ol, t, r);
    }, e.prototype.formatCookie = function(t, r, o, f) {
      f === void 0 && (f = "/");
      var h = t + "=" + r, C = /* @__PURE__ */ new Date();
      return C.setTime(C.getTime() + 90 * 24 * 60 * 60 * 1e3), h += ";path=" + f, h += ";expires=" + C.toUTCString(), o && (h += ";domain=" + o), h += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (h += " Secure "), h;
    }, e.prototype.clearCookie = function(t, r) {
      t === void 0 && (t = ""), r === void 0 && (r = "/");
      var o = /* @__PURE__ */ new Date(0), f = ol + "=" + Aa;
      f += ";path=" + r, f += ";expires=" + o.toUTCString(), t && (f += ";domain=" + t + ";"), f += ";samesite=None;", this._outerWindow.location.protocol === "https:" && (f += " Secure "), this._outerDocument.cookie = f;
    }, e;
  }()
);
function dp(e) {
  var t = new Xg();
  return new cp(e, t);
}
function Gf(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]|[\s-]+/g, "");
}
function Tc(e, t) {
  return [e, t].filter((r) => !!r).map((r) => Gf(r)).join("_");
}
var fp = class {
  /**
   * Creates an Analytics instance, will fire a pageview event if requireOptin
   * is false
   *
   * @param templateData - template data object from the pages system
   * @param requireOptIn - boolean, set to true if you require user opt in before tracking analytics
   */
  constructor(t, r, o, f = []) {
    Ln(this, "_optedIn");
    Ln(this, "_conversionTrackingEnabled", false);
    Ln(this, "_cookieManager");
    Ln(this, "_analyticsReporter");
    Ln(this, "_pageViewFired", false);
    Ln(this, "_enableDebugging", false);
    this.templateData = t, this.pageDomain = o, this.productionDomains = f, this._optedIn = !r, this.makeReporter(), this.pageView();
  }
  calculatePageType() {
    var f, h, C, T;
    const t = !!((h = (f = this.templateData.document) == null ? void 0 : f.__) != null && h.staticPage), r = !!((T = (C = this.templateData.document) == null ? void 0 : C.__) != null && T.entityPageSet);
    let o;
    if (t)
      o = {
        name: "static",
        staticPageId: this.templateData.document.__.name
      };
    else if (r)
      o = {
        name: "entity",
        pageSetId: this.templateData.document.__.name,
        id: this.templateData.document.uid
      };
    else
      throw new Error("invalid document type");
    return o;
  }
  makeReporter() {
    if (ys().name !== "browser" || !this._optedIn)
      return;
    const t = Jg(...this.productionDomains);
    this._analyticsReporter = dp({
      businessId: this.templateData.document.businessId,
      pageType: this.calculatePageType(),
      pageUrl: window.location.href,
      production: t,
      referrer: document.referrer,
      siteId: this.templateData.document.siteId,
      pageDomain: this.pageDomain
    }), this.setDebugEnabled(this._enableDebugging);
  }
  canTrack() {
    return ys().name === "browser" && this._optedIn && !!this._analyticsReporter;
  }
  setupConversionTracking() {
    var t;
    this._cookieManager = new up(), (t = this._analyticsReporter) == null || t.setConversionTrackingEnabled(
      true,
      this._cookieManager.setAndGetYextCookie()
    );
  }
  /** {@inheritDoc AnalyticsMethods.enableConversionTracking} */
  enableTrackingCookie() {
    this._conversionTrackingEnabled = true, this.canTrack() && this.setupConversionTracking();
  }
  /** {@inheritDoc AnalyticsMethods.identify} */
  identify(t) {
    var r;
    this.canTrack() && ((r = this._analyticsReporter) == null || r.setVisitor(t));
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async optIn() {
    this._optedIn = true, this.makeReporter(), this._conversionTrackingEnabled && !this._cookieManager && this.setupConversionTracking(), this._pageViewFired || await this.pageView();
  }
  /** {@inheritDoc AnalyticsMethods.async} */
  async pageView() {
    var t;
    if (!this.canTrack())
      return Promise.resolve(void 0);
    await ((t = this._analyticsReporter) == null ? void 0 : t.pageView()), this._pageViewFired = true;
  }
  /** {@inheritDoc AnalyticsMethods.track} */
  async track(t, r) {
    var o;
    if (!this.canTrack())
      return Promise.resolve();
    await ((o = this._analyticsReporter) == null ? void 0 : o.track(
      { eventType: Gf(t) },
      r
    ));
  }
  /** {@inheritDoc AnalyticsMethods.setDebugEnabled} */
  setDebugEnabled(t) {
    var r;
    this._enableDebugging = t, (r = this._analyticsReporter) == null || r.setDebugEnabled(t);
  }
  /** {@inheritDoc AnalyticsMethods.trackClick} */
  trackClick(t, r) {
    return (o) => {
      if (!this.canTrack())
        return Promise.resolve();
      if (o.target === null || o.defaultPrevented)
        return this.track(t, r);
      const f = o.target;
      if (f.href === null || f.href === void 0)
        return this.track(t, r);
      const h = new URL(f.href);
      if (h.protocol === "mailto:" || h.protocol === "tel:" || // eslint-disable-next-line no-script-url
      h.protocol === "javascript:" || h.hostname === window.location.hostname)
        return this.track(t, r);
      if (f.target && !f.target.match(/^_(self|parent|top)$/i) || o.ctrlKey || o.shiftKey || o.metaKey)
        return this.track(t, r);
      o.preventDefault();
      const T = () => {
        window.location.assign(h);
      }, O = new Promise((S) => {
        setTimeout(() => {
          S();
        }, 1e3);
      });
      return Promise.race([this.track(t, r), O]).then(T).catch(T);
    };
  }
};
var Yf = (0, import_react.createContext)(null);
var jf = (0, import_react.createContext)({ name: "" });
var qf = () => (0, import_react.useContext)(jf).name;
function BC(e) {
  const t = qf(), [r] = (0, import_react.useState)({
    name: Tc(t, e.name)
  });
  return yt.jsx(jf.Provider, { value: r, children: e.children });
}
function oa() {
  const e = (0, import_react.useContext)(Yf);
  if (!e)
    return e;
  ys().name === "browser" && !window.setAnalyticsOptIn && (window.setAnalyticsOptIn = async () => {
    await e.optIn();
  });
  const t = qf();
  return {
    trackClick(r, o) {
      return e.trackClick(Tc(t, r), o);
    },
    setDebugEnabled(r) {
      return e.setDebugEnabled(r);
    },
    enableTrackingCookie() {
      return e.enableTrackingCookie();
    },
    identify(r) {
      return e.identify(r);
    },
    optIn() {
      return e.optIn();
    },
    pageView() {
      return e.pageView();
    },
    track(r, o) {
      return e.track(Tc(t, r), o);
    }
  };
}
var KC = () => {
  var e;
  return (e = oa()) == null ? void 0 : e.track;
};
var HC = () => {
  var e;
  return (e = oa()) == null ? void 0 : e.pageView;
};
var UC = () => {
  var e;
  return (e = oa()) == null ? void 0 : e.identify;
};
function WC(e) {
  var D;
  const {
    children: t,
    requireOptIn: r,
    enableTrackingCookie: o,
    enableDebugging: f,
    templateData: h,
    pageDomain: C,
    productionDomains: T
  } = e, O = (0, import_react.useRef)(null);
  O.current === null && (O.current = new fp(
    h,
    r,
    C,
    T
  ));
  const S = O.current;
  o && S.enableTrackingCookie();
  let x = hp();
  return ys().name === "node" && (x = x || ((D = process.env) == null ? void 0 : D.NODE_ENV) === "development"), S.setDebugEnabled(f ?? x), yt.jsx(Yf.Provider, { value: S, children: t });
}
function hp() {
  return ys().name !== "browser" || typeof window === void 0 ? false : !!new URL(window.location.href).searchParams.get("xYextDebug");
}
var ko = {
  /**
   * The the default layout if one is not specified. An image will be scaled down to fit the
   * container but not exceed the absolute size of the image.
   */
  INTRINSIC: "intrinsic",
  /**
   * Shows the image in a fixed size. `width` or `height` must be passed in. If both `width` and
   * `height` are passed in, but the aspect ratio does not match the aspect ratio of the image,
   * the image will be centered. This behavior can be adjusted using the `objectFit` and
   * `objectPosition` props of the `style` rpop.
   */
  FIXED: "fixed",
  /** Shows the image in a fixed aspect ratio. The `aspectRatio` prop must be provided. */
  ASPECT: "aspect",
  /** Always fills the image to 100% of the container's width. */
  FILL: "fill"
};
var Vf = /(https?:\/\/a.mktgcdn.com\/p(?<env>-sandbox|-qa|-dev)?\/)(?<uuid>.+)\/(.*)/;
var zC = ({
  image: e,
  className: t,
  width: r,
  height: o,
  aspectRatio: f,
  layout: h = ko.INTRINSIC,
  placeholder: C,
  imgOverrides: T,
  style: O = {},
  loading: S = "lazy"
}) => {
  const x = (0, import_react.useRef)(null), [D, k] = (0, import_react.useState)(false), H = "image" in e ? e.image : e;
  (0, import_react.useEffect)(() => {
    var V;
    (V = x.current) != null && V.complete && k(true);
  }, []), gp(
    h,
    H.width,
    H.height,
    r,
    o,
    f
  );
  const N = Math.abs(H.width);
  N || console.warn("Invalid image width.");
  const v = Math.abs(H.height);
  v || console.warn("Invalid image height.");
  const F = pp(H.url);
  if (!F)
    return yt.jsx(yt.Fragment, { children: C != null && C });
  const U = r && r > 0 ? r : void 0, I = o && o > 0 ? o : void 0, { src: K, imgStyle: B, widths: z } = mp(
    h,
    N,
    v,
    F,
    O,
    H.url,
    U,
    I,
    f
  ), te = z.map(
    (V) => `${xc(
      F,
      V,
      v / N * V,
      H.url
    )} ${V}w`
  ).join(", "), re = [640, 768, 1024, 1280, 1536], de = z.map(
    (V, G) => G === z.length - 1 ? `${V}px` : `(max-width: ${re[G]}px) ${V}px`
  ).join(", ");
  return yt.jsxs(yt.Fragment, { children: [
    !D && C != null && C,
    yt.jsx(
      "img",
      {
        ref: x,
        style: B,
        src: K,
        className: t,
        width: U,
        height: I,
        srcSet: te,
        sizes: de,
        loading: S,
        alt: H.alternateText || "",
        ...T
      }
    )
  ] });
};
var gp = (e, t, r, o, f, h) => {
  if (t < 0 && console.warn(`Invalid image width: ${t}.`), r < 0 && console.warn(`Invalid image height: ${r}.`), e === ko.FIXED) {
    if (!o && !f) {
      console.warn(
        "Using fixed layout but neither width nor height is passed as props."
      );
      return;
    }
    o && o < 0 && console.warn(`Using fixed layout but width is invalid: ${o}.`), f && f < 0 && console.warn(`Using fixed layout but height is invalid: ${f}.`);
    return;
  }
  (o || f) && console.warn(
    "Width or height is passed in but layout is not fixed. These will have no impact. If you want to have a fixed height or width then set layout to fixed."
  ), e === ko.ASPECT && !h && console.warn(
    "Using aspect layout but aspectRatio is not passed as a prop."
  );
};
var pp = (e) => {
  var r;
  const t = e.match(Vf);
  return (r = t == null ? void 0 : t.groups) != null && r.uuid ? t.groups.uuid : (console.error(`Invalid image url: ${e}.`), "");
};
var _p = (e) => {
  var r;
  const t = e.match(Vf);
  return (r = t == null ? void 0 : t.groups) == null ? void 0 : r.env;
};
var xc = (e, t, r, o) => {
  const f = _p(o);
  return `https://dynl.mktgcdn.com/${f ? `p${f}` : "p"}/${e}/${Math.round(
    t
  )}x${Math.round(r)}`;
};
var mp = (e, t, r, o, f, h, C, T, O) => {
  let S = [100, 320, 640, 960, 1280, 1920], x = xc(o, 500, 500, h);
  const D = { ...f };
  switch (D.objectFit = D.objectFit || "cover", D.objectPosition = D.objectPosition || "center", e) {
    case ko.INTRINSIC:
      D.maxWidth = t, D.width = "100%", D.aspectRatio = O ? `${O}` : `${t} / ${r}`;
      break;
    case ko.FIXED: {
      const { fixedWidth: k, fixedHeight: H, fixedWidths: N } = yp(
        t,
        r,
        S,
        C,
        T
      );
      D.width = k, D.height = H, S = N, x = xc(o, k, H, h);
      break;
    }
    case ko.ASPECT:
      D.aspectRatio = O ? `${O}` : `${t} / ${r}`;
      break;
    case ko.FILL:
      D.width = "100%", D.aspectRatio = O ? `${O}` : `${t} / ${r}`;
      break;
    default:
      console.warn(`Unrecognized layout: ${e}.`);
      break;
  }
  return { src: x, imgStyle: D, widths: S };
};
var yp = (e, t, r, o, f) => o && f ? {
  fixedWidth: o,
  fixedHeight: f,
  fixedWidths: [o]
} : o ? {
  fixedWidth: o,
  fixedHeight: o * t / e,
  fixedWidths: [o]
} : f ? {
  fixedWidth: f / t * e,
  fixedHeight: f,
  fixedWidths: [f / t * e]
} : {
  fixedWidth: e,
  fixedHeight: t,
  fixedWidths: r
};
var Jf = { exports: {} };
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var o = [], f = 0; f < arguments.length; f++) {
        var h = arguments[f];
        if (h) {
          var C = typeof h;
          if (C === "string" || C === "number")
            o.push(h);
          else if (Array.isArray(h)) {
            if (h.length) {
              var T = r.apply(null, h);
              T && o.push(T);
            }
          } else if (C === "object") {
            if (h.toString !== Object.prototype.toString && !h.toString.toString().includes("[native code]")) {
              o.push(h.toString());
              continue;
            }
            for (var O in h)
              t.call(h, O) && h[O] && o.push(O);
          }
        }
      }
      return o.join(" ");
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(Jf);
var Cp = Jf.exports;
var Ql = bc(Cp);
var Np = (e) => e.linkType === "Email" || !e.linkType && Zf(e.link) ? `mailto:${e.link}` : e.linkType === "Phone" ? `tel:${e.link}` : e.link;
var Zf = (e) => /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(e);
var Ep = (e) => {
  let t = "";
  for (let r = e.length - 1; r >= 0; t += e[r--])
    ;
  return t;
};
var Tp = (e) => "href" in e;
var xp = import_react.default.forwardRef(
  function(t, r) {
    const o = Tp(t) ? { link: t.href } : t.cta, { children: f, onClick: h, className: C, eventName: T, cta: O, ...S } = t, x = T || (O ? "cta" : "link"), D = oa(), k = t.obfuscate || t.obfuscate !== false && Zf(o.link), [H, N] = (0, import_react.useState)(false), v = async (B) => {
      if (N(true), D !== null)
        try {
          await D.trackClick(x, t.conversionDetails)(B);
        } catch {
          console.error("Failed to report click Analytics Event");
        }
      h && h(B);
    }, F = !f && !o.label, U = !H && k, I = {
      ...t.style,
      unicodeBidi: "bidi-override",
      direction: F && U ? "rtl" : "ltr"
    }, K = U ? Ep(o.link) : o.link;
    return yt.jsx(
      "a",
      {
        className: Ql("Link", C),
        href: H || !k ? Np(o) : "obfuscate",
        onClick: v,
        rel: t.target && !t.rel ? "noopener" : void 0,
        ref: r,
        style: I,
        ...S,
        children: f || o.label || K
      }
    );
  }
);
var GC = {
  URL: "URL",
  Email: "Email",
  Phone: "Phone"
};
var nn = Object.freeze({
  DEGREE: Symbol("deg"),
  KILOMETER: Symbol("km"),
  MILE: Symbol("mi"),
  RADIAN: Symbol("r")
});
var Ir = Object.freeze({
  MERCATOR: Symbol("mercator"),
  SPHERICAL: Symbol("spherical")
});
var La = 3959;
var Pa = 6371;
var vp = ["latitude", "lat"];
var Sp = ["longitude", "lon", "lng", "long"];
function bu(e, t) {
  for (const r of t)
    if (e[r] || e[r] === 0)
      return e[r];
}
function Mu(e) {
  switch (typeof e) {
    case "string":
    case "number":
      const t = Number.parseFloat(e);
      if (Number.isNaN(t))
        throw new Error(`'${e}' must be convertible to a Number'`);
      return t;
    default:
      throw new Error(
        `typeof '${e}' must be a number or a string that can be converted to a number, is '${typeof e}'`
      );
  }
}
function $o(e) {
  return e * Math.PI / 180;
}
function Mi(e) {
  return e / Math.PI * 180;
}
function wp(e, t) {
  const r = $o(e.latitude), o = $o(t.latitude), f = o - r, h = $o(t.longitude - e.longitude), C = Math.pow(Math.sin(f / 2), 2) + Math.cos(r) * Math.cos(o) * Math.pow(Math.sin(h / 2), 2);
  return 2 * Math.atan2(Math.sqrt(C), Math.sqrt(1 - C));
}
function Op(e, t) {
  const r = Math.tan(Math.PI / 360 * (e + 90)), o = Math.tan(Math.PI / 360 * (t + 90));
  return Math.log(o / r);
}
function Rp(e, t) {
  const o = Math.tan(Math.PI / 360 * (e + 90)) * Math.pow(Math.E, t);
  return Math.atan(o) * 360 / Math.PI - 90;
}
var Vt = class {
  /**
   * Constructor takes either 1 or 2 arguments.
   * 2 arguments: latitude and longitude.
   * 1 argument: an object with at least one {@link module:@yext/components-geo~Coordinate~LATITUDE_ALIASES latitude alias}
   * and one one {@link module:@yext/components-geo~CoordinateCoordinate~LONGITUDE_ALIASES longitude alias}.
   * @param {number|Object} latitudeOrObject
   * @param {number} [longitude] Optional only if the first argument is a {@link module:@yext/components-geo~Coordinate Coordinate}-like object
   */
  constructor(t, r) {
    let o = t;
    typeof t == "object" && (o = bu(t, vp), r = bu(t, Sp), o = typeof o == "function" ? o() : o, r = typeof r == "function" ? r() : r), this.latitude = o, this.longitude = r;
  }
  /**
   * Degrees latitude in the range [-90, 90].
   * If setting a value outside this range, it will be set to -90 or 90, whichever is closer.
   * @type {number}
   */
  get latitude() {
    return this._lat;
  }
  /**
   * Degrees longitude in the range [-Infinity, Infinity].
   * @type {number}
   */
  get longitude() {
    return this._lon;
  }
  /**
   * Degrees longitude in the range [-180, 180).
   * If the coordinate's longitude is outside this range, the equivalent value within it is used.
   * Examples: 123 => 123, 270 => -90, -541 => 179
   * @type {number}
   */
  get normalLon() {
    return ((this._lon + 180) % 360 + 360) % 360 - 180;
  }
  set latitude(t) {
    this._lat = Math.max(-90, Math.min(Mu(t), 90));
  }
  set longitude(t) {
    this._lon = Mu(t);
  }
  /**
   * Add distance to the coordinate to change its position.
   * @param {number} latDist latitude distance
   * @param {number} lonDist longitude distance
   * @param {module:@yext/components-geo~Unit} [unit=Unit.DEGREE] The unit of latDist and lonDist
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   */
  add(t, r, o = nn.DEGREE, f = Ir.SPHERICAL) {
    if (f === Ir.MERCATOR && (o === nn.DEGREE || o === nn.RADIAN)) {
      const h = o === nn.DEGREE ? $o(t) : t, C = o === nn.DEGREE ? r : Mi(r);
      this.latitude = Rp(this.latitude, h), this.longitude += C;
    } else
      switch (o) {
        case nn.DEGREE:
          this.latitude += t, this.longitude += r;
          break;
        case nn.KILOMETER:
          this.latitude += Mi(t) * Pa, this.longitude += Mi(r) * Pa * Math.cos($o(this.latitude));
          break;
        case nn.MILE:
          this.latitude += Mi(t) * La, this.longitude += Mi(r) * La * Math.cos($o(this.latitude));
          break;
        case nn.RADIAN:
          this.latitude += Mi(t), this.longitude += Mi(r);
          break;
        default:
          throw new Error(`unit unhandled: ${o}`);
      }
  }
  /**
   * Calculate the distance from this coordinate to another coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @param {module:@yext/components-geo~Unit} [unit=Unit.MILE] The unit of distance
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL] The projection of Earth (not relevant when using a physical distance unit, e.g. Mile)
   * @returns {number} Distance in the requested unit
   */
  distanceTo(t, r = nn.MILE, o = Ir.SPHERICAL) {
    if (o === Ir.MERCATOR && (r === nn.DEGREE || r === nn.RADIAN)) {
      const f = Op(
        this.latitude,
        t.latitude
      ), h = Math.abs(t.normalLon - this.normalLon), C = $o(
        Math.min(h, 360 - h)
      ), T = Math.sqrt(Math.pow(f, 2) + Math.pow(C, 2));
      switch (r) {
        case nn.DEGREE:
          return Mi(T);
        case nn.RADIAN:
          return T;
        default:
          throw new Error(`unit unhandled: ${r}`);
      }
    } else {
      const f = wp(this, t);
      switch (r) {
        case nn.DEGREE:
          return Mi(f);
        case nn.KILOMETER:
          return f * Pa;
        case nn.MILE:
          return f * La;
        case nn.RADIAN:
          return f;
        default:
          throw new Error(`unit unhandled: ${r}`);
      }
    }
  }
  /**
   * Test if this coordinate has the same latitude and longitude as another.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  equals(t) {
    return t && t.latitude === this.latitude && t.longitude === this.longitude;
  }
  /**
   * Get the coordinate as a string that can be used in a search query.
   * Example: {latitude: -45, longitude: 123} => '-45,123'
   * @returns {string}
   */
  searchQueryString() {
    return `${this.latitude},${this.longitude}`;
  }
};
function Xf(e, t = () => null) {
  const r = document.createElement("script");
  r.async = true, r.onload = t, r.src = e, document.head.appendChild(r);
}
var er = {
  UNDEFINED: "undefined",
  NULL: "object",
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null
  BOOLEAN: "boolean",
  NUMBER: "number",
  BIGINT: "bigint",
  STRING: "string",
  SYMBOL: "symbol",
  FUNCTION: "function",
  OBJECT: "object"
};
function hr(e, t) {
  if (typeof t != "string")
    throw new Error("Assertion error: 'type' must be a string");
  if (typeof e !== t)
    throw new Error(
      `Expected an object of type '${t}' but received '${typeof e}'`
    );
}
function tr(e, t) {
  let r;
  try {
    r = e instanceof t;
  } catch {
    throw new Error(
      "Assertion error: 'instanceClass' is not a valid constructor"
    );
  }
  if (!r)
    throw new Error(
      `Expected an instance of '${t.name}' but received '${e.constructor.name}'`
    );
}
var Qf = class {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into
   */
  constructor(t, r) {
    tr(t, Ko), tr(r, HTMLElement), this.providerMapClass = t.getMapClass(), this.wrapper = r, this.controlEnabled = true, this.panHandler = () => null, this.panStartHandler = () => null, this.providerOptions = {};
  }
  /**
   * @param {boolean} controlEnabled Whether the user can interact with the map
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withControlEnabled(t) {
    return this.controlEnabled = t, this;
  }
  /**
   * @param {function} panHandler Function called after the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanHandler(t) {
    return hr(t, er.FUNCTION), this.panHandler = t, this;
  }
  /**
   * @param {function} panStartHandler Function called before the map bounds change
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withPanStartHandler(t) {
    return hr(t, er.FUNCTION), this.panStartHandler = t, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options, usually by passing the object to the map's constructor
   * @returns {module:@yext/components-maps~ProviderMapOptions}
   */
  withProviderOptions(t) {
    return this.providerOptions = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap} An instance of a subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const t = this.providerMapClass;
    return new t(this);
  }
};
var Es = class {
  /**
   * The constructor creates a map instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderMapOptions ProviderMapOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    tr(t, Qf), this._panHandler = t.panHandler, this._panStartHandler = t.panStartHandler;
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The current center of the map
   */
  getCenter() {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    throw new Error("not implemented");
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The new center for the map
   * @param {boolean} animated Whether to transition smoothly to the new center
   */
  setCenter(t, r) {
    throw new Error("not implemented");
  }
  /**
   * Zoom level complies with the specifications in {@link module:@yext/components-maps~Map#getZoom Map#getZoom}
   * @param {number} zoom The new zoom level for the map
   * @param {boolean} animated Whether to transition smoothly to the new zoom
   */
  setZoom(t, r) {
    throw new Error("not implemented");
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} animated Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~ProviderMap#setZoom
   * @see module:@yext/components-maps~ProviderMap#setCenter
   */
  setZoomCenter(t, r, o) {
    this.setZoom(t, o), this.setCenter(r, o);
  }
};
var eh = class {
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   */
  constructor(t) {
    tr(t, Ko), this.providerPinClass = t.getPinClass(), this.clickHandler = () => null, this.focusHandler = (r) => null, this.hoverHandler = (r) => null, this.icons = {};
  }
  /**
   * @param {import('./mapPin.js').PinClickHandler} clickHandler Function called when the pin is clicked
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withClickHandler(t) {
    return hr(t, er.FUNCTION), this.clickHandler = t, this;
  }
  /**
   * @param {import('./mapPin.js').PinFocusHandler} focusHandler Function called when the pin becomes (un)focused
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withFocusHandler(t) {
    return hr(t, er.FUNCTION), this.focusHandler = t, this;
  }
  /**
   * @param {import('./mapPin.js').PinHoverHandler} hoverHandler Function called when the pin becomes (un)hovered
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withHoverHandler(t) {
    return hr(t, er.FUNCTION), this.hoverHandler = t, this;
  }
  /**
   * Similar to {@link module:@yext/components-maps~MapPinOptions#withIcon MapPinOptions#withIcon},
   * but all icons are given as a map of key => icon. If a provider pin instance needs an icon to be
   * a specialized class rather than a simple URL, the icons in this object can be converted in this
   * function and assigned back to the icons object instead of being recreated from the URL every
   * time the pin's icon changes.
   * @param {Object<string,string>} icons Map of a string key to the URL or data URI of an image
   * @returns {module:@yext/components-maps~ProviderPinOptions}
   */
  withIcons(t) {
    return this.icons = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin} An instance of a subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the given {@link module:@yext/components-maps~MapProvider MapProvider}
   */
  build() {
    const t = this.providerPinClass;
    return new t(this);
  }
};
var Lc = class {
  /**
   * The constructor creates a pin instance using the provider's API and initializes it with all the
   * given options. See {@link module:@yext/components-maps~ProviderPinOptions ProviderPinOptions}
   * for the supported options.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    tr(t, eh), this._clickHandler = t.clickHandler, this._focusHandler = t.focusHandler, this._hoverHandler = t.hoverHandler, this._icons = t.icons;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} coordinate The position of the pin
   */
  setCoordinate(t) {
    throw new Error("not implemented");
  }
  /**
   * Remove the pin from its current map and, if newMap is not null, add it to the new map.
   * @param {?module:@yext/components-maps~Map} newMap The new map -- if null, the pin will not be
   *   shown on any map
   * @param {?module:@yext/components-maps~Map} currentMap The current map -- if null, the pin is
   *   not shown on any map
   */
  setMap(t, r) {
    throw new Error("not implemented");
  }
  /**
   * Apply the given properties to modify the appearance of the pin.
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~PinProperties
   */
  setProperties(t) {
    throw new Error("not implemented");
  }
};
var Dp = Object.freeze({
  backgroundPosition: "center",
  backgroundRepeat: "no-repeat",
  backgroundSize: "contain",
  left: "0",
  outline: "none",
  pointerEvents: "auto",
  position: "absolute",
  top: "0"
});
var sa = class extends Lc {
  /**
   * This is the base style applied to pin elements. It is a map from CSS property to value, such
   * as 'position': 'absolute'
   * @type {Object}
   */
  static get baseStyle() {
    return Dp;
  }
  /**
   * After instatiating a {@link module:@yext/components-maps~ProviderPin ProviderPin}, this creates
   * a wrapper element and a default pin element.
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._pinEl = document.createElement("button"), Object.assign(this._pinEl.style, this.constructor.baseStyle), this._pinAlt = document.createElement("span"), this._pinAlt.classList.add("sr-only"), this._pinEl.appendChild(this._pinAlt), this._wrapper = document.createElement("div"), this._wrapper.style.pointerEvents = "none", this._wrapper.appendChild(this._pinEl), this.addListeners();
  }
  /**
   * Adds click, hover, and focus event listeners to the wrapper element
   */
  addListeners() {
    this._wrapper.addEventListener("click", () => this._clickHandler()), this._wrapper.addEventListener("focusin", () => this._focusHandler(true)), this._wrapper.addEventListener("focusout", () => this._focusHandler(false)), this._wrapper.addEventListener("mouseover", () => this._hoverHandler(true)), this._wrapper.addEventListener("mouseout", () => this._hoverHandler(false));
  }
  /**
   * @returns {HTMLElement} HTML button element for pin element
   */
  getPinElement() {
    return this._pinEl;
  }
  /**
   * @returns {HTMLElement} HTML button element for wrapper element
   */
  getWrapperElement() {
    return this._wrapper;
  }
  /**
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   * @see module:@yext/components-maps~ProviderPin#setProperties
   */
  setProperties(t) {
    this.setElementProperties(t);
    const r = t.getClass(), o = t.getElement() || this._pinEl, f = t.getZIndex();
    o.style.pointerEvents = "auto", this._wrapper && (this._wrapper.style.zIndex = f, this._wrapper.setAttribute("class", r), o !== this._wrapper.children[0] && (this._wrapper.children[0].style.pointerEvents = "", this._wrapper.removeChild(this._wrapper.children[0]), this._wrapper.appendChild(o)));
  }
  /**
   * Sets properties used specifically by the pin element
   * @param {module:@yext/components-maps~PinProperties} pinProperties
   */
  setElementProperties(t) {
    const r = t.getAnchorX(), o = t.getAnchorY(), f = t.getHeight(), h = this._icons[t.getIcon()], C = t.getSRText(), T = t.getWidth();
    Object.assign(this._pinEl.style, {
      backgroundImage: h ? `url("${h}")` : "",
      height: f + "px",
      transform: `translate(${-100 * r}%, ${-100 * o}%)`,
      width: T + "px"
    }), this._pinAlt.innerText = C;
  }
};
var Bo = class {
  constructor() {
    this.loadFunction = (t, r, o, f) => t(), this.mapClass = Es, this.pinClass = Lc, this.providerName = "";
  }
  /**
   * @param {module:@yext/components-maps~ProviderLoadFunction} loadFunction
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withLoadFunction(t) {
    return hr(t, er.FUNCTION), this.loadFunction = t, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderMap} mapClass Subclass of {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withMapClass(t) {
    return this.mapClass = t, this;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPin} pinClass Subclass of {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   for the provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withPinClass(t) {
    return this.pinClass = t, this;
  }
  /**
   * @param {string} providerName Name of the map provider
   * @returns {module:@yext/components-maps~MapProviderOptions}
   */
  withProviderName(t) {
    return this.providerName = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapProvider}
   */
  build() {
    return new Ko(this);
  }
};
var Ko = class {
  /**
   * @param {module:@yext/components-maps~MapProviderOptions} options
   */
  constructor(t) {
    tr(t, Bo), this._loadFunction = t.loadFunction, this._mapClass = t.mapClass, this._pinClass = t.pinClass, this._providerName = t.providerName, this._loadPromise = new Promise((r, o) => {
      this._resolveLoad = r, this._rejectLoad = o;
    }), this._apiKey = "", this._loadInvoked = false, this._loaded = false, this._options = {};
  }
  /**
   * Returns true if the map provider has been successfully loaded
   * @type {boolean}
   */
  get loaded() {
    return this._loaded;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderMap}
   * @see module:@yext/components-maps~MapProviderOptions#withMapClass
   */
  getMapClass() {
    return this._mapClass;
  }
  /**
   * @returns {module:@yext/components-maps~ProviderPin}
   * @see module:@yext/components-maps~MapProviderOptions#withPinClass
   */
  getPinClass() {
    return this._pinClass;
  }
  /**
   * @returns {string}
   * @see module:@yext/components-maps~MapProviderOptions#withProviderName
   */
  getProviderName() {
    return this._providerName;
  }
  /**
   * Call {@link module:@yext/components-maps~MapPinOptions~loadFunction MapPinOptions~loadFunction}
   * and resolve or reject when loading succeeds or fails
   * @async
   * @param {string} [apiKey] Provider API key -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   * @param {Object} [options] Additional provider-specific options -- uses value from {@link module:@yext/components-maps~MapProvider#setLoadOptions MapProvider#setLoadOptions}
   *   if not passed
   */
  async load(t = this._apiKey, r = this._options) {
    this._loadInvoked || (this._loadInvoked = true, this._loadFunction(this._resolveLoad, this._rejectLoad, t, r)), await this.ready(), this._loaded = true;
  }
  /**
   * Resolves or rejects when the map provider has loaded successfully or unsuccessfully
   * @async
   */
  async ready() {
    await this._loadPromise;
  }
  /**
   * Set the API key and provider options used on load. Does nothing if load was already called.
   * @param {string} apiKey Provider API key
   * @param {?Object} [options=null] Additional provider-specific options
   */
  setLoadOptions(t, r = null) {
    this._loadInvoked || (this._apiKey = t, this._options = r || this._options);
  }
};
var Lu = {
  GEOCODER: "geocoder",
  PLACES: "places"
};
var Ap = class extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t), this.map = new google.maps.Map(t.wrapper, {
      disableDefaultUI: !t.controlEnabled,
      fullscreenControl: false,
      gestureHandling: t.controlEnabled ? "auto" : "none",
      mapTypeControl: false,
      rotateControl: false,
      scaleControl: false,
      streetViewControl: false,
      zoomControl: t.controlEnabled,
      zoomControlOptions: {
        position: google.maps.ControlPosition.RIGHT_TOP
      },
      ...t.providerOptions
    }), this._moving = false, google.maps.event.addListener(this.map, "bounds_changed", () => {
      this._moving || (this._moving = true, this._panStartHandler());
    }), google.maps.event.addListener(this.map, "idle", () => {
      this._moving = false, this._panHandler();
    });
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new google.maps.LatLng(
      t.latitude,
      t.longitude
    );
    r ? this.map.panTo(o) : this.map.setCenter(o);
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map.setZoom(Math.floor(t));
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(t, r, o) {
    this.setCenter(r, o), this.setZoom(t, o);
  }
};
var bp = class extends sa {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._wrapper.style.position = "absolute", google.maps.OverlayView.preventMapHitsAndGesturesFrom(this._wrapper);
    const r = this;
    class o extends google.maps.OverlayView {
      draw() {
        var C;
        const h = (C = this.getProjection()) == null ? void 0 : C.fromLatLngToDivPixel(
          r._latLng
        );
        h && (r._wrapper.style.left = h.x + "px", r._wrapper.style.top = h.y + "px");
      }
      onAdd() {
        this.getPanes().floatPane.appendChild(r._wrapper);
      }
      onRemove() {
        var h;
        (h = r._wrapper.parentNode) == null || h.removeChild(r._wrapper);
      }
    }
    this.pin = new o();
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this._latLng = new google.maps.LatLng(
      t.latitude,
      t.longitude
    ), this.pin.draw();
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    this.pin.setMap(t ? t.getProviderMap().map : null);
  }
};
var Pu = "GoogleMapsCallback_b7d77ff2";
var Mp = "https://maps.googleapis.com/maps/api/js";
function Lp(e, t, r, {
  autocomplete: o = false,
  channel: f = window.location.hostname,
  client: h,
  language: C,
  region: T,
  libraries: O = [],
  params: S = {}
} = {}) {
  window[Pu] = e, o && O.push(Lu.GEOCODER, Lu.PLACES);
  const x = {
    callback: Pu,
    channel: f,
    libraries: O.join(","),
    ...S
  };
  r && (x.key = r), h && (x.client = h), C && (x.language = C), T && (x.region = T), Xf(
    Mp + "?" + Object.entries(x).map(([D, k]) => D + "=" + k).join("&")
  );
}
var th = new Bo().withLoadFunction(Lp).withMapClass(Ap).withPinClass(bp).withProviderName("Google").build();
var Po = class {
  /**
   * Create a new {@link module:@yext/components-geo~GeoBounds GeoBounds} with minimal area that
   * contains all the given coordinates
   * @param {module:@yext/components-geo~Coordinate[]} coordinates
   * @returns {module:@yext/components-geo~GeoBounds}
   */
  static fit(t) {
    const r = t.map((S) => S.latitude), o = Math.max(...r), f = Math.min(...r), h = t.map((S) => S.normalLon).sort((S, x) => S - x), C = h.map((S, x) => ({ distance: (x < h.length - 1 ? h[x + 1] : h[0] + 360) - S, index: x })).reduce(
      (S, x) => x.distance > S.distance ? x : S
    ).index, T = h[C], O = h[(C + 1) % h.length];
    return new this(new Vt(f, O), new Vt(o, T));
  }
  /**
   * @param {module:@yext/components-geo~Coordinate} sw Southwest coordinate
   * @param {module:@yext/components-geo~Coordinate} ne Northeast coordinate
   */
  constructor(t, r) {
    this._ne = new Vt(r), this._sw = new Vt(t);
  }
  /**
   * Northeast coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get ne() {
    return this._ne;
  }
  /**
   * Southwest coordinate
   * @type {module:@yext/components-geo~Coordinate}
   */
  get sw() {
    return this._sw;
  }
  set ne(t) {
    this._ne = new Vt(t);
  }
  set sw(t) {
    this._sw = new Vt(t);
  }
  /**
   * Whether the coordinate lies within the region defined by the bounds.
   * {@link module:@yext/components-geo~Coordinate#normalLon Normalized longitudes} are used for the
   * bounds and the coordinate.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   * @returns {boolean}
   */
  contains(t) {
    const r = this._sw.latitude <= t.latitude && t.latitude <= this._ne.latitude, o = this._ne.longitude - this._sw.longitude >= 360, f = this._sw.normalLon <= this._ne.normalLon ? this._sw.normalLon <= t.normalLon && t.normalLon <= this._ne.normalLon : this._sw.normalLon <= t.normalLon || t.normalLon <= this._ne.normalLon;
    return r && (o || f);
  }
  /**
   * Extend the bounds if necessary so that the coordinate is contained by them.
   * @param {module:@yext/components-geo~Coordinate} coordinate
   */
  extend(t) {
    if (this._ne.latitude = Math.max(this._ne.latitude, t.latitude), this._sw.latitude = Math.min(this._sw.latitude, t.latitude), !this.contains(t)) {
      const r = ((t.longitude - this._ne.longitude) % 360 + 360) % 360, o = ((this._sw.longitude - t.longitude) % 360 + 360) % 360;
      r < o ? this._ne.longitude += r : this._sw.longitude -= o;
    }
  }
  /**
   * Calculate the center of the bounds using the given projection.
   * To find the visual center on a Mercator map, use Projection.MERCATOR.
   * To find the center for geolocation or geosearch purposes, use Projection.SPHERICAL.
   * @param {module:@yext/components-geo~Projection} [projection=Projection.SPHERICAL]
   * @returns {module:@yext/components-geo~Coordinate}
   */
  getCenter(t = Ir.SPHERICAL) {
    const r = new Vt(this._ne.latitude, this._sw.longitude), o = this._sw.distanceTo(r, nn.DEGREE, t), f = (r.longitude + this._ne.longitude) / 2 + (this._ne.longitude < r.longitude ? 180 : 0);
    return r.add(-o / 2, 0, nn.DEGREE, t), r.longitude = f, r;
  }
};
var Pp = class {
  constructor() {
    this._anchorX = 0.5, this._anchorY = 1, this._height = 39, this._icon = "default", this._srText = "map pin", this._width = 33, this._zIndex = 0, this._class = "", this._element = null;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (left edge) to 1 (right edge)
   */
  getAnchorX() {
    return this._anchorX;
  }
  /**
   * @returns {number} The point in the pin that should be positioned over the coordinate, from 0
   *   (top edge) to 1 (bottom edge)
   */
  getAnchorY() {
    return this._anchorY;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The class of the wrapper element for an HTML pin
   */
  getClass() {
    return this._class;
  }
  /**
   * {@link module:@yext/components-maps~HTMLProviderPin HTMLProviderPins} only
   * @returns {string} The HTML pin element
   */
  getElement() {
    return this._element;
  }
  /**
   * @returns {number} The pixel height of the pin
   */
  getHeight() {
    return this._height;
  }
  /**
   * This returns a string key that can be used with {@link module:@yext/components-maps~MapPin#getIcon MapPin#getIcon}
   * to get the icon image for a pin.
   * @returns {string} The unique name of the icon
   */
  getIcon() {
    return this._icon;
  }
  /**
   * @returns {string} The text that a screen reader reads when focused on the pin
   */
  getSRText() {
    return this._srText;
  }
  /**
   * @returns {number} The pixel width of the pin
   */
  getWidth() {
    return this._width;
  }
  /**
   * @returns {number} The z-index of the pin
   */
  getZIndex() {
    return this._zIndex;
  }
  /**
   * @param {number} anchorX
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorX
   */
  setAnchorX(t) {
    return this._anchorX = t, this;
  }
  /**
   * @param {number} anchorY
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getAnchorY
   */
  setAnchorY(t) {
    return this._anchorY = t, this;
  }
  /**
   * @param {string} className
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getClass
   */
  setClass(t) {
    return this._class = t, this;
  }
  /**
   * @param {HTMLElement} element
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getElement
   */
  setElement(t) {
    return this._element = t, this;
  }
  /**
   * @param {number} height
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getHeight
   */
  setHeight(t) {
    return this._height = t, this;
  }
  /**
   * @param {string} icon
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getIcon
   */
  setIcon(t) {
    return this._icon = t, this;
  }
  /**
   * @param {string} srText
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getSRText
   */
  setSRText(t) {
    return this._srText = t, this;
  }
  /**
   * @param {number} width
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getWidth
   */
  setWidth(t) {
    return this._width = t, this;
  }
  /**
   * @param {number} zIndex
   * @returns {module:@yext/components-maps~PinProperties}
   * @see module:@yext/components-maps~PinProperties#getZIndex
   */
  setZIndex(t) {
    return this._zIndex = t, this;
  }
};
var Pc = class {
  /**
   * Initialize with default options
   */
  constructor() {
    this.coordinate = new Vt(0, 0), this.hideOffscreen = false, this.icons = {}, this.propertiesForStatus = (t) => new Pp(), this.provider = null, this.type = "";
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withCoordinate(t) {
    return this.coordinate = new Vt(t), this;
  }
  /**
   * @param {boolean} hideOffscreen If true, the pin will only be rendered if it's in the visible
   *   portion of the map to improve performance
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withHideOffscreen(t) {
    return this.hideOffscreen = t, this;
  }
  /**
   * @param {string} key The unique name for the icon, used in {@link module:@yext/components-maps~PinProperties#getIcon PinProperties#getIcon}
   *   and {@link module:@yext/components-maps~PinProperties#setIcon PinProperties#setIcon}
   * @param {string} icon The URL or data URI of the icon image
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withIcon(t, r) {
    return this.icons[t] = r, this;
  }
  /**
   * @param {module:@yext/components-maps~PinPropertiesForStatus} propertiesForStatus
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withPropertiesForStatus(t) {
    return hr(t, er.FUNCTION), this.propertiesForStatus = t, this;
  }
  /**
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withProvider(t) {
    return tr(t, Ko), this.provider = t, this;
  }
  /**
   * @param {string} type A string describing the type of the pin
   * @returns {module:@yext/components-maps~MapPinOptions}
   */
  withType(t) {
    return this.type = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~MapPin}
   */
  build() {
    return new Ip(this);
  }
};
var Ip = class {
  /**
   * @param {module:@yext/components-maps~MapPinOptions} options
   */
  constructor(t) {
    if (tr(t, Pc), tr(t.provider, Ko), !t.provider.loaded)
      throw new Error(
        `MapProvider '${t.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling MapPin constructor.`
      );
    this._coordinate = t.coordinate, this._hideOffscreen = t.hideOffscreen, this._icons = { ...t.icons }, this._propertiesForStatus = t.propertiesForStatus, this._type = t.type, this._clickHandler = () => null, this._focusHandler = (r) => this._hoverHandler(r), this._hoverHandler = (r) => null, this._hidden = false, this._cancelHiddenUpdater = () => null, this._map = null, this._pin = new eh(t.provider).withIcons({ ...this._icons }).withClickHandler(() => this._clickHandler()).withFocusHandler((r) => this._focusHandler(r)).withHoverHandler((r) => this._hoverHandler(r)).build(), this._pin.setCoordinate(t.coordinate), this._status = {}, this.setStatus(this._status);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The coordinate of the pin
   */
  getCoordinate() {
    return this._coordinate;
  }
  /**
   * Get the icon for a string key, such as 'default', 'hovered', or 'selected'
   * @param {string} key The unique name of the icon
   * @returns {string} The URL or data URI of the icon image
   * @see module:@yext/components-maps~MapPinOptions#withIcon
   */
  getIcon(t) {
    return this._icons[t];
  }
  /**
   * @returns {module:@yext/components-maps~Map} The map that the pin is currently on, or null if
   * not on a map
   */
  getMap() {
    return this._map;
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderPin} The pin's {@link module:@yext/components-maps~ProviderPin ProviderPin}
   *   instance
   */
  getProviderPin() {
    return this._pin;
  }
  /**
   * @returns {string} The string describing the type of pin
   */
  getType() {
    return this._type;
  }
  /**
   * Remove this pin from its current map, if on one.
   */
  remove() {
    this.setMap(null);
  }
  /**
   * Set a handler function for when the pin is clicked, replacing any previously set click handler.
   * @param {module:@yext/components-maps~PinClickHandler} clickHandler
   */
  setClickHandler(t) {
    hr(t, er.FUNCTION), this._clickHandler = t;
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   */
  setCoordinate(t) {
    this._coordinate = new Vt(t), this._pin.setCoordinate(this._coordinate), this._hideOffscreen && this._hideIfOffscreen();
  }
  /**
   * Set a handler function for when the pin is (un)focused, replacing any previously set focus handler.
   * @param {module:@yext/components-maps~PinFocusHandler} focusHandler
   */
  setFocusHandler(t) {
    hr(t, er.FUNCTION), this._focusHandler = t;
  }
  /**
   * Set a handler function for when the pin is (un)hovered, replacing any previously set hover handler.
   * @param {module:@yext/components-maps~PinHoverHandler} hoverHandler
   */
  setHoverHandler(t) {
    hr(t, er.FUNCTION), this._hoverHandler = t;
  }
  /**
   * Add the pin to a map, removing it from its current map if on one.
   * @param {?Map} map
   */
  setMap(t) {
    if (t !== this._map && (t !== null && tr(t, rh), this._pin.setMap(t, this._hidden ? null : this._map), this._map = t, this._hidden = false, this._cancelHiddenUpdater(), t && this._hideOffscreen)) {
      let r = false;
      const o = new Promise((f) => {
        this._cancelHiddenUpdater = () => {
          r = true, f();
        };
      });
      (async () => {
        for (; !r; )
          this._hideIfOffscreen(), await Promise.race([o, t.moving()]), await Promise.race([o, t.idle()]);
      })();
    }
  }
  /**
   * Assign all properties in an object to the pin's status.
   * Example: if the pin's status is { a: true, b: true }, passing in { a: false, c: true } will
   * change the pin's status to { a: false, b: true, c: true }
   * @param {Object} status
   */
  setStatus(t) {
    Object.assign(this._status, t), this._pin.setProperties(this._propertiesForStatus(this._status));
  }
  /**
   * Add or remove the pin from the map based on whether its coordinate is within the current bounds
   * @protected
   */
  _hideIfOffscreen() {
    if (this._map) {
      const t = this._map.getBounds().contains(this._coordinate);
      this._hidden && t ? this._pin.setMap(this._map, null) : !this._hidden && !t && this._pin.setMap(null, this._map), this._hidden = !t;
    }
  }
};
var io = 0.98;
function ql(e, t) {
  return Math.max(typeof e == er.FUNCTION ? e() : e || 0, 0) / t;
}
var nh = class {
  /**
   * Initialize with default options
   */
  constructor() {
    this.controlEnabled = true, this.defaultCenter = new Vt(39.83, -98.58), this.defaultZoom = 4, this.legendPins = [], this.padding = {
      bottom: () => 50,
      left: () => 50,
      right: () => 50,
      top: () => 50
    }, this.panHandler = (t, r) => null, this.panStartHandler = (t) => null, this.provider = null, this.providerOptions = {}, this.singlePinZoom = 14, this.wrapper = null;
  }
  /**
   * @param {boolean} controlEnabled Whether the user can move and zoom the map
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withControlEnabled(t) {
    return this.controlEnabled = t, this;
  }
  /**
   * @param {module:@yext/components-tsx-geo~Coordinate} defaultCenter The center on initial load and
   *   when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates} with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultCenter(t) {
    return this.defaultCenter = new Vt(t), this;
  }
  /**
   * @param {number} defaultZoom The zoom on initial load and when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an empty array
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withDefaultZoom(t) {
    return this.defaultZoom = t, this;
  }
  /**
   * @todo GENERATOR TODO Map legend not yet implemented
   * @param {module:@yext/components-maps~MapPin[]} legendPins Pins used to construct the map legend
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withLegendPins(t) {
    return this.legendPins = Array.from(t), this;
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * See {@link module:@yext/components-maps~Map#setPadding Map#setPadding} for more information.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~MapOptions}
   * @see module:@yext/components-maps~Map#setPadding
   */
  withPadding(t) {
    return this.padding = t, this;
  }
  /**
   * @param {module:@yext/components-maps~PanHandler} panHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanHandler(t) {
    return hr(t, er.FUNCTION), this.panHandler = t, this;
  }
  /**
   * @param {module:@yext/components-maps~PanStartHandler} panStartHandler
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withPanStartHandler(t) {
    return hr(t, er.FUNCTION), this.panStartHandler = t, this;
  }
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} must be loaded before
   * constructing the {@link module:@yext/components-maps~Map Map}.
   * @param {module:@yext/components-maps~MapProvider} provider
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProvider(t) {
    return tr(t, Ko), this.provider = t, this;
  }
  /**
   * @param {Object} providerOptions A free-form object used to set any additional provider-specific
   *   options in the {@link module:@yext/components-maps~ProviderMap ProviderMap}
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withProviderOptions(t) {
    return this.providerOptions = t, this;
  }
  /**
   * @param {number} singlePinZoom The zoom when calling {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}
   *   with an array containing one coordinate
   * @returns {MapOptions}
   */
  withSinglePinZoom(t) {
    return this.singlePinZoom = t, this;
  }
  /**
   * @param {HTMLElement} wrapper The wrapper element that the map will be inserted into. The
   *   existing contents of the element will be removed.
   * @returns {module:@yext/components-maps~MapOptions}
   */
  withWrapper(t) {
    return tr(t, HTMLElement), this.wrapper = t, this;
  }
  /**
   * @returns {module:@yext/components-maps~Map}
   */
  build() {
    return new rh(this);
  }
};
var rh = class {
  /**
   * The {@link module:@yext/components-maps~MapProvider MapProvider} for the map must be loaded
   * before calling this constructor.
   * @param {module:@yext/components-maps~MapOptions} options
   */
  constructor(t) {
    if (tr(t, nh), tr(t.provider, Ko), tr(t.wrapper, HTMLElement), !t.provider.loaded)
      throw new Error(
        `MapProvider '${t.provider.getProviderName()}' is not loaded. The MapProvider must be loaded before calling Map constructor.`
      );
    for (this._defaultCenter = t.defaultCenter, this._defaultZoom = t.defaultZoom, this._legendPins = t.legendPins, this._provider = t.provider, this._singlePinZoom = t.singlePinZoom, this._wrapper = t.wrapper, this._padding = {}, this.setPadding(t.padding), this._cachedBounds = null, this._resolveIdle = () => null, this._resolveMoving = () => null, this._idlePromise = Promise.resolve(), this._setIdle(), this.setPanHandler(t.panHandler), this.setPanStartHandler(t.panStartHandler); this._wrapper.firstChild; )
      this._wrapper.removeChild(this._wrapper.lastChild);
    this._panHandlerRunning = false, this._panStartHandlerRunning = false, this._map = new Qf(t.provider, this._wrapper).withControlEnabled(t.controlEnabled).withPanHandler(() => this.panHandler()).withPanStartHandler(() => this.panStartHandler()).withProviderOptions(t.providerOptions).build(), this.setZoomCenter(this._defaultZoom, this._defaultCenter), this._currentBounds = this.getBounds();
  }
  /**
   * Set the map bounds so that all the given coordinates are within the {@link module:@yext/components-maps~MapOptions#withPadding padded}
   * view.
   * @param {module:@yext/components-tsx-geo~Coordinate[]} coordinates
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {number} [maxZoom=singlePinZoom] The max zoom level after fitting. Uses {@link module:@yext/components-maps~MapOptions#withSinglePinZoom singlePinZoom}
   *   by default.
   */
  fitCoordinates(t, r = false, o = this._singlePinZoom) {
    t.length ? this.setBounds(
      Po.fit(t),
      r,
      this._padding,
      o
    ) : this.setZoomCenter(this._defaultZoom, this._defaultCenter, r);
  }
  /**
   * Get the current visible region of the map. If the map is zoomed out to show multiple copies of
   * the world, the longitude bounds will be outside [-180, 180) but the center will always be
   * within [-180, 180).
   * @returns {module:@yext/components-tsx-geo~GeoBounds}
   */
  getBounds() {
    if (!this._cachedBounds) {
      const t = this._wrapper.offsetHeight, r = this._wrapper.offsetWidth, o = this.getZoom(), f = this.getCenter(), h = 360 / Math.pow(2, o + 8), C = r * h, T = t * h;
      this._cachedBounds = new Po(f, f), this._cachedBounds.ne.add(
        T / 2,
        C / 2,
        nn.DEGREE,
        Ir.MERCATOR
      ), this._cachedBounds.sw.add(
        -T / 2,
        -C / 2,
        nn.DEGREE,
        Ir.MERCATOR
      ), this.moving().then(() => this._cachedBounds = null);
    }
    return new Po(this._cachedBounds.sw, this._cachedBounds.ne);
  }
  /**
   * @returns {module:@yext/components-tsx-geo~Coordinate} The center of the current visible region of
   *   the map
   */
  getCenter() {
    return this._map.getCenter();
  }
  /**
   * Intended for internal use only
   * @returns {module:@yext/components-maps~ProviderMap} The map's {@link module:@yext/components-maps~ProviderMap ProviderMap}
   *   instance
   */
  getProviderMap() {
    return this._map;
  }
  /**
   * To standardize zoom for all providers, zoom level is calculated with this formula:
   * zoom = log2(pixel width of equator) - 8.
   * At zoom = 0, the entire world is 256 pixels wide.
   * At zoom = 1, the entire world is 512 pixels wide.
   * Zoom 2 → 1024 pixels, zoom 3 → 2056 pixels, etc.
   * Negative and non-integer zoom levels are valid and follow the formula.
   * @returns {number} The current zoom level of the map
   */
  getZoom() {
    return this._map.getZoom();
  }
  /**
   * Returns when the map is not moving.
   * Use map.idle().then(callback) to run callback immediately if the map is currently idle or once
   * the map becomes idle if it's not.
   */
  async idle() {
    await this._idlePromise;
  }
  /**
   * Returns when the map is moving.
   * Use map.moving().then(callback) to run callback immediately if the map is currently moving or
   * once the map starts moving if it's not.
   */
  async moving() {
    await this._movingPromise;
  }
  /**
   * @returns {module:@yext/components-maps~MapPinOptions} A {@link module:@yext/components-maps~MapPinOptions MapPinOptions}
   *   instance with the same provider as this map
   */
  newPinOptions() {
    return new Pc().withProvider(this._provider);
  }
  /**
   * Called when the map has finished moving, at most once per animation frame.
   * Passes the current and previous bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanHandler MapOptions#withPanHandler}
   */
  panHandler() {
    this._panHandlerRunning || (this._panHandlerRunning = true, requestAnimationFrame(() => {
      const t = this._currentBounds;
      this._currentBounds = this.getBounds(), this._panHandler(
        t,
        new Po(
          new Vt(this._currentBounds.sw),
          new Vt(this._currentBounds.ne)
        )
      ), this._panHandlerRunning = false;
    }), this._setIdle());
  }
  /**
   * Called when the map has started moving, at most once per animation frame.
   * Passes the current bounds to the custom pan handler given by {@link module:@yext/components-maps~MapOptions#withPanStartHandler MapOptions#withPanStartHandler}
   */
  panStartHandler() {
    this._panStartHandlerRunning || (this._panStartHandlerRunning = true, requestAnimationFrame(() => {
      this._panStartHandler(
        new Po(
          new Vt(this._currentBounds.sw),
          new Vt(this._currentBounds.ne)
        )
      ), this._panStartHandlerRunning = false;
    }), this._setMoving());
  }
  /**
   * @param {Object} bounds
   * @param {Object} bounds.ne The northeast corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {Object} bounds.sw The southwest corner of the bounds -- must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @param {Object} [padding={}]
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @param {number} [maxZoom=Infinity]
   */
  setBounds({ ne: t, sw: r }, o = false, f = {}, h = 1 / 0) {
    const C = this._wrapper.offsetHeight, T = this._wrapper.offsetWidth;
    if (!C || !T)
      return;
    let O = ql(f.bottom, C), S = ql(f.left, T), x = ql(f.right, T), D = ql(f.top, C), k = S + x, H = O + D;
    k > io && (S *= io / k, x *= io / k, k = io), H > io && (O *= io / H, D *= io / H, H = io);
    const N = C * (1 - H), v = T * (1 - k), F = new Po(r, t), U = new Vt(F.ne.latitude, F.sw.longitude), I = F.sw.distanceTo(U, nn.DEGREE, Ir.MERCATOR), K = (F.ne.longitude - U.longitude + 360) % 360;
    let B = Math.max(I, K * N / v) / (1 - H), z = Math.max(K, I * v / N) / (1 - k), te = Math.log2(T * 360 / z) - 8;
    te > h && (te = h, z = T * 360 / 2 ** (te + 8), B = z * C / T);
    const re = F.getCenter(Ir.MERCATOR), de = (D - O) / 2 * B, V = (x - S) / 2 * z;
    re.add(de, V, nn.DEGREE, Ir.MERCATOR), this.setZoomCenter(te, re, o);
  }
  /**
   * @param {Object} coordinate Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new center
   */
  setCenter(t, r = false) {
    this._map.setCenter(new Vt(t), r);
  }
  /**
   * Padding is used by {@link module:@yext/components-maps~Map#fitCoordinates Map#fitCoordinates}.
   * Padding can either be constant values or funtions that return a padding value.
   * Constant values are good if the map should always have the same padding on every breakpoint.
   * Functions are useful if the map should have different padding at different breakpoints/layouts.
   * The function can check window.innerWidth or any other condition before returning a number.
   * @param {Object} padding
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.bottom Minimum number of
   *   pixels between the map's bottom edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.left Minimum number of
   *   pixels between the map's left edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.right Minimum number of
   *   pixels between the map's right edge and a pin
   * @param {number|module:@yext/components-maps~PaddingFunction} padding.top Minimum number of
   *   pixels between the map's top edge and a pin
   * @returns {module:@yext/components-maps~Map}
   */
  setPadding({
    bottom: t = this._padding.bottom,
    left: r = this._padding.left,
    right: o = this._padding.right,
    top: f = this._padding.top
  }) {
    return this._padding = { bottom: t, left: r, right: o, top: f }, this;
  }
  /**
   * @param {module:@yext/components-maps~Map~panHandler} panHandler
   */
  setPanHandler(t) {
    hr(t, er.FUNCTION), this._panHandler = t;
  }
  /**
   * @param {module:@yext/components-maps~Map~panStartHandler} panStartHandler
   */
  setPanStartHandler(t) {
    hr(t, er.FUNCTION), this._panStartHandler = t;
  }
  /**
   * @param {number} zoom
   * @param {boolean} [animated=false] Whether to transition smoothly to the new zoom
   * @see module:@yext/components-maps~Map#getZoom
   */
  setZoom(t, r = false) {
    this._map.setZoom(t, r);
  }
  /**
   * @param {number} zoom
   * @param {Object} center Must be convertible to {@link module:@yext/components-tsx-geo~Coordinate Coordinate}
   * @param {boolean} [animated=false] Whether to transition smoothly to the new bounds
   * @see module:@yext/components-maps~Map#setZoom
   * @see module:@yext/components-maps~Map#setCenter
   */
  setZoomCenter(t, r, o = false) {
    this._map.setZoomCenter(t, r, o);
  }
  /**
   * Set the map state to idle
   * @protected
   */
  _setIdle() {
    this._resolveMoving(), this._movingPromise = new Promise(
      (t) => this._resolveMoving = t
    ), this._resolveIdle();
  }
  /**
   * Set the map state to moving
   * @protected
   */
  _setMoving() {
    this._resolveIdle(), this._idlePromise = new Promise((t) => this._resolveIdle = t), this._resolveMoving();
  }
};
var la = (0, import_react.createContext)(null);
function jC() {
  const e = (0, import_react.useContext)(la);
  if (!e || e.map === void 0)
    throw new Error("Attempted to call useMapContext() outside of <Map>.");
  return e.map;
}
var ih = ({
  apiKey: e,
  bounds: t,
  children: r,
  className: o,
  clientKey: f,
  controls: h,
  defaultCenter: C,
  defaultZoom: T,
  mapRef: O,
  padding: S,
  panStartHandler: x,
  panHandler: D,
  provider: k,
  providerOptions: H = {},
  singleZoom: N
}) => {
  const v = (0, import_react.useRef)(null), [F, U] = (0, import_react.useState)(C), [I, K] = (0, import_react.useState)(false), [B, z] = (0, import_react.useState)(), [te, re] = (0, import_react.useState)(T), de = (V, G) => {
    D(V, G), U(G.getCenter());
  };
  return (0, import_react.useEffect)(() => {
    !I || !B || re(B.getZoom());
  }, [F]), (0, import_react.useEffect)(() => {
    if (!t || !I || !B)
      return;
    const V = t.map((G) => new Vt(G));
    B.fitCoordinates(V);
  }, [JSON.stringify(t), B]), (0, import_react.useEffect)(() => {
    if (!I || B)
      return;
    const V = new nh().withControlEnabled(h).withDefaultCenter(F).withDefaultZoom(te).withPadding(S).withPanHandler(de).withPanStartHandler(x).withProvider(k).withProviderOptions(H).withSinglePinZoom(N).withWrapper(v.current).build();
    z(V), O && (O.current = V);
  }, [I]), (0, import_react.useEffect)(() => {
    I || B || !v.current || k.load(e, {
      ...H,
      ...f && { client: f }
    }).then(() => K(true));
  }, []), yt.jsx(
    "div",
    {
      className: Ql(
        {
          "is-loaded": I
        },
        o
      ),
      id: "map",
      ref: v,
      "data-testid": "map",
      children: B && yt.jsx(la.Provider, { value: { map: B, provider: k }, children: r })
    }
  );
};
ih.defaultProps = {
  controls: true,
  defaultCenter: { latitude: 39.83, longitude: -98.58 },
  defaultZoom: 4,
  padding: { bottom: 50, left: 50, right: 50, top: 50 },
  panHandler: () => null,
  panStartHandler: () => null,
  provider: th,
  providerOptions: {},
  singleZoom: 14
};
var kp = ({ count: e }) => yt.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    viewBox: "0 0 22 22",
    children: yt.jsxs("g", { fill: "none", fillRule: "evenodd", children: [
      yt.jsx(
        "circle",
        {
          fill: "red",
          fillRule: "nonzero",
          stroke: "white",
          cx: "11",
          cy: "11",
          r: "11"
        }
      ),
      yt.jsx(
        "text",
        {
          fill: "white",
          fontFamily: "Arial-BoldMT,Arial",
          fontSize: "12",
          fontWeight: "bold",
          children: yt.jsx("tspan", { x: "50%", y: "15", textAnchor: "middle", children: e })
        }
      )
    ] })
  }
);
var Ic = (0, import_react.createContext)(
  null
);
function qC() {
  const e = (0, import_react.useContext)(Ic);
  if (!e)
    throw new Error(
      "Attempted to call useClustererContext() outside of <Clusterer>."
    );
  return e;
}
var VC = ({
  clusterRadius: e = 50,
  children: t,
  ClusterTemplate: r = kp
}) => {
  const { map: o } = (0, import_react.useContext)(la), [f, h] = (0, import_react.useState)([]), [C, T] = (0, import_react.useState)(), [O, S] = (0, import_react.useState)([]), [x, D] = (0, import_react.useState)([]);
  return (0, import_react.useEffect)(() => {
    T($p(f, o.getZoom(), e));
  }, [f, o.getZoom()]), (0, import_react.useEffect)(() => {
    D(() => []), S(() => []), (C == null ? void 0 : C.length) !== 0 && (C == null || C.forEach((k) => {
      if (k.length === 1) {
        k[0].pin.setMap(o);
        return;
      }
      if (k.length > 1) {
        const H = Po.fit(
          k.map((v) => v.pin.getCoordinate())
        ).getCenter(Ir.MERCATOR), N = `cluster-{${H._lat},${H._lon}}`;
        k.forEach((v) => v.pin.setMap(null)), S((v) => [...v, N]), D((v) => [
          ...v,
          yt.jsx(
            kc,
            {
              coordinate: H,
              id: N,
              onClick: () => o.fitCoordinates(
                k.map((F) => F.pin.getCoordinate()),
                true,
                1 / 0
              ),
              children: yt.jsx(r, { count: k.length })
            },
            N
          )
        ]);
      }
    }));
  }, [C]), yt.jsx(
    Ic.Provider,
    {
      value: {
        clusters: C ?? [],
        clusterIds: O,
        setPinStore: h
      },
      children: yt.jsxs(yt.Fragment, { children: [
        x.map((k, H) => yt.jsx(import_react.Fragment, { children: k }, H)),
        t
      ] })
    }
  );
};
var $p = (e, t, r) => {
  const o = r * Math.PI / 2 ** (t + 7), f = e.map((T, O) => [O]), h = [];
  e.forEach((T, O) => {
    for (let S = O; S < e.length; S++)
      S !== O && new Vt(T.pin.getCoordinate()).distanceTo(
        new Vt(e[S].pin.getCoordinate()),
        nn.RADIAN,
        Ir.MERCATOR
      ) <= o && (f[O].push(S), f[S].push(O));
  });
  let C = 1;
  for (; C; ) {
    C = 0;
    let T;
    if (f.forEach((x, D) => {
      x.length > C && (C = x.length, T = D);
    }), !C)
      break;
    const O = f[T ?? 0], S = [];
    f[T ?? 0] = [];
    for (const x of O) {
      const D = f[x];
      S.push(e[x]), f[x] = [], D.forEach(
        (k) => f[k].splice(
          f[k].indexOf(x),
          1
        )
      );
    }
    h.push(S);
  }
  return h;
};
var Fp = yt.jsx(
  "svg",
  {
    width: "30",
    height: "38",
    viewBox: "0 0 30 38",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: yt.jsx(
      "path",
      {
        d: "M30 15.0882C30 23.4212 23.3333 30.7353 15 38C7.22222 31.2941 0 23.4212 0 15.0882C0 6.75523 6.71573 0 15 0C23.2843 0 30 6.75523 30 15.0882Z",
        fill: "red"
      }
    )
  }
);
var kc = ({
  children: e,
  coordinate: t,
  hideOffscreen: r,
  id: o,
  icon: f,
  onClick: h,
  onFocus: C,
  onHover: T,
  zIndex: O
}) => {
  const { map: S, provider: x } = (0, import_react.useContext)(la), D = (0, import_react.useContext)(Ic), k = (0, import_react.useMemo)(() => new Pc().withCoordinate(t).withHideOffscreen(r).withProvider(x).build(), []);
  (0, import_react.useEffect)(() => {
    if (O !== 0 && !O)
      return;
    const N = k.getProviderPin().getWrapperElement();
    N && (N.style.zIndex = O.toString());
  }, [O]), (0, import_react.useEffect)(() => {
    k.setMap(S), k.setClickHandler(() => h(o)), k.setFocusHandler((v) => C(v, o)), k.setHoverHandler((v) => T(v, o));
    const N = D == null ? void 0 : D.clusterIds.includes(o);
    return D && !N && D.setPinStore((v) => [
      ...v,
      {
        pin: k,
        id: o
      }
    ]), () => {
      k.setMap(null), D && D.setPinStore(
        (v) => v.filter((F) => F.id !== o)
      );
    };
  }, []);
  const H = e || f;
  if (H) {
    const N = k.getProviderPin().getPinElement();
    return Object.assign(N.style, {
      height: "auto",
      width: "auto"
    }), (0, import_react_dom.createPortal)(H, N);
  }
  return null;
};
kc.defaultProps = {
  hideOffscreen: false,
  icon: Fp,
  onClick: () => null,
  onHover: () => null,
  onFocus: () => null
};
var Bp = ({
  children: e,
  coordinate: t,
  linkSameTab: r,
  pinUrl: o,
  onClick: f = () => null,
  onHover: h = () => null,
  onFocus: C = () => null,
  ...T
}) => yt.jsx(ih, { bounds: [t], ...T, children: yt.jsx(
  kc,
  {
    coordinate: t,
    id: "location-map-marker",
    onClick: f,
    onHover: h,
    onFocus: C,
    children: o ? yt.jsx(xp, { href: o, target: r ? "_self" : "_blank", children: e }) : e || void 0
  }
) });
Bp.defaultProps = {
  controls: true,
  panHandler: () => null,
  provider: th,
  singleZoom: 16
};
var el = {};
var ku;
function Hp() {
  if (ku)
    return el;
  ku = 1;
  var e = import_react.default;
  const t = e.createContext(null);
  function r(f, h) {
    let C = null;
    f != null && (C = f[1]);
    function T() {
      return h ?? (C != null ? C.getTheme() : null);
    }
    return {
      getTheme: T
    };
  }
  function o() {
    const f = e.useContext(t);
    if (f == null)
      throw Error("LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext");
    return f;
  }
  return el.LexicalComposerContext = t, el.createLexicalComposerContext = r, el.useLexicalComposerContext = o, el;
}
var ka;
var $u;
function kn() {
  return $u || ($u = 1, ka = true ? Hp() : Kp()), ka;
}
var $e = {};
var Bu;
function Wp() {
  if (Bu)
    return $e;
  Bu = 1;
  function e(c) {
    return {
      type: c
    };
  }
  const t = e("SELECTION_CHANGE_COMMAND"), r = e("CLICK_COMMAND"), o = e("DELETE_CHARACTER_COMMAND"), f = e("INSERT_LINE_BREAK_COMMAND"), h = e("INSERT_PARAGRAPH_COMMAND"), C = e("CONTROLLED_TEXT_INSERTION_COMMAND"), T = e("PASTE_COMMAND"), O = e("REMOVE_TEXT_COMMAND"), S = e("DELETE_WORD_COMMAND"), x = e("DELETE_LINE_COMMAND"), D = e("FORMAT_TEXT_COMMAND"), k = e("UNDO_COMMAND"), H = e("REDO_COMMAND"), N = e("KEYDOWN_COMMAND"), v = e("KEY_ARROW_RIGHT_COMMAND"), F = e("MOVE_TO_END"), U = e("KEY_ARROW_LEFT_COMMAND"), I = e("MOVE_TO_START"), K = e("KEY_ARROW_UP_COMMAND"), B = e("KEY_ARROW_DOWN_COMMAND"), z = e("KEY_ENTER_COMMAND"), te = e("KEY_SPACE_COMMAND"), re = e("KEY_BACKSPACE_COMMAND"), de = e("KEY_ESCAPE_COMMAND"), V = e("KEY_DELETE_COMMAND"), G = e("KEY_TAB_COMMAND"), q = e("INSERT_TAB_COMMAND"), me = e("INDENT_CONTENT_COMMAND"), pe = e("OUTDENT_CONTENT_COMMAND"), Z = e("DROP_COMMAND"), ee = e("FORMAT_ELEMENT_COMMAND"), P = e("DRAGSTART_COMMAND"), w = e("DRAGOVER_COMMAND"), j = e("DRAGEND_COMMAND"), ne = e("COPY_COMMAND"), Y = e("CUT_COMMAND"), W = e("SELECT_ALL_COMMAND"), Q = e("CLEAR_EDITOR_COMMAND"), b = e("CLEAR_HISTORY_COMMAND"), g = e("CAN_REDO_COMMAND"), _ = e("CAN_UNDO_COMMAND"), A = e("FOCUS_COMMAND"), J = e("BLUR_COMMAND"), ce = e("KEY_MODIFIER_COMMAND"), ge = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ae = ge && "documentMode" in document ? document.documentMode : null, Te = ge && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Me = ge && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ze = ge && "InputEvent" in window && !ae ? "getTargetRanges" in new window.InputEvent("input") : false, oe = ge && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), ie = ge && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, ue = ge && /Android/.test(navigator.userAgent), we = ge && /^(?=.*Chrome).*/i.test(navigator.userAgent), Le = ge && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !we, Be = 1, Ye = 3, st = 0, pt = 1, at = 2, ve = 0, se = 1, he = 2, Oe = 1, be = 2, Re = 4, He = 8, Ve = 16, Qe = 32, ct = 64, At = 128, je = Oe | be | Re | He | Ve | Qe | ct | At, qe = 1, nt = 2, gt = 1, Ct = 2, xt = 3, St = 4, wt = 5, Et = 6, Yt = " ", Kt = oe || ie || Le ? Yt : "​", bt = `

`, nr = Me ? Yt : Kt, gr = "֑-߿יִ-﷽ﹰ-ﻼ", Ci = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", Ho = new RegExp("^[^" + Ci + "]*[" + gr + "]"), Uo = new RegExp("^[^" + gr + "]*[" + Ci + "]"), on = {
    bold: Oe,
    code: Ve,
    highlight: At,
    italic: be,
    strikethrough: Re,
    subscript: Qe,
    superscript: ct,
    underline: He
  }, rr = {
    directionless: qe,
    unmergeable: nt
  }, Fr = {
    center: Ct,
    end: Et,
    justify: St,
    left: gt,
    right: xt,
    start: wt
  }, Wo = {
    [Ct]: "center",
    [Et]: "end",
    [St]: "justify",
    [gt]: "left",
    [xt]: "right",
    [wt]: "start"
  }, ye = {
    normal: ve,
    segmented: he,
    token: se
  }, Ge = {
    [ve]: "normal",
    [he]: "segmented",
    [se]: "token"
  }, et = 100;
  let _t = false, It = 0;
  function Ft() {
    return _t;
  }
  function Lt(c) {
    It = c.timeStamp;
  }
  function Mt(c) {
    It === 0 && Ti(c).addEventListener("textInput", Lt, true);
  }
  function cn(c, i, a) {
    return (
      // @ts-expect-error: internal field
      i.__lexicalLineBreak === c || // @ts-ignore We intentionally add this to the Node.
      c[`__lexicalKey_${a._key}`] !== void 0
    );
  }
  function Zt(c) {
    return c.getEditorState().read(() => {
      const i = en();
      return i !== null ? i.clone() : null;
    });
  }
  function jt(c, i, a) {
    const u = sr(a._window);
    let p = null, y = null;
    u !== null && u.anchorNode === c && (p = u.anchorOffset, y = u.focusOffset);
    const M = c.nodeValue;
    M !== null && fo(i, M, p, y, false);
  }
  function Rn(c, i, a) {
    if (ft(c)) {
      const u = c.anchor.getNode();
      if (u.is(a) && c.format !== u.getFormat())
        return false;
    }
    return i.nodeType === Ye && a.isAttached();
  }
  function ir(c, i, a) {
    _t = true;
    const u = performance.now() - It > et;
    try {
      Nr(c, () => {
        const p = en() || Zt(c), y = /* @__PURE__ */ new Map(), M = c.getRootElement(), $ = c._editorState, le = c._blockCursorElement;
        let fe = false, Ce = "";
        for (let xe = 0; xe < i.length; xe++) {
          const Ne = i[xe], Ke = Ne.type, Ie = Ne.target;
          let Ae = or(Ie, $);
          if (!(Ae === null && Ie !== M || yn(Ae))) {
            if (Ke === "characterData")
              u && dt(Ae) && Rn(p, Ie, Ae) && jt(
                // nodeType === DOM_TEXT_TYPE is a Text DOM node
                Ie,
                Ae,
                c
              );
            else if (Ke === "childList") {
              fe = true;
              const ht = Ne.addedNodes;
              for (let Pt = 0; Pt < ht.length; Pt++) {
                const Rt = ht[Pt], mt = ti(Rt), Tt = Rt.parentNode;
                if (Tt != null && Rt !== le && mt === null && (Rt.nodeName !== "BR" || !cn(Rt, Tt, c))) {
                  if (Me) {
                    const $t = Rt.innerText || Rt.nodeValue;
                    $t && (Ce += $t);
                  }
                  Tt.removeChild(Rt);
                }
              }
              const We = Ne.removedNodes, tt = We.length;
              if (tt > 0) {
                let Pt = 0;
                for (let Rt = 0; Rt < tt; Rt++) {
                  const mt = We[Rt];
                  (mt.nodeName === "BR" && cn(mt, Ie, c) || le === mt) && (Ie.appendChild(mt), Pt++);
                }
                tt !== Pt && (Ie === M && (Ae = ni($)), y.set(Ie, Ae));
              }
            }
          }
        }
        if (y.size > 0)
          for (const [xe, Ne] of y)
            if (Ze(Ne)) {
              const Ke = Ne.getChildrenKeys();
              let Ie = xe.firstChild;
              for (let Ae = 0; Ae < Ke.length; Ae++) {
                const ht = Ke[Ae], We = c.getElementByKey(ht);
                We !== null && (Ie == null ? (xe.appendChild(We), Ie = We) : Ie !== We && xe.replaceChild(We, Ie), Ie = Ie.nextSibling);
              }
            } else
              dt(Ne) && Ne.markDirty();
        const Ee = a.takeRecords();
        if (Ee.length > 0) {
          for (let xe = 0; xe < Ee.length; xe++) {
            const Ne = Ee[xe], Ke = Ne.addedNodes, Ie = Ne.target;
            for (let Ae = 0; Ae < Ke.length; Ae++) {
              const ht = Ke[Ae], We = ht.parentNode;
              We != null && ht.nodeName === "BR" && !cn(ht, Ie, c) && We.removeChild(ht);
            }
          }
          a.takeRecords();
        }
        p !== null && (fe && (p.dirty = true, _r(p)), Me && vl(c) && p.insertRawText(Ce));
      });
    } finally {
      _t = false;
    }
  }
  function Xr(c) {
    const i = c._observer;
    if (i !== null) {
      const a = i.takeRecords();
      ir(c, a, i);
    }
  }
  function Kn(c) {
    Mt(c), c._observer = new MutationObserver((i, a) => {
      ir(c, i, a);
    });
  }
  function xs(c, i) {
    const a = c.__mode, u = c.__format, p = c.__style, y = i.__mode, M = i.__format, $ = i.__style;
    return (a === null || a === y) && (u === null || u === M) && (p === null || p === $);
  }
  function Br(c, i) {
    const a = c.mergeWithSibling(i), u = ln()._normalizedNodes;
    return u.add(c.__key), u.add(i.__key), a;
  }
  function vs(c) {
    let i = c;
    if (i.__text === "" && i.isSimpleText() && !i.isUnmergeable()) {
      i.remove();
      return;
    }
    let a;
    for (; (a = i.getPreviousSibling()) !== null && dt(a) && a.isSimpleText() && !a.isUnmergeable(); )
      if (a.__text === "")
        a.remove();
      else if (xs(a, i)) {
        i = Br(a, i);
        break;
      } else
        break;
    let u;
    for (; (u = i.getNextSibling()) !== null && dt(u) && u.isSimpleText() && !u.isUnmergeable(); )
      if (u.__text === "")
        u.remove();
      else if (xs(i, u)) {
        i = Br(i, u);
        break;
      } else
        break;
  }
  function Ni(c) {
    return zo(c.anchor), zo(c.focus), c;
  }
  function zo(c) {
    for (; c.type === "element"; ) {
      const i = c.getNode(), a = c.offset;
      let u, p;
      if (a === i.getChildrenSize() ? (u = i.getChildAtIndex(a - 1), p = true) : (u = i.getChildAtIndex(a), p = false), dt(u)) {
        c.set(u.__key, p ? u.getTextContentSize() : 0, "text");
        break;
      } else if (!Ze(u))
        break;
      c.set(u.__key, p ? u.getChildrenSize() : 0, "element");
    }
  }
  let Ss = 1;
  function ws() {
    return "" + Ss++;
  }
  function xr(c, i) {
    const a = c._nodes.get(i);
    if (a === void 0)
      throw Error(`registeredNode: Type ${i} not found`);
    return a;
  }
  const Go = typeof queueMicrotask == "function" ? queueMicrotask : (c) => {
    Promise.resolve().then(c);
  };
  function ua(c) {
    return yn(or(c));
  }
  function Bi(c) {
    const i = document.activeElement;
    if (i === null)
      return false;
    const a = i.nodeName;
    return yn(or(c)) && (a === "INPUT" || a === "TEXTAREA" || i.contentEditable === "true" && // @ts-ignore iternal field
    i.__lexicalEditor == null);
  }
  function Kr(c, i, a) {
    const u = c.getRootElement();
    try {
      return u !== null && u.contains(i) && u.contains(a) && // Ignore if selection is within nested editor
      i !== null && !Bi(i) && ao(i) === c;
    } catch {
      return false;
    }
  }
  function ao(c) {
    let i = c;
    for (; i != null; ) {
      const a = i.__lexicalEditor;
      if (a != null)
        return a;
      i = Qo(i);
    }
    return null;
  }
  function cl(c) {
    return Ho.test(c) ? "rtl" : Uo.test(c) ? "ltr" : null;
  }
  function Os(c) {
    return c.isToken() || c.isSegmented();
  }
  function Cn(c) {
    return c.nodeType === Ye;
  }
  function Sn(c) {
    let i = c;
    for (; i != null; ) {
      if (Cn(i))
        return i;
      i = i.firstChild;
    }
    return null;
  }
  function pr(c, i, a) {
    const u = on[i];
    if (a !== null && (c & u) === (a & u))
      return c;
    let p = c ^ u;
    return i === "subscript" ? p &= ~on.superscript : i === "superscript" && (p &= ~on.subscript), p;
  }
  function Qr(c) {
    return dt(c) || ui(c) || yn(c);
  }
  function Dn(c, i) {
    if (i != null) {
      c.__key = i;
      return;
    }
    jn(), lu();
    const a = ln(), u = gi(), p = ws();
    u._nodeMap.set(p, c), Ze(c) ? a._dirtyElements.set(p, true) : a._dirtyLeaves.add(p), a._cloneNotNeeded.add(p), a._dirtyType = pt, c.__key = p;
  }
  function co(c, i, a) {
    let u = c;
    for (; u !== null; ) {
      if (a.has(u))
        return;
      const p = i.get(u);
      if (p === void 0)
        break;
      a.set(u, false), u = p.__parent;
    }
  }
  function ei(c) {
    const i = c.getParent();
    if (i !== null) {
      const a = c.getWritable(), u = i.getWritable(), p = c.getPreviousSibling(), y = c.getNextSibling();
      if (p === null)
        if (y !== null) {
          const M = y.getWritable();
          u.__first = y.__key, M.__prev = null;
        } else
          u.__first = null;
      else {
        const M = p.getWritable();
        if (y !== null) {
          const $ = y.getWritable();
          $.__prev = M.__key, M.__next = $.__key;
        } else
          M.__next = null;
        a.__prev = null;
      }
      if (y === null)
        if (p !== null) {
          const M = p.getWritable();
          u.__last = p.__key, M.__next = null;
        } else
          u.__last = null;
      else {
        const M = y.getWritable();
        if (p !== null) {
          const $ = p.getWritable();
          $.__next = M.__key, M.__prev = $.__key;
        } else
          M.__prev = null;
        a.__next = null;
      }
      u.__size--, a.__parent = null;
    }
  }
  function Ki(c) {
    lu();
    const i = c.getLatest(), a = i.__parent, u = gi(), p = ln(), y = u._nodeMap, M = p._dirtyElements;
    a !== null && co(a, y, M);
    const $ = i.__key;
    p._dirtyType = pt, Ze(c) ? M.set($, true) : p._dirtyLeaves.add($);
  }
  function Yo(c) {
    const i = c.getPreviousSibling(), a = c.getNextSibling();
    i !== null && Ki(i), a !== null && Ki(a);
  }
  function un(c) {
    jn();
    const i = ln(), a = i._compositionKey;
    if (c !== a) {
      if (i._compositionKey = c, a !== null) {
        const u = gn(a);
        u !== null && u.getWritable();
      }
      if (c !== null) {
        const u = gn(c);
        u !== null && u.getWritable();
      }
    }
  }
  function vr() {
    return hs() ? null : ln()._compositionKey;
  }
  function gn(c, i) {
    const u = (i || gi())._nodeMap.get(c);
    return u === void 0 ? null : u;
  }
  function ti(c, i) {
    const a = ln(), u = c[`__lexicalKey_${a._key}`];
    return u !== void 0 ? gn(u, i) : null;
  }
  function or(c, i) {
    let a = c;
    for (; a != null; ) {
      const u = ti(a, i);
      if (u !== null)
        return u;
      a = Qo(a);
    }
    return null;
  }
  function jo(c) {
    const i = c._decorators, a = Object.assign({}, i);
    return c._pendingDecorators = a, a;
  }
  function Hi(c) {
    return c.read(() => Hn().getTextContent());
  }
  function qo(c, i) {
    Nr(c, () => {
      const a = gi();
      if (a.isEmpty())
        return;
      if (i === "root") {
        Hn().markDirty();
        return;
      }
      const u = a._nodeMap;
      for (const [, p] of u)
        p.markDirty();
    }, c._pendingEditorState === null ? {
      tag: "history-merge"
    } : void 0);
  }
  function Hn() {
    return ni(gi());
  }
  function ni(c) {
    return c._nodeMap.get("root");
  }
  function _r(c) {
    jn();
    const i = gi();
    if (c !== null) {
      if (Object.isFrozen(c))
        throw Error("$setSelection called on frozen selection object. Ensure selection is cloned before passing in.");
      c.dirty = true, c.setCachedNodes(null);
    }
    i._selection = c;
  }
  function ul() {
    jn();
    const c = ln();
    Xr(c);
  }
  function Hr(c) {
    const i = ln(), a = dl(c, i);
    if (a === null) {
      const u = i.getRootElement();
      return c === u ? gn("root") : null;
    }
    return gn(a);
  }
  function Vo(c, i) {
    return i ? c.getTextContentSize() : 0;
  }
  function dl(c, i) {
    let a = c;
    for (; a != null; ) {
      const u = a[`__lexicalKey_${i._key}`];
      if (u !== void 0)
        return u;
      a = Qo(a);
    }
    return null;
  }
  function Rs(c) {
    return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(c);
  }
  function Jo(c) {
    const i = [];
    let a = c;
    for (; a !== null; )
      i.push(a), a = a._parentEditor;
    return i;
  }
  function uo() {
    return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
  }
  function Ui(c) {
    return c.nodeType === Ye ? c.nodeValue : null;
  }
  function Zo(c, i, a) {
    const u = sr(i._window);
    if (u === null)
      return;
    const p = u.anchorNode;
    let {
      anchorOffset: y,
      focusOffset: M
    } = u;
    if (p !== null) {
      let $ = Ui(p);
      const le = or(p);
      if ($ !== null && dt(le)) {
        if ($ === Kt && a) {
          const fe = a.length;
          $ = a, y = fe, M = fe;
        }
        $ !== null && fo(le, $, y, M, c);
      }
    }
  }
  function fo(c, i, a, u, p) {
    let y = c;
    if (y.isAttached() && (p || !y.isDirty())) {
      const M = y.isComposing();
      let $ = i;
      (M || p) && i[i.length - 1] === Kt && ($ = i.slice(0, -1));
      const le = y.getTextContent();
      if (p || $ !== le) {
        if ($ === "") {
          if (un(null), !oe && !ie && !Le) {
            const Ie = ln();
            setTimeout(() => {
              Ie.update(() => {
                y.isAttached() && y.remove();
              });
            }, 20);
          } else
            y.remove();
          return;
        }
        const fe = y.getParent(), Ce = fs(), Ee = y.getTextContentSize(), xe = vr(), Ne = y.getKey();
        if (y.isToken() || xe !== null && Ne === xe && !M || // Check if character was added at the start or boundaries when not insertable, and we need
        // to clear this input from occurring as that action wasn't permitted.
        ft(Ce) && (fe !== null && !fe.canInsertTextBefore() && Ce.anchor.offset === 0 || Ce.anchor.key === c.__key && Ce.anchor.offset === 0 && !y.canInsertTextBefore() || Ce.focus.key === c.__key && Ce.focus.offset === Ee && !y.canInsertTextAfter())) {
          y.markDirty();
          return;
        }
        const Ke = en();
        if (!ft(Ke) || a === null || u === null) {
          y.setTextContent($);
          return;
        }
        if (Ke.setTextNodeRange(y, a, y, u), y.isSegmented()) {
          const Ie = y.getTextContent(), Ae = Mn(Ie);
          y.replace(Ae), y = Ae;
        }
        y.setTextContent($);
      }
    }
  }
  function Ds(c) {
    const i = c.getPreviousSibling();
    return (dt(i) || Ze(i) && i.isInline()) && !i.canInsertTextAfter();
  }
  function Ur(c, i) {
    if (i.isSegmented())
      return true;
    if (!c.isCollapsed())
      return false;
    const a = c.anchor.offset, u = i.getParentOrThrow(), p = i.isToken();
    return a === 0 ? !i.canInsertTextBefore() || !u.canInsertTextBefore() || p || Ds(i) : a === i.getTextContentSize() ? !i.canInsertTextAfter() || !u.canInsertTextAfter() || p : false;
  }
  function As(c, i, a, u) {
    return c === 9 && !i && !a && !u;
  }
  function ho(c, i, a, u) {
    return c === 66 && !i && Wr(a, u);
  }
  function fl(c, i, a, u) {
    return c === 73 && !i && Wr(a, u);
  }
  function hl(c, i, a, u) {
    return c === 85 && !i && Wr(a, u);
  }
  function Wi(c, i) {
    return xl(c) && !i;
  }
  function go(c, i) {
    return xl(c) && i;
  }
  function bs(c, i) {
    return Te && i && c === 79;
  }
  function Ms(c, i, a) {
    return Sr(c) && (Te ? i : a);
  }
  function po(c, i, a) {
    return wr(c) && (Te ? i : a);
  }
  function _o(c, i) {
    return Te && i && Sr(c);
  }
  function gl(c, i) {
    return Te && i && wr(c);
  }
  function pl(c, i, a, u) {
    return Te ? i || a ? false : Sr(c) || c === 72 && u : u || i || a ? false : Sr(c);
  }
  function _l(c, i, a, u, p) {
    return Te ? a || u || p ? false : wr(c) || c === 68 && i : i || u || p ? false : wr(c);
  }
  function ml(c, i, a, u) {
    return c === 90 && !i && Wr(a, u);
  }
  function da(c, i, a, u) {
    return Te ? c === 90 && a && i : c === 89 && u || c === 90 && u && i;
  }
  function fa(c, i, a, u) {
    return i ? false : c === 67 ? Te ? a : u : false;
  }
  function yl(c, i, a, u) {
    return i ? false : c === 88 ? Te ? a : u : false;
  }
  function Cl(c) {
    return c === 37;
  }
  function Nl(c) {
    return c === 39;
  }
  function ha(c) {
    return c === 38;
  }
  function ga(c) {
    return c === 40;
  }
  function Ls(c, i, a, u) {
    return Cl(c) && !i && !u && !a;
  }
  function pa(c, i, a, u, p) {
    return Cl(c) && !u && !a && (i || p);
  }
  function _a(c, i, a, u) {
    return Nl(c) && !i && !u && !a;
  }
  function El(c, i, a, u, p) {
    return Nl(c) && !u && !a && (i || p);
  }
  function zi(c, i, a) {
    return ha(c) && !i && !a;
  }
  function Tl(c, i, a) {
    return ga(c) && !i && !a;
  }
  function ma(c, i, a, u) {
    return c || i || a || u;
  }
  function Ps(c) {
    return c === 32;
  }
  function Wr(c, i) {
    return Te ? c : i;
  }
  function xl(c) {
    return c === 13;
  }
  function Sr(c) {
    return c === 8;
  }
  function ya(c) {
    return c === 27;
  }
  function wr(c) {
    return c === 46;
  }
  function ri(c, i, a) {
    return c === 65 && Wr(i, a);
  }
  function Is() {
    const c = Hn(), i = c.select(0, c.getChildrenSize());
    _r(Ni(i));
  }
  function Ei(c, i) {
    c.__lexicalClassNameCache === void 0 && (c.__lexicalClassNameCache = {});
    const a = c.__lexicalClassNameCache, u = a[i];
    if (u !== void 0)
      return u;
    const p = c[i];
    if (typeof p == "string") {
      const y = p.split(" ");
      return a[i] = y, y;
    }
    return p;
  }
  function mo(c, i, a, u, p) {
    if (a.size === 0)
      return;
    const y = u.__type, M = u.__key, $ = i.get(y);
    if ($ === void 0)
      throw Error(`Type ${y} not in registeredNodes`);
    const le = $.klass;
    let fe = c.get(le);
    fe === void 0 && (fe = /* @__PURE__ */ new Map(), c.set(le, fe));
    const Ce = fe.get(M), Ee = Ce === "destroyed" && p === "created";
    (Ce === void 0 || Ee) && fe.set(M, Ee ? "updated" : p);
  }
  function ks(c) {
    const i = gi(), a = i._readOnly, u = c.getType(), p = i._nodeMap, y = [];
    for (const [, M] of p)
      M instanceof c && M.__type === u && (a || M.isAttached()) && y.push(M);
    return y;
  }
  function yo(c, i, a) {
    const u = c.getParent();
    let p = a, y = c;
    return u !== null && (i && a === 0 ? (p = y.getIndexWithinParent(), y = u) : !i && a === y.getChildrenSize() && (p = y.getIndexWithinParent() + 1, y = u)), y.getChildAtIndex(i ? p - 1 : p);
  }
  function zr(c, i) {
    const a = c.offset;
    if (c.type === "element") {
      const u = c.getNode();
      return yo(u, i, a);
    } else {
      const u = c.getNode();
      if (i && a === 0 || !i && a === u.getTextContentSize()) {
        const p = i ? u.getPreviousSibling() : u.getNextSibling();
        return p === null ? yo(u.getParentOrThrow(), i, u.getIndexWithinParent() + (i ? 0 : 1)) : p;
      }
    }
    return null;
  }
  function vl(c) {
    const i = Ti(c).event, a = i && i.inputType;
    return a === "insertFromPaste" || a === "insertFromPasteAsQuotation";
  }
  function it(c, i, a) {
    return fu(c, i, a);
  }
  function Co(c) {
    return !Er(c) && !c.isLastChild() && !c.isInline();
  }
  function Xo(c, i) {
    const a = c._keyToDOMMap.get(i);
    if (a === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${i}`);
    return a;
  }
  function Qo(c) {
    const i = c.assignedSlot || c.parentElement;
    return i !== null && i.nodeType === 11 ? i.host : i;
  }
  function Sl(c, i, a) {
    const u = a.ownerDocument, p = u.defaultView;
    if (p === null)
      return;
    let {
      top: y,
      bottom: M
    } = i, $ = 0, le = 0, fe = a;
    for (; fe !== null; ) {
      const Ce = fe === u.body;
      if (Ce)
        $ = 0, le = Ti(c).innerHeight;
      else {
        const xe = fe.getBoundingClientRect();
        $ = xe.top, le = xe.bottom;
      }
      let Ee = 0;
      if (y < $ ? Ee = -($ - y) : M > le && (Ee = M - le), Ee !== 0)
        if (Ce)
          p.scrollBy(0, Ee);
        else {
          const xe = fe.scrollTop;
          fe.scrollTop += Ee;
          const Ne = fe.scrollTop - xe;
          y -= Ne, M -= Ne;
        }
      if (Ce)
        break;
      fe = Qo(fe);
    }
  }
  function Ca(c) {
    return ln()._updateTags.has(c);
  }
  function ii(c) {
    jn(), ln()._updateTags.add(c);
  }
  function An(c) {
    const i = en();
    if (!ft(i) || !Ze(c))
      return i;
    const {
      anchor: a,
      focus: u
    } = i, p = a.getNode(), y = u.getNode();
    return ut(p, c) && a.set(c.__key, 0, "element"), ut(y, c) && u.set(c.__key, 0, "element"), i;
  }
  function ut(c, i) {
    let a = c.getParent();
    for (; a !== null; ) {
      if (a.is(i))
        return true;
      a = a.getParent();
    }
    return false;
  }
  function Gi(c) {
    const i = c.ownerDocument;
    return i && i.defaultView || null;
  }
  function Ti(c) {
    const i = c._window;
    if (i === null)
      throw Error("window object not found");
    return i;
  }
  function wl(c) {
    return Ze(c) && c.isInline() || yn(c) && c.isInline();
  }
  function mr(c) {
    let i = c.getParentOrThrow();
    for (; i !== null; ) {
      if (Or(i))
        return i;
      i = i.getParentOrThrow();
    }
    return i;
  }
  function Or(c) {
    return Er(c) || Ze(c) && c.isShadowRoot();
  }
  function $s(c) {
    const i = c.constructor.clone(c);
    return Dn(i, null), i;
  }
  function Yi(c) {
    const i = ln(), a = c.constructor.getType(), u = i._nodes.get(a);
    if (u === void 0)
      throw Error('$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.');
    const p = u.replace;
    if (p !== null) {
      const y = p(c);
      if (!(y instanceof c.constructor))
        throw Error("$initializeNode failed. Ensure replacement node is a subclass of the original node.");
      return y;
    }
    return c;
  }
  function Rr(c, i) {
    const a = c.getParent();
    if (Er(a) && !Ze(i) && !yn(i))
      throw Error("Only element or decorator nodes can be inserted in to the root node");
  }
  function Fs(c) {
    const i = c.theme, a = document.createElement("div");
    a.contentEditable = "false", a.setAttribute("data-lexical-cursor", "true");
    let u = i.blockCursor;
    if (u !== void 0) {
      if (typeof u == "string") {
        const p = u.split(" ");
        u = i.blockCursor = p;
      }
      u !== void 0 && a.classList.add(...u);
    }
    return a;
  }
  function ji(c) {
    return (yn(c) || Ze(c) && !c.canBeEmpty()) && !c.isInline();
  }
  function vt(c, i, a) {
    a.style.removeProperty("caret-color"), i._blockCursorElement = null;
    const u = c.parentElement;
    u !== null && u.removeChild(c);
  }
  function Bs(c, i, a) {
    let u = c._blockCursorElement;
    if (ft(a) && a.isCollapsed() && a.anchor.type === "element" && i.contains(document.activeElement)) {
      const p = a.anchor, y = p.getNode(), M = p.offset, $ = y.getChildrenSize();
      let le = false, fe = null;
      if (M === $) {
        const Ce = y.getChildAtIndex(M - 1);
        ji(Ce) && (le = true);
      } else {
        const Ce = y.getChildAtIndex(M);
        if (ji(Ce)) {
          const Ee = Ce.getPreviousSibling();
          (Ee === null || ji(Ee)) && (le = true, fe = c.getElementByKey(Ce.__key));
        }
      }
      if (le) {
        const Ce = c.getElementByKey(y.__key);
        u === null && (c._blockCursorElement = u = Fs(c._config)), i.style.caretColor = "transparent", fe === null ? Ce.appendChild(u) : Ce.insertBefore(u, fe);
        return;
      }
    }
    u !== null && vt(u, c, i);
  }
  function sr(c) {
    return ge ? (c || window).getSelection() : null;
  }
  function es(c, i) {
    let a = c.getChildAtIndex(i);
    if (a == null && (a = c), Or(c))
      throw Error("Can not call $splitNode() on root element");
    const u = (M) => {
      const $ = M.getParentOrThrow(), le = Or($), fe = M === a && !le ? M : $s(M);
      if (le)
        return M.insertAfter(fe), [M, fe, fe];
      {
        const [Ce, Ee, xe] = u($), Ne = M.getNextSiblings();
        return xe.append(fe, ...Ne), [Ce, Ee, fe];
      }
    }, [p, y] = u(a);
    return [p, y];
  }
  function No(c, i) {
    let a = c;
    for (; a !== Hn() && a != null; ) {
      if (i(a))
        return a;
      a = a.getParent();
    }
    return null;
  }
  function xi(c) {
    const i = [], a = [c];
    for (; a.length > 0; ) {
      const u = a.pop();
      if (u === void 0)
        throw Error("Stack.length > 0; can't be undefined");
      Ze(u) && a.unshift(...u.getChildren()), u !== c && i.push(u);
    }
    return i;
  }
  function Eo(c) {
    return To(c) && c.tagName === "A";
  }
  function To(c) {
    return c.nodeType === 1;
  }
  function vi(c) {
    if (yn(c) && !c.isInline())
      return true;
    if (!Ze(c) || Or(c))
      return false;
    const i = c.getFirstChild(), a = i === null || ui(i) || dt(i) || i.isInline();
    return !c.isInline() && c.canBeEmpty() !== false && a;
  }
  function ts(c, i) {
    let a = c;
    for (; a !== null && a.getParent() !== null && !i(a); )
      a = a.getParentOrThrow();
    return i(a) ? a : null;
  }
  function Ol(c, i) {
    const a = c._decorators;
    let p = c._pendingDecorators || a;
    const y = i._nodeMap;
    let M;
    for (M in p)
      y.has(M) || (p === a && (p = jo(c)), delete p[M]);
  }
  function Ks(c, i, a, u, p, y) {
    let M = c.getFirstChild();
    for (; M !== null; ) {
      const $ = M.__key;
      M.__parent === i && (Ze(M) && Ks(M, $, a, u, p, y), a.has($) || y.delete($), p.push($)), M = M.getNextSibling();
    }
  }
  function Rl(c, i, a, u) {
    const p = c._nodeMap, y = i._nodeMap, M = [];
    for (const [$] of u) {
      const le = y.get($);
      le !== void 0 && (le.isAttached() || (Ze(le) && Ks(le, $, p, y, M, u), p.has($) || u.delete($), M.push($)));
    }
    for (const $ of M)
      y.delete($);
    for (const $ of a) {
      const le = y.get($);
      le !== void 0 && !le.isAttached() && (p.has($) || a.delete($), y.delete($));
    }
  }
  let pn = "", $n = "", yr = "", oi, bn, Wt, Si = false, qi = false, xo, ns = null, Vi, rs, si, Gr, vo, So;
  function dn(c, i) {
    const a = si.get(c);
    if (i !== null) {
      const u = Qt(c);
      u.parentNode === i && i.removeChild(u);
    }
    if (Gr.has(c) || bn._keyToDOMMap.delete(c), Ze(a)) {
      const u = Zi(a, si);
      _n(u, 0, u.length - 1, null);
    }
    a !== void 0 && mo(So, Wt, xo, a, "destroyed");
  }
  function _n(c, i, a, u) {
    let p = i;
    for (; p <= a; ++p) {
      const y = c[p];
      y !== void 0 && dn(y, u);
    }
  }
  function mn(c, i) {
    c.setProperty("text-align", i);
  }
  const Hs = "40px";
  function Ji(c, i) {
    const a = oi.theme.indent;
    if (typeof a == "string") {
      const p = c.classList.contains(a);
      i > 0 && !p ? c.classList.add(a) : i < 1 && p && c.classList.remove(a);
    }
    const u = getComputedStyle(c).getPropertyValue("--lexical-indent-base-value") || Hs;
    c.style.setProperty("padding-inline-start", i === 0 ? "" : `calc(${i} * ${u})`);
  }
  function Us(c, i) {
    const a = c.style;
    i === 0 ? mn(a, "") : i === gt ? mn(a, "left") : i === Ct ? mn(a, "center") : i === xt ? mn(a, "right") : i === St ? mn(a, "justify") : i === wt ? mn(a, "start") : i === Et && mn(a, "end");
  }
  function Yr(c, i, a) {
    const u = Gr.get(c);
    if (u === void 0)
      throw Error("createNode: node does not exist in nodeMap");
    const p = u.createDOM(oi, bn);
    if (Ml(c, p, bn), dt(u) ? p.setAttribute("data-lexical-text", "true") : yn(u) && p.setAttribute("data-lexical-decorator", "true"), Ze(u)) {
      const y = u.__indent, M = u.__size;
      if (y !== 0 && Ji(p, y), M !== 0) {
        const le = M - 1, fe = Zi(u, Gr);
        Un(fe, le, u, p);
      }
      const $ = u.__format;
      $ !== 0 && Us(p, $), u.isInline() || Ws(null, u, p), Co(u) && (pn += bt, yr += bt);
    } else {
      const y = u.getTextContent();
      if (yn(u)) {
        const M = u.decorate(bn, oi);
        M !== null && Xi(c, M), p.contentEditable = "false";
      } else
        dt(u) && (u.isDirectionless() || ($n += y));
      pn += y, yr += y;
    }
    if (i !== null)
      if (a != null)
        i.insertBefore(p, a);
      else {
        const y = i.__lexicalLineBreak;
        y != null ? i.insertBefore(p, y) : i.appendChild(p);
      }
    return Object.freeze(u), mo(So, Wt, xo, u, "created"), p;
  }
  function Un(c, i, a, u) {
    const p = $n;
    $n = "", lr(c, a, 0, i, u, null), Dl(a, u), $n = p;
  }
  function lr(c, i, a, u, p, y) {
    const M = pn;
    pn = "";
    let $ = a;
    for (; $ <= u; ++$)
      Yr(c[$], p, y);
    Co(i) && (pn += bt), p.__lexicalTextContent = pn, pn = M + pn;
  }
  function Xt(c, i) {
    const a = i.get(c);
    return ui(a) || yn(a) && a.isInline();
  }
  function Ws(c, i, a) {
    const u = c !== null && (c.__size === 0 || Xt(c.__last, si)), p = i.__size === 0 || Xt(i.__last, Gr);
    if (u) {
      if (!p) {
        const y = a.__lexicalLineBreak;
        y != null && a.removeChild(y), a.__lexicalLineBreak = null;
      }
    } else if (p) {
      const y = document.createElement("br");
      a.__lexicalLineBreak = y, a.appendChild(y);
    }
  }
  function Dl(c, i) {
    const a = (
      // @ts-expect-error: internal field
      i.__lexicalDirTextContent
    ), u = i.__lexicalDir;
    if (a !== $n || u !== ns) {
      const p = $n === "", y = p ? ns : cl($n);
      if (y !== u) {
        const M = i.classList, $ = oi.theme;
        let le = u !== null ? $[u] : void 0, fe = y !== null ? $[y] : void 0;
        if (le !== void 0) {
          if (typeof le == "string") {
            const Ce = le.split(" ");
            le = $[u] = Ce;
          }
          M.remove(...le);
        }
        if (y === null || p && y === "ltr")
          i.removeAttribute("dir");
        else {
          if (fe !== void 0) {
            if (typeof fe == "string") {
              const Ce = fe.split(" ");
              fe = $[y] = Ce;
            }
            fe !== void 0 && M.add(...fe);
          }
          i.dir = y;
        }
        if (!qi) {
          const Ce = c.getWritable();
          Ce.__dir = y;
        }
      }
      ns = y, i.__lexicalDirTextContent = $n, i.__lexicalDir = y;
    }
  }
  function Na(c, i, a) {
    const u = $n;
    $n = "", Al(c, i, a), Dl(i, a), $n = u;
  }
  function Zi(c, i) {
    const a = [];
    let u = c.__first;
    for (; u !== null; ) {
      const p = i.get(u);
      if (p === void 0)
        throw Error("createChildrenArray: node does not exist in nodeMap");
      a.push(u), u = p.__next;
    }
    return a;
  }
  function Al(c, i, a) {
    const u = pn, p = c.__size, y = i.__size;
    if (pn = "", p === 1 && y === 1) {
      const M = c.__first, $ = i.__first;
      if (M === $)
        Cr(M, a);
      else {
        const le = Qt(M), fe = Yr($, null, null);
        a.replaceChild(fe, le), dn(M, null);
      }
    } else {
      const M = Zi(c, si), $ = Zi(i, Gr);
      if (p === 0)
        y !== 0 && lr($, i, 0, y - 1, a, null);
      else if (y === 0) {
        if (p !== 0) {
          const fe = a.__lexicalLineBreak == null;
          _n(M, 0, p - 1, fe ? null : a), fe && (a.textContent = "");
        }
      } else
        bl(i, M, $, p, y, a);
    }
    Co(i) && (pn += bt), a.__lexicalTextContent = pn, pn = u + pn;
  }
  function Cr(c, i) {
    const a = si.get(c);
    let u = Gr.get(c);
    if (a === void 0 || u === void 0)
      throw Error("reconcileNode: prevNode or nextNode does not exist in nodeMap");
    const p = Si || rs.has(c) || Vi.has(c), y = Xo(bn, c);
    if (a === u && !p) {
      if (Ze(a)) {
        const M = y.__lexicalTextContent;
        M !== void 0 && (pn += M, yr += M);
        const $ = y.__lexicalDirTextContent;
        $ !== void 0 && ($n += $);
      } else {
        const M = a.getTextContent();
        dt(a) && !a.isDirectionless() && ($n += M), yr += M, pn += M;
      }
      return y;
    }
    if (a !== u && p && mo(So, Wt, xo, u, "updated"), u.updateDOM(a, y, oi)) {
      const M = Yr(c, null, null);
      if (i === null)
        throw Error("reconcileNode: parentDOM is null");
      return i.replaceChild(M, y), dn(c, null), M;
    }
    if (Ze(a) && Ze(u)) {
      const M = u.__indent;
      M !== a.__indent && Ji(y, M);
      const $ = u.__format;
      $ !== a.__format && Us(y, $), p && (Na(a, u, y), !Er(u) && !u.isInline() && Ws(a, u, y)), Co(u) && (pn += bt, yr += bt);
    } else {
      const M = u.getTextContent();
      if (yn(u)) {
        const $ = u.decorate(bn, oi);
        $ !== null && Xi(c, $);
      } else
        dt(u) && !u.isDirectionless() && ($n += M);
      pn += M, yr += M;
    }
    return !qi && Er(u) && u.__cachedText !== yr && (u = u.getWritable(), u.__cachedText = yr), Object.freeze(u), y;
  }
  function Xi(c, i) {
    let a = bn._pendingDecorators;
    const u = bn._decorators;
    if (a === null) {
      if (u[c] === i)
        return;
      a = jo(bn);
    }
    a[c] = i;
  }
  function rt(c) {
    return c.firstChild;
  }
  function is(c) {
    let i = c.nextSibling;
    return i !== null && i === bn._blockCursorElement && (i = i.nextSibling), i;
  }
  function bl(c, i, a, u, p, y) {
    const M = u - 1, $ = p - 1;
    let le, fe, Ce = rt(y), Ee = 0, xe = 0;
    for (; Ee <= M && xe <= $; ) {
      const Ie = i[Ee], Ae = a[xe];
      if (Ie === Ae)
        Ce = is(Cr(Ae, y)), Ee++, xe++;
      else {
        le === void 0 && (le = new Set(i)), fe === void 0 && (fe = new Set(a));
        const ht = fe.has(Ie), We = le.has(Ae);
        if (!ht)
          Ce = is(Qt(Ie)), dn(Ie, y), Ee++;
        else if (!We)
          Yr(Ae, y, Ce), xe++;
        else {
          const tt = Xo(bn, Ae);
          tt === Ce ? Ce = is(Cr(Ae, y)) : (Ce != null ? y.insertBefore(tt, Ce) : y.appendChild(tt), Cr(Ae, y)), Ee++, xe++;
        }
      }
    }
    const Ne = Ee > M, Ke = xe > $;
    if (Ne && !Ke) {
      const Ie = a[$ + 1], Ae = Ie === void 0 ? null : bn.getElementByKey(Ie);
      lr(a, c, xe, $, y, Ae);
    } else
      Ke && !Ne && _n(i, Ee, M, y);
  }
  function Jn(c, i, a, u, p, y) {
    pn = "", yr = "", $n = "", Si = u === at, ns = null, bn = a, oi = a._config, Wt = a._nodes, xo = bn._listeners.mutation, Vi = p, rs = y, si = c._nodeMap, Gr = i._nodeMap, qi = i._readOnly, vo = new Map(a._keyToDOMMap);
    const M = /* @__PURE__ */ new Map();
    return So = M, Cr("root", null), bn = void 0, Wt = void 0, Vi = void 0, rs = void 0, si = void 0, Gr = void 0, oi = void 0, vo = void 0, So = void 0, M;
  }
  function Ml(c, i, a) {
    const u = a._keyToDOMMap;
    i["__lexicalKey_" + a._key] = c, u.set(c, i);
  }
  function Qt(c) {
    const i = vo.get(c);
    if (i === void 0)
      throw Error(`Reconciliation: could not find DOM element for node key ${c}`);
    return i;
  }
  const Wn = Object.freeze({}), Je = 30, os = [["keydown", E], ["pointerdown", kl], ["compositionstart", s], ["compositionend", m], ["input", n], ["click", ar], ["cut", Wn], ["copy", Wn], ["dragstart", Wn], ["dragover", Wn], ["dragend", Wn], ["paste", Wn], ["focus", Wn], ["blur", Wn], ["drop", Wn]];
  ze && os.push(["beforeinput", (c, i) => l(c, i)]);
  let Dr = 0, Yn = 0, Ll = 0, li = null, Qi = 0, eo = false, ai = false, wo = false, Zn = false, zs = [0, "", 0, "root", 0];
  function Pl(c, i, a, u, p) {
    const y = c.anchor, M = c.focus, $ = y.getNode(), le = ln(), fe = sr(le._window), Ce = fe !== null ? fe.anchorNode : null, Ee = y.key, xe = le.getElementByKey(Ee), Ne = a.length;
    return Ee !== M.key || // If we're working with a non-text node.
    !dt($) || // If we are replacing a range with a single character or grapheme, and not composing.
    (!p && (!ze || // We check to see if there has been
    // a recent beforeinput event for "textInput". If there has been one in the last
    // 50ms then we proceed as normal. However, if there is not, then this is likely
    // a dangling `input` event caused by execCommand('insertText').
    Ll < u + 50) || $.isDirty() && Ne < 2 || Rs(a)) && y.offset !== M.offset && !$.isComposing() || // Any non standard text node.
    Os($) || // If the text length is more than a single character and we're either
    // dealing with this in "beforeinput" or where the node has already recently
    // been changed (thus is dirty).
    $.isDirty() && Ne > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
    (p || !ze) && xe !== null && !$.isComposing() && Ce !== Sn(xe) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
    // of the editor.
    fe !== null && i !== null && (!i.collapsed || i.startContainer !== fe.anchorNode || i.startOffset !== fe.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
    $.getFormat() !== c.format || $.getStyle() !== c.style || // One last set of heuristics to check against.
    Ur(c, $);
  }
  function Il(c, i) {
    return c !== null && c.nodeValue !== null && c.nodeType === Ye && i !== 0 && i !== c.nodeValue.length;
  }
  function ss(c, i, a) {
    const {
      anchorNode: u,
      anchorOffset: p,
      focusNode: y,
      focusOffset: M
    } = c;
    eo && (eo = false, Il(u, p) && Il(y, M)) || Nr(i, () => {
      if (!a) {
        _r(null);
        return;
      }
      if (!Kr(i, u, y))
        return;
      const $ = en();
      if (ft($)) {
        const le = $.anchor, fe = le.getNode();
        if ($.isCollapsed()) {
          c.type === "Range" && c.anchorNode === c.focusNode && ($.dirty = true);
          const Ce = Ti(i).event, Ee = Ce ? Ce.timeStamp : performance.now(), [xe, Ne, Ke, Ie, Ae] = zs, ht = Hn(), We = i.isComposing() === false && ht.getTextContent() === "";
          Ee < Ae + 200 && le.offset === Ke && le.key === Ie ? ($.format = xe, $.style = Ne) : le.type === "text" ? ($.format = fe.getFormat(), $.style = fe.getStyle()) : le.type === "element" && !We && ($.format = 0, $.style = "");
        } else {
          let Ce = je, Ee = false;
          const xe = $.getNodes(), Ne = xe.length;
          for (let Ke = 0; Ke < Ne; Ke++) {
            const Ie = xe[Ke];
            if (dt(Ie) && (Ee = true, Ce &= Ie.getFormat(), Ce === 0))
              break;
          }
          $.format = Ee ? Ce : 0;
        }
      }
      it(i, t, void 0);
    });
  }
  function ar(c, i) {
    Nr(i, () => {
      const a = en(), u = sr(i._window), p = fs();
      if (u) {
        if (ft(a)) {
          const y = a.anchor, M = y.getNode();
          if (y.type === "element" && y.offset === 0 && a.isCollapsed() && !Er(M) && Hn().getChildrenSize() === 1 && M.getTopLevelElementOrThrow().isEmpty() && p !== null && a.is(p))
            u.removeAllRanges(), a.dirty = true;
          else if (c.detail === 3 && !a.isCollapsed()) {
            const le = a.focus.getNode();
            M !== le && (Ze(M) ? M.select(0) : M.getParentOrThrow().select(0));
          }
        } else if (c.pointerType === "touch") {
          const y = u.anchorNode;
          if (y !== null) {
            const M = y.nodeType;
            if (M === Be || M === Ye) {
              const $ = Ta(p, u, i);
              _r($);
            }
          }
        }
      }
      it(i, r, c);
    });
  }
  function kl(c, i) {
    const a = c.target, u = c.pointerType;
    a instanceof Node && u !== "touch" && Nr(i, () => {
      ua(a) || (ai = true);
    });
  }
  function ls(c) {
    if (!c.getTargetRanges)
      return null;
    const i = c.getTargetRanges();
    return i.length === 0 ? null : i[0];
  }
  function $l(c, i) {
    return c !== i || Ze(c) || Ze(i) || !c.isToken() || !i.isToken();
  }
  function Oo(c) {
    return Yn === 229 && c < Dr + Je;
  }
  function l(c, i) {
    const a = c.inputType, u = ls(c);
    a === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
    // as the `paste` event should have triggered, unless the
    // user has dom.event.clipboardevents.enabled disabled in
    // about:config. In that case, we need to process the
    // pasted content in the DOM mutation phase.
    Me && vl(i) || a !== "insertCompositionText" && Nr(i, () => {
      const p = en();
      if (a === "deleteContentBackward") {
        if (p === null) {
          const Ce = fs();
          if (!ft(Ce))
            return;
          _r(Ce.clone());
        }
        if (ft(p)) {
          if (ue && un(p.anchor.key), Oo(c.timeStamp) && i.isComposing() && p.anchor.key === p.focus.key) {
            if (un(null), Dr = 0, setTimeout(() => {
              Nr(i, () => {
                un(null);
              });
            }, Je), ft(p)) {
              const Ee = p.anchor.getNode();
              Ee.markDirty(), p.format = Ee.getFormat(), p.style = Ee.getStyle();
            }
            p.anchor.getNode().getTextContent().length <= 1 && (c.preventDefault(), it(i, o, true));
          } else
            c.preventDefault(), it(i, o, true);
          return;
        }
      }
      if (!ft(p))
        return;
      const y = c.data;
      li !== null && Zo(false, i, li), (!p.dirty || li !== null) && p.isCollapsed() && !Er(p.anchor.getNode()) && u !== null && p.applyDOMRange(u), li = null;
      const M = p.anchor, $ = p.focus, le = M.getNode(), fe = $.getNode();
      if (a === "insertText" || a === "insertTranspose") {
        if (y === `
`)
          c.preventDefault(), it(i, f, false);
        else if (y === bt)
          c.preventDefault(), it(i, h, void 0);
        else if (y == null && c.dataTransfer) {
          const Ce = c.dataTransfer.getData("text/plain");
          c.preventDefault(), p.insertRawText(Ce);
        } else
          y != null && Pl(p, u, y, c.timeStamp, true) ? (c.preventDefault(), it(i, C, y)) : li = y;
        Ll = c.timeStamp;
        return;
      }
      switch (c.preventDefault(), a) {
        case "insertFromYank":
        case "insertFromDrop":
        case "insertReplacementText": {
          it(i, C, c);
          break;
        }
        case "insertFromComposition": {
          un(null), it(i, C, c);
          break;
        }
        case "insertLineBreak": {
          un(null), it(i, f, false);
          break;
        }
        case "insertParagraph": {
          un(null), wo && !ie ? (wo = false, it(i, f, false)) : it(i, h, void 0);
          break;
        }
        case "insertFromPaste":
        case "insertFromPasteAsQuotation": {
          it(i, T, c);
          break;
        }
        case "deleteByComposition": {
          $l(le, fe) && it(i, O, c);
          break;
        }
        case "deleteByDrag":
        case "deleteByCut": {
          it(i, O, c);
          break;
        }
        case "deleteContent": {
          it(i, o, false);
          break;
        }
        case "deleteWordBackward": {
          it(i, S, true);
          break;
        }
        case "deleteWordForward": {
          it(i, S, false);
          break;
        }
        case "deleteHardLineBackward":
        case "deleteSoftLineBackward": {
          it(i, x, true);
          break;
        }
        case "deleteContentForward":
        case "deleteHardLineForward":
        case "deleteSoftLineForward": {
          it(i, x, false);
          break;
        }
        case "formatStrikeThrough": {
          it(i, D, "strikethrough");
          break;
        }
        case "formatBold": {
          it(i, D, "bold");
          break;
        }
        case "formatItalic": {
          it(i, D, "italic");
          break;
        }
        case "formatUnderline": {
          it(i, D, "underline");
          break;
        }
        case "historyUndo": {
          it(i, k, void 0);
          break;
        }
        case "historyRedo": {
          it(i, H, void 0);
          break;
        }
      }
    });
  }
  function n(c, i) {
    c.stopPropagation(), Nr(i, () => {
      const a = en(), u = c.data, p = ls(c);
      if (u != null && ft(a) && Pl(a, p, u, c.timeStamp, false)) {
        Zn && (d(i, u), Zn = false);
        const y = a.anchor, M = y.getNode(), $ = sr(i._window);
        if ($ === null)
          return;
        const le = y.offset;
        (!ze || a.isCollapsed() || !dt(M) || $.anchorNode === null || M.getTextContent().slice(0, le) + u + M.getTextContent().slice(le + a.focus.offset) !== Ui($.anchorNode)) && it(i, C, u);
        const fe = u.length;
        Me && fe > 1 && c.inputType === "insertCompositionText" && !i.isComposing() && (a.anchor.offset -= fe), !oe && !ie && !Le && i.isComposing() && (Dr = 0, un(null));
      } else
        Zo(false, i, u !== null ? u : void 0), Zn && (d(i, u || void 0), Zn = false);
      ul();
    }), li = null;
  }
  function s(c, i) {
    Nr(i, () => {
      const a = en();
      if (ft(a) && !i.isComposing()) {
        const u = a.anchor, p = a.anchor.getNode();
        un(u.key), // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        (c.timeStamp < Dr + Je || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        u.type === "element" || !a.isCollapsed() || p.getFormat() !== a.format || p.getStyle() !== a.style) && it(i, C, nr);
      }
    });
  }
  function d(c, i) {
    const a = c._compositionKey;
    if (un(null), a !== null && i != null) {
      if (i === "") {
        const u = gn(a), p = Sn(c.getElementByKey(a));
        p !== null && p.nodeValue !== null && dt(u) && fo(u, p.nodeValue, null, null, true);
        return;
      }
      if (i[i.length - 1] === `
`) {
        const u = en();
        if (ft(u)) {
          const p = u.focus;
          u.anchor.set(p.key, p.offset, p.type), it(c, z, null);
          return;
        }
      }
    }
    Zo(true, c, i);
  }
  function m(c, i) {
    Me ? Zn = true : Nr(i, () => {
      d(i, c.data);
    });
  }
  function E(c, i) {
    if (Dr = c.timeStamp, Yn = c.keyCode, i.isComposing())
      return;
    const {
      keyCode: a,
      shiftKey: u,
      ctrlKey: p,
      metaKey: y,
      altKey: M
    } = c;
    if (!it(i, N, c)) {
      if (_a(a, p, M, y))
        it(i, v, c);
      else if (El(a, p, u, M, y))
        it(i, F, c);
      else if (Ls(a, p, M, y))
        it(i, U, c);
      else if (pa(a, p, u, M, y))
        it(i, I, c);
      else if (zi(a, p, y))
        it(i, K, c);
      else if (Tl(a, p, y))
        it(i, B, c);
      else if (go(a, u))
        wo = true, it(i, z, c);
      else if (Ps(a))
        it(i, te, c);
      else if (bs(a, p))
        c.preventDefault(), wo = true, it(i, f, true);
      else if (Wi(a, u))
        wo = false, it(i, z, c);
      else if (pl(a, M, y, p))
        Sr(a) ? it(i, re, c) : (c.preventDefault(), it(i, o, true));
      else if (ya(a))
        it(i, de, c);
      else if (_l(a, p, u, M, y))
        wr(a) ? it(i, V, c) : (c.preventDefault(), it(i, o, false));
      else if (Ms(a, M, p))
        c.preventDefault(), it(i, S, true);
      else if (po(a, M, p))
        c.preventDefault(), it(i, S, false);
      else if (_o(a, y))
        c.preventDefault(), it(i, x, true);
      else if (gl(a, y))
        c.preventDefault(), it(i, x, false);
      else if (ho(a, M, y, p))
        c.preventDefault(), it(i, D, "bold");
      else if (hl(a, M, y, p))
        c.preventDefault(), it(i, D, "underline");
      else if (fl(a, M, y, p))
        c.preventDefault(), it(i, D, "italic");
      else if (As(a, M, p, y))
        it(i, G, c);
      else if (ml(a, u, y, p))
        c.preventDefault(), it(i, k, void 0);
      else if (da(a, u, y, p))
        c.preventDefault(), it(i, H, void 0);
      else {
        const $ = i._editorState._selection;
        ur($) ? fa(a, u, y, p) ? (c.preventDefault(), it(i, ne, c)) : yl(a, u, y, p) ? (c.preventDefault(), it(i, Y, c)) : ri(a, y, p) && (c.preventDefault(), it(i, W, c)) : !Me && ri(a, y, p) && (c.preventDefault(), it(i, W, c));
      }
      ma(p, u, M, y) && it(i, ce, c);
    }
  }
  function R(c) {
    let i = c.__lexicalEventHandles;
    return i === void 0 && (i = [], c.__lexicalEventHandles = i), i;
  }
  const X = /* @__PURE__ */ new Map();
  function _e(c) {
    const i = c.target, a = i == null ? null : i.nodeType === 9 ? i.defaultView : i.ownerDocument.defaultView, u = sr(a);
    if (u === null)
      return;
    const p = ao(u.anchorNode);
    if (p === null)
      return;
    ai && (ai = false, Nr(p, () => {
      const Ce = fs(), Ee = u.anchorNode;
      if (Ee === null)
        return;
      const xe = Ee.nodeType;
      if (xe !== Be && xe !== Ye)
        return;
      const Ne = Ta(Ce, u, p);
      _r(Ne);
    }));
    const y = Jo(p), M = y[y.length - 1], $ = M._key, le = X.get($), fe = le || M;
    fe !== p && ss(u, fe, false), ss(u, p, true), p !== M ? X.set($, p) : le && X.delete($);
  }
  function Se(c) {
    c._lexicalHandled = true;
  }
  function Fe(c) {
    return c._lexicalHandled === true;
  }
  function Ue(c, i) {
    Qi === 0 && c.ownerDocument.addEventListener("selectionchange", _e), Qi++, c.__lexicalEditor = i;
    const a = R(c);
    for (let u = 0; u < os.length; u++) {
      const [p, y] = os[u], M = typeof y == "function" ? ($) => {
        Fe($) || (Se($), i.isEditable() && y($, i));
      } : ($) => {
        if (!Fe($) && (Se($), i.isEditable()))
          switch (p) {
            case "cut":
              return it(i, Y, $);
            case "copy":
              return it(i, ne, $);
            case "paste":
              return it(i, T, $);
            case "dragstart":
              return it(i, P, $);
            case "dragover":
              return it(i, w, $);
            case "dragend":
              return it(i, j, $);
            case "focus":
              return it(i, A, $);
            case "blur":
              return it(i, J, $);
            case "drop":
              return it(i, Z, $);
          }
      };
      c.addEventListener(p, M), a.push(() => {
        c.removeEventListener(p, M);
      });
    }
  }
  function Pe(c) {
    Qi !== 0 && (Qi--, Qi === 0 && c.ownerDocument.removeEventListener("selectionchange", _e));
    const i = c.__lexicalEditor;
    i != null && (De(i), c.__lexicalEditor = null);
    const a = R(c);
    for (let u = 0; u < a.length; u++)
      a[u]();
    c.__lexicalEventHandles = [];
  }
  function De(c) {
    if (c._parentEditor !== null) {
      const i = Jo(c), u = i[i.length - 1]._key;
      X.get(u) === c && X.delete(u);
    } else
      X.delete(c._key);
  }
  function Xe() {
    eo = true;
  }
  function lt(c, i, a, u, p) {
    zs = [c, i, a, u, p];
  }
  function Nt(c, i, a) {
    jn();
    const u = c.__key, p = c.getParent();
    if (p === null)
      return;
    const y = An(c);
    let M = false;
    if (ft(y) && i) {
      const $ = y.anchor, le = y.focus;
      $.key === u && (Gl($, c, p, c.getPreviousSibling(), c.getNextSibling()), M = true), le.key === u && (Gl(le, c, p, c.getPreviousSibling(), c.getNextSibling()), M = true);
    } else
      ur(y) && i && c.isSelected() && c.selectPrevious();
    if (ft(y) && i && !M) {
      const $ = c.getIndexWithinParent();
      ei(c), zl(y, p, $, -1);
    } else
      ei(c);
    !a && !Or(p) && !p.canBeEmpty() && p.isEmpty() && Nt(p, i), i && Er(p) && p.isEmpty() && p.selectEnd();
  }
  class Ot {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    /** @internal */
    /** @internal */
    //@ts-ignore We set the key in the constructor.
    /** @internal */
    /** @internal */
    /** @internal */
    // Flow doesn't support abstract classes unfortunately, so we can't _force_
    // subclasses of Node to implement statics. All subclasses of Node should have
    // a static getType and clone method though. We define getType and clone here so we can call it
    // on any  Node, and we throw this error by default since the subclass should provide
    // their own implementation.
    /**
     * Returns the string type of this node. Every node must
     * implement this and it MUST BE UNIQUE amongst nodes registered
     * on the editor.
     *
     */
    static getType() {
      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
    /**
     * Clones this node, creating a new node with a different key
     * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
     * implement this method.
     *
     */
    static clone(i) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
    constructor(i) {
      this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, Dn(this, i), this.__type !== "root" && (jn(), sn(
        this.__type,
        // @ts-expect-error
        this.constructor
      ));
    }
    // Getters and Traversers
    /**
     * Returns the string type of this node.
     */
    getType() {
      return this.__type;
    }
    /**
     * Returns true if there is a path between this node and the RootNode, false otherwise.
     * This is a way of determining if the node is "attached" EditorState. Unattached nodes
     * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
     */
    isAttached() {
      let i = this.__key;
      for (; i !== null; ) {
        if (i === "root")
          return true;
        const a = gn(i);
        if (a === null)
          break;
        i = a.__parent;
      }
      return false;
    }
    /**
     * Returns true if this node is contained within the provided Selection., false otherwise.
     * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
     * what's included.
     *
     * @param selection - The selection that we want to determine if the node is in.
     */
    isSelected(i) {
      const a = i || en();
      if (a == null)
        return false;
      const u = a.getNodes().some((p) => p.__key === this.__key);
      return dt(this) ? u : ft(a) && a.anchor.type === "element" && a.focus.type === "element" && a.anchor.key === a.focus.key && a.anchor.offset === a.focus.offset ? false : u;
    }
    /**
     * Returns this nodes key.
     */
    getKey() {
      return this.__key;
    }
    /**
     * Returns the zero-based index of this node within the parent.
     */
    getIndexWithinParent() {
      const i = this.getParent();
      if (i === null)
        return -1;
      let a = i.getFirstChild(), u = 0;
      for (; a !== null; ) {
        if (this.is(a))
          return u;
        u++, a = a.getNextSibling();
      }
      return -1;
    }
    /**
     * Returns the parent of this node, or null if none is found.
     */
    getParent() {
      const i = this.getLatest().__parent;
      return i === null ? null : gn(i);
    }
    /**
     * Returns the parent of this node, or throws if none is found.
     */
    getParentOrThrow() {
      const i = this.getParent();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a parent.`);
      return i;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElement() {
      let i = this;
      for (; i !== null; ) {
        const a = i.getParent();
        if (Or(a))
          return i;
        i = a;
      }
      return null;
    }
    /**
     * Returns the highest (in the EditorState tree)
     * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
     * for more information on which Elements comprise "roots".
     */
    getTopLevelElementOrThrow() {
      const i = this.getTopLevelElement();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a top parent element.`);
      return i;
    }
    /**
     * Returns a list of the every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParents() {
      const i = [];
      let a = this.getParent();
      for (; a !== null; )
        i.push(a), a = a.getParent();
      return i;
    }
    /**
     * Returns a list of the keys of every ancestor of this node,
     * all the way up to the RootNode.
     *
     */
    getParentKeys() {
      const i = [];
      let a = this.getParent();
      for (; a !== null; )
        i.push(a.__key), a = a.getParent();
      return i;
    }
    /**
     * Returns the "previous" siblings - that is, the node that comes
     * before this one in the same parent.
     *
     */
    getPreviousSibling() {
      const a = this.getLatest().__prev;
      return a === null ? null : gn(a);
    }
    /**
     * Returns the "previous" siblings - that is, the nodes that come between
     * this one and the first child of it's parent, inclusive.
     *
     */
    getPreviousSiblings() {
      const i = [], a = this.getParent();
      if (a === null)
        return i;
      let u = a.getFirstChild();
      for (; u !== null && !u.is(this); )
        i.push(u), u = u.getNextSibling();
      return i;
    }
    /**
     * Returns the "next" siblings - that is, the node that comes
     * after this one in the same parent
     *
     */
    getNextSibling() {
      const a = this.getLatest().__next;
      return a === null ? null : gn(a);
    }
    /**
     * Returns all "next" siblings - that is, the nodes that come between this
     * one and the last child of it's parent, inclusive.
     *
     */
    getNextSiblings() {
      const i = [];
      let a = this.getNextSibling();
      for (; a !== null; )
        i.push(a), a = a.getNextSibling();
      return i;
    }
    /**
     * Returns the closest common ancestor of this node and the provided one or null
     * if one cannot be found.
     *
     * @param node - the other node to find the common ancestor of.
     */
    getCommonAncestor(i) {
      const a = this.getParents(), u = i.getParents();
      Ze(this) && a.unshift(this), Ze(i) && u.unshift(i);
      const p = a.length, y = u.length;
      if (p === 0 || y === 0 || a[p - 1] !== u[y - 1])
        return null;
      const M = new Set(u);
      for (let $ = 0; $ < p; $++) {
        const le = a[$];
        if (M.has(le))
          return le;
      }
      return null;
    }
    /**
     * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
     * Always use this instead of referential equality.
     *
     * @param object - the node to perform the equality comparison on.
     */
    is(i) {
      return i == null ? false : this.__key === i.__key;
    }
    /**
     * Returns true if this node logical precedes the target node in the editor state.
     *
     * @param targetNode - the node we're testing to see if it's after this one.
     */
    isBefore(i) {
      if (this === i)
        return false;
      if (i.isParentOf(this))
        return true;
      if (this.isParentOf(i))
        return false;
      const a = this.getCommonAncestor(i);
      let u = 0, p = 0, y = this;
      for (; ; ) {
        const M = y.getParentOrThrow();
        if (M === a) {
          u = y.getIndexWithinParent();
          break;
        }
        y = M;
      }
      for (y = i; ; ) {
        const M = y.getParentOrThrow();
        if (M === a) {
          p = y.getIndexWithinParent();
          break;
        }
        y = M;
      }
      return u < p;
    }
    /**
     * Returns true if this node is the parent of the target node, false otherwise.
     *
     * @param targetNode - the would-be child node.
     */
    isParentOf(i) {
      const a = this.__key;
      if (a === i.__key)
        return false;
      let u = i;
      for (; u !== null; ) {
        if (u.__key === a)
          return true;
        u = u.getParent();
      }
      return false;
    }
    // TO-DO: this function can be simplified a lot
    /**
     * Returns a list of nodes that are between this node and
     * the target node in the EditorState.
     *
     * @param targetNode - the node that marks the other end of the range of nodes to be returned.
     */
    getNodesBetween(i) {
      const a = this.isBefore(i), u = [], p = /* @__PURE__ */ new Set();
      let y = this;
      for (; ; ) {
        const M = y.__key;
        if (p.has(M) || (p.add(M), u.push(y)), y === i)
          break;
        const $ = Ze(y) ? a ? y.getFirstChild() : y.getLastChild() : null;
        if ($ !== null) {
          y = $;
          continue;
        }
        const le = a ? y.getNextSibling() : y.getPreviousSibling();
        if (le !== null) {
          y = le;
          continue;
        }
        const fe = y.getParentOrThrow();
        if (p.has(fe.__key) || u.push(fe), fe === i)
          break;
        let Ce = null, Ee = fe;
        do {
          if (Ee === null)
            throw Error("getNodesBetween: ancestor is null");
          Ce = a ? Ee.getNextSibling() : Ee.getPreviousSibling(), Ee = Ee.getParent(), Ee !== null && Ce === null && !p.has(Ee.__key) && u.push(Ee);
        } while (Ce === null);
        y = Ce;
      }
      return a || u.reverse(), u;
    }
    /**
     * Returns true if this node has been marked dirty during this update cycle.
     *
     */
    isDirty() {
      const a = ln()._dirtyLeaves;
      return a !== null && a.has(this.__key);
    }
    /**
     * Returns the latest version of the node from the active EditorState.
     * This is used to avoid getting values from stale node references.
     *
     */
    getLatest() {
      const i = gn(this.__key);
      if (i === null)
        throw Error("Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.");
      return i;
    }
    /**
     * Returns a mutable version of the node. Will throw an error if
     * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
     *
     */
    getWritable() {
      jn();
      const i = gi(), a = ln(), u = i._nodeMap, p = this.__key, y = this.getLatest(), M = y.__parent, $ = a._cloneNotNeeded, le = en();
      if (cr(le) && le.setCachedNodes(null), $.has(p))
        return Ki(y), y;
      const Ce = y.constructor.clone(y);
      return Ce.__parent = M, Ce.__next = y.__next, Ce.__prev = y.__prev, Ze(y) && Ze(Ce) ? (Ce.__first = y.__first, Ce.__last = y.__last, Ce.__size = y.__size, Ce.__indent = y.__indent, Ce.__format = y.__format, Ce.__dir = y.__dir) : dt(y) && dt(Ce) && (Ce.__format = y.__format, Ce.__style = y.__style, Ce.__mode = y.__mode, Ce.__detail = y.__detail), $.add(p), Ce.__key = p, Ki(Ce), u.set(p, Ce), Ce;
    }
    /**
     * Returns the text content of the node. Override this for
     * custom nodes that should have a representation in plain text
     * format (for copy + paste, for example)
     *
     */
    getTextContent() {
      return "";
    }
    /**
     * Returns the length of the string produced by calling getTextContent on this node.
     *
     */
    getTextContentSize() {
      return this.getTextContent().length;
    }
    // View
    /**
     * Called during the reconciliation process to determine which nodes
     * to insert into the DOM for this Lexical Node.
     *
     * This method must return exactly one HTMLElement. Nested elements are not supported.
     *
     * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
     *
     * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
     * @param _editor - allows access to the editor for context during reconciliation.
     *
     * */
    createDOM(i, a) {
      throw Error("createDOM: base method not extended");
    }
    /**
     * Called when a node changes and should update the DOM
     * in whatever way is necessary to make it align with any changes that might
     * have happened during the update.
     *
     * Returning "true" here will cause lexical to unmount and recreate the DOM node
     * (by calling createDOM). You would need to do this if the element tag changes,
     * for instance.
     *
     * */
    updateDOM(i, a, u) {
      throw Error("updateDOM: base method not extended");
    }
    /**
     * Controls how the this node is serialized to HTML. This is important for
     * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
     * in which case the primary transfer format is HTML. It's also important if you're serializing
     * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
     * also use this method to build your own HTML renderer.
     *
     * */
    exportDOM(i) {
      return {
        element: this.createDOM(i._config, i)
      };
    }
    /**
     * Controls how the this node is serialized to JSON. This is important for
     * copy and paste between Lexical editors sharing the same namespace. It's also important
     * if you're serializing to JSON for persistent storage somewhere.
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    exportJSON() {
      throw Error("exportJSON: base method not extended");
    }
    /**
     * Controls how the this node is deserialized from JSON. This is usually boilerplate,
     * but provides an abstraction between the node implementation and serialized interface that can
     * be important if you ever make breaking changes to a node schema (by adding or removing properties).
     * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
     *
     * */
    static importJSON(i) {
      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
    /**
     * @experimental
     *
     * Registers the returned function as a transform on the node during
     * Editor initialization. Most such use cases should be addressed via
     * the {@link LexicalEditor.registerNodeTransform} API.
     *
     * Experimental - use at your own risk.
     */
    static transform() {
      return null;
    }
    // Setters and mutators
    /**
     * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
     * somewhere, the Lexical garbage collector will eventually clean it up.
     *
     * @param preserveEmptyParent - If falsy, the node's parent will be removed if
     * it's empty after the removal operation. This is the default behavior, subject to
     * other node heuristics such as {@link ElementNode#canBeEmpty}
     * */
    remove(i) {
      Nt(this, true, i);
    }
    /**
     * Replaces this LexicalNode with the provided node, optionally transferring the children
     * of the replaced node to the replacing node.
     *
     * @param replaceWith - The node to replace this one with.
     * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
     * */
    replace(i, a) {
      jn();
      let u = en();
      u !== null && (u = u.clone()), Rr(this, i);
      const p = this.getLatest(), y = this.__key, M = i.__key, $ = i.getWritable(), le = this.getParentOrThrow().getWritable(), fe = le.__size;
      ei($);
      const Ce = p.getPreviousSibling(), Ee = p.getNextSibling(), xe = p.__prev, Ne = p.__next, Ke = p.__parent;
      if (Nt(p, false, true), Ce === null)
        le.__first = M;
      else {
        const Ie = Ce.getWritable();
        Ie.__next = M;
      }
      if ($.__prev = xe, Ee === null)
        le.__last = M;
      else {
        const Ie = Ee.getWritable();
        Ie.__prev = M;
      }
      if ($.__next = Ne, $.__parent = Ke, le.__size = fe, a && this.getChildren().forEach((Ie) => {
        $.append(Ie);
      }), ft(u)) {
        _r(u);
        const Ie = u.anchor, Ae = u.focus;
        Ie.key === y && Ul(Ie, $), Ae.key === y && Ul(Ae, $);
      }
      return vr() === y && un(M), $;
    }
    /**
     * Inserts a node after this LexicalNode (as the next sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertAfter(i, a = true) {
      jn(), Rr(this, i);
      const u = this.getWritable(), p = i.getWritable(), y = p.getParent(), M = en();
      let $ = false, le = false;
      if (y !== null) {
        const Ne = i.getIndexWithinParent();
        if (ei(p), ft(M)) {
          const Ke = y.__key, Ie = M.anchor, Ae = M.focus;
          $ = Ie.type === "element" && Ie.key === Ke && Ie.offset === Ne + 1, le = Ae.type === "element" && Ae.key === Ke && Ae.offset === Ne + 1;
        }
      }
      const fe = this.getNextSibling(), Ce = this.getParentOrThrow().getWritable(), Ee = p.__key, xe = u.__next;
      if (fe === null)
        Ce.__last = Ee;
      else {
        const Ne = fe.getWritable();
        Ne.__prev = Ee;
      }
      if (Ce.__size++, u.__next = Ee, p.__next = xe, p.__prev = u.__key, p.__parent = u.__parent, a && ft(M)) {
        const Ne = this.getIndexWithinParent();
        zl(M, Ce, Ne + 1);
        const Ke = Ce.__key;
        $ && M.anchor.set(Ke, Ne + 2, "element"), le && M.focus.set(Ke, Ne + 2, "element");
      }
      return i;
    }
    /**
     * Inserts a node before this LexicalNode (as the previous sibling).
     *
     * @param nodeToInsert - The node to insert after this one.
     * @param restoreSelection - Whether or not to attempt to resolve the
     * selection to the appropriate place after the operation is complete.
     * */
    insertBefore(i, a = true) {
      jn(), Rr(this, i);
      const u = this.getWritable(), p = i.getWritable(), y = p.__key;
      ei(p);
      const M = this.getPreviousSibling(), $ = this.getParentOrThrow().getWritable(), le = u.__prev, fe = this.getIndexWithinParent();
      if (M === null)
        $.__first = y;
      else {
        const Ee = M.getWritable();
        Ee.__next = y;
      }
      $.__size++, u.__prev = y, p.__prev = le, p.__next = u.__key, p.__parent = u.__parent;
      const Ce = en();
      if (a && ft(Ce)) {
        const Ee = this.getParentOrThrow();
        zl(Ce, Ee, fe);
      }
      return i;
    }
    /**
     * Whether or not this node has a required parent. Used during copy + paste operations
     * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
     * a ListNode parent or TextNodes with a ParagraphNode parent.
     *
     * */
    isParentRequired() {
      return false;
    }
    /**
     * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
     *
     * */
    createParentElementNode() {
      return Ai();
    }
    selectStart() {
      return this.selectPrevious();
    }
    selectEnd() {
      return this.selectNext(0, 0);
    }
    /**
     * Moves selection to the previous sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectPrevious(i, a) {
      jn();
      const u = this.getPreviousSibling(), p = this.getParentOrThrow();
      if (u === null)
        return p.select(0, 0);
      if (Ze(u))
        return u.select();
      if (!dt(u)) {
        const y = u.getIndexWithinParent() + 1;
        return p.select(y, y);
      }
      return u.select(i, a);
    }
    /**
     * Moves selection to the next sibling of this node, at the specified offsets.
     *
     * @param anchorOffset - The anchor offset for selection.
     * @param focusOffset -  The focus offset for selection
     * */
    selectNext(i, a) {
      jn();
      const u = this.getNextSibling(), p = this.getParentOrThrow();
      if (u === null)
        return p.select();
      if (Ze(u))
        return u.select(0, 0);
      if (!dt(u)) {
        const y = u.getIndexWithinParent();
        return p.select(y, y);
      }
      return u.select(i, a);
    }
    /**
     * Marks a node dirty, triggering transforms and
     * forcing it to be reconciled during the update cycle.
     *
     * */
    markDirty() {
      this.getWritable();
    }
  }
  function sn(c, i) {
    const a = ln()._nodes.get(c);
    if (a === void 0)
      throw Error(`Create node: Attempted to create node ${i.name} that was not configured to be used on the editor.`);
    const u = a.klass;
    if (u !== i)
      throw Error(`Create node: Type ${c} in node ${i.name} does not match registered node ${u.name} with the same type`);
  }
  function Xn(c, i, a) {
    const u = a || i.getParentOrThrow().getLastChild();
    let p = i;
    const y = [i];
    for (; p !== u; ) {
      if (!p.getNextSibling())
        throw Error("insertRangeAfter: lastToInsert must be a later sibling of firstToInsert");
      p = p.getNextSibling(), y.push(p);
    }
    let M = c;
    for (const $ of y)
      M = M.insertAfter($);
  }
  class Ar extends Ot {
    static getType() {
      return "linebreak";
    }
    static clone(i) {
      return new Ar(i.__key);
    }
    constructor(i) {
      super(i);
    }
    getTextContent() {
      return `
`;
    }
    createDOM() {
      return document.createElement("br");
    }
    updateDOM() {
      return false;
    }
    static importDOM() {
      return {
        br: (i) => {
          const a = i.parentElement;
          let u, p;
          return a !== null && ((u = a.firstChild) === i || u.nextSibling === i && u.nodeType === Ye && (u.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) && ((p = a.lastChild) === i || p.previousSibling === i && p.nodeType === Ye && (p.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) ? null : {
            conversion: jr,
            priority: 0
          };
        }
      };
    }
    static importJSON(i) {
      return ci();
    }
    exportJSON() {
      return {
        type: "linebreak",
        version: 1
      };
    }
  }
  function jr(c) {
    return {
      node: ci()
    };
  }
  function ci() {
    return Yi(new Ar());
  }
  function ui(c) {
    return c instanceof Ar;
  }
  function to(c, i) {
    return i & Ve ? "code" : i & At ? "mark" : i & Qe ? "sub" : i & ct ? "sup" : null;
  }
  function Gs(c, i) {
    return i & Oe ? "strong" : i & be ? "em" : "span";
  }
  function as(c, i, a, u, p) {
    const y = u.classList;
    let M = Ei(p, "base");
    M !== void 0 && y.add(...M), M = Ei(p, "underlineStrikethrough");
    let $ = false;
    const le = i & He && i & Re, fe = a & He && a & Re;
    M !== void 0 && (fe ? ($ = true, le || y.add(...M)) : le && y.remove(...M));
    for (const Ce in on) {
      const xe = on[Ce];
      if (M = Ei(p, Ce), M !== void 0)
        if (a & xe) {
          if ($ && (Ce === "underline" || Ce === "strikethrough")) {
            i & xe && y.remove(...M);
            continue;
          }
          (!(i & xe) || le && Ce === "underline" || Ce === "strikethrough") && y.add(...M);
        } else
          i & xe && y.remove(...M);
    }
  }
  function br(c, i) {
    const a = c.length, u = i.length;
    let p = 0, y = 0;
    for (; p < a && p < u && c[p] === i[p]; )
      p++;
    for (; y + p < a && y + p < u && c[a - y - 1] === i[u - y - 1]; )
      y++;
    return [p, a - p - y, i.slice(p, u - y)];
  }
  function no(c, i, a) {
    const u = i.firstChild, p = a.isComposing(), M = c + (p ? Kt : "");
    if (u == null)
      i.textContent = M;
    else {
      const $ = u.nodeValue;
      if ($ !== M)
        if (p || Me) {
          const [le, fe, Ce] = br($, M);
          fe !== 0 && u.deleteData(le, fe), u.insertData(le, Ce);
        } else
          u.nodeValue = M;
    }
  }
  function cs(c, i, a, u, p, y) {
    no(p, c, i);
    const $ = y.theme.text;
    $ !== void 0 && as(a, 0, u, c, $);
  }
  function Ro(c, i) {
    const a = document.createElement(i);
    return a.appendChild(c), a;
  }
  class wi extends Ot {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "text";
    }
    static clone(i) {
      return new wi(i.__text, i.__key);
    }
    constructor(i, a) {
      super(a), this.__text = i, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
    }
    /**
     * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
     *
     * @returns a number representing the format of the text node.
     */
    getFormat() {
      return this.getLatest().__format;
    }
    /**
     * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
     * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
     * or TextNode.isUnmergeable instead.
     *
     * @returns a number representing the detail of the text node.
     */
    getDetail() {
      return this.getLatest().__detail;
    }
    /**
     * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
     *
     * @returns TextModeType.
     */
    getMode() {
      const i = this.getLatest();
      return Ge[i.__mode];
    }
    /**
     * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
     *
     * @returns CSSText-like string of styles applied to the underlying DOM node.
     */
    getStyle() {
      return this.getLatest().__style;
    }
    /**
     * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
     *
     * @returns true if the node is in token mode, false otherwise.
     */
    isToken() {
      return this.getLatest().__mode === se;
    }
    /**
     *
     * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
     * mutate the TextNode, false otherwise.
     */
    isComposing() {
      return this.__key === vr();
    }
    /**
     * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
     * with a RangeSelection, but are deleted in space-delimited "segments".
     *
     * @returns true if the node is in segmented mode, false otherwise.
     */
    isSegmented() {
      return this.getLatest().__mode === he;
    }
    /**
     * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
     *
     * @returns true if the node is directionless, false otherwise.
     */
    isDirectionless() {
      return (this.getLatest().__detail & qe) !== 0;
    }
    /**
     * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
     * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
     *
     * @returns true if the node is unmergeable, false otherwise.
     */
    isUnmergeable() {
      return (this.getLatest().__detail & nt) !== 0;
    }
    /**
     * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
     * string values to get the format of a TextNode.
     *
     * @param type - the TextFormatType to check for.
     *
     * @returns true if the node has the provided format, false otherwise.
     */
    hasFormat(i) {
      const a = on[i];
      return (this.getFormat() & a) !== 0;
    }
    /**
     * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
     * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
     *
     * @returns true if the node is simple text, false otherwise.
     */
    isSimpleText() {
      return this.__type === "text" && this.__mode === 0;
    }
    /**
     * Returns the text content of the node as a string.
     *
     * @returns a string representing the text content of the node.
     */
    getTextContent() {
      return this.getLatest().__text;
    }
    /**
     * Returns the format flags applied to the node as a 32-bit integer.
     *
     * @returns a number representing the TextFormatTypes applied to the node.
     */
    getFormatFlags(i, a) {
      const p = this.getLatest().__format;
      return pr(p, i, a);
    }
    // View
    createDOM(i) {
      const a = this.__format, u = to(this, a), p = Gs(this, a), y = u === null ? p : u, M = document.createElement(y);
      let $ = M;
      this.hasFormat("code") && M.setAttribute("spellcheck", "false"), u !== null && ($ = document.createElement(p), M.appendChild($));
      const le = this.__text;
      cs($, this, p, a, le, i);
      const fe = this.__style;
      return fe !== "" && (M.style.cssText = fe), M;
    }
    updateDOM(i, a, u) {
      const p = this.__text, y = i.__format, M = this.__format, $ = to(this, y), le = to(this, M), fe = Gs(this, y), Ce = Gs(this, M);
      if (($ === null ? fe : $) !== (le === null ? Ce : le))
        return true;
      if ($ === le && fe !== Ce) {
        const We = a.firstChild;
        if (We == null)
          throw Error("updateDOM: prevInnerDOM is null or undefined");
        const tt = document.createElement(Ce);
        return cs(tt, this, Ce, M, p, u), a.replaceChild(tt, We), false;
      }
      let Ne = a;
      if (le !== null && $ !== null && (Ne = a.firstChild, Ne == null))
        throw Error("updateDOM: innerDOM is null or undefined");
      no(p, Ne, this);
      const Ie = u.theme.text;
      Ie !== void 0 && y !== M && as(Ce, y, M, Ne, Ie);
      const Ae = i.__style, ht = this.__style;
      return Ae !== ht && (a.style.cssText = ht), false;
    }
    static importDOM() {
      return {
        "#text": () => ({
          conversion: js,
          priority: 0
        }),
        b: () => ({
          conversion: Bl,
          priority: 0
        }),
        code: () => ({
          conversion: Mr,
          priority: 0
        }),
        em: () => ({
          conversion: Mr,
          priority: 0
        }),
        i: () => ({
          conversion: Mr,
          priority: 0
        }),
        s: () => ({
          conversion: Mr,
          priority: 0
        }),
        span: () => ({
          conversion: Fl,
          priority: 0
        }),
        strong: () => ({
          conversion: Mr,
          priority: 0
        }),
        sub: () => ({
          conversion: Mr,
          priority: 0
        }),
        sup: () => ({
          conversion: Mr,
          priority: 0
        }),
        u: () => ({
          conversion: Mr,
          priority: 0
        })
      };
    }
    static importJSON(i) {
      const a = Mn(i.text);
      return a.setFormat(i.format), a.setDetail(i.detail), a.setMode(i.mode), a.setStyle(i.style), a;
    }
    // This improves Lexical's basic text output in copy+paste plus
    // for headless mode where people might use Lexical to generate
    // HTML content and not have the ability to use CSS classes.
    exportDOM(i) {
      let {
        element: a
      } = super.exportDOM(i);
      if (!(a !== null && To(a)))
        throw Error("Expected TextNode createDOM to always return a HTMLElement");
      return a.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (a = Ro(a, "b")), this.hasFormat("italic") && (a = Ro(a, "i")), this.hasFormat("strikethrough") && (a = Ro(a, "s")), this.hasFormat("underline") && (a = Ro(a, "u")), {
        element: a
      };
    }
    exportJSON() {
      return {
        detail: this.getDetail(),
        format: this.getFormat(),
        mode: this.getMode(),
        style: this.getStyle(),
        text: this.getTextContent(),
        type: "text",
        version: 1
      };
    }
    // Mutators
    selectionTransform(i, a) {
    }
    /**
     * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
     * version of the argument can only specify one format and doing so will remove all other formats that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
     *
     * @param format - TextFormatType or 32-bit integer representing the node format.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setFormat(i) {
      const a = this.getWritable();
      return a.__format = typeof i == "string" ? on[i] : i, a;
    }
    /**
     * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
     * version of the argument can only specify one detail value and doing so will remove all other detail values that
     * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
     * or {@link TextNode.togglerUnmergeable}
     *
     * @param detail - TextDetailType or 32-bit integer representing the node detail.
     *
     * @returns this TextNode.
     * // TODO 0.12 This should just be a `string`.
     */
    setDetail(i) {
      const a = this.getWritable();
      return a.__detail = typeof i == "string" ? rr[i] : i, a;
    }
    /**
     * Sets the node style to the provided CSSText-like string. Set this property as you
     * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
     *
     * @param style - CSSText to be applied to the underlying HTMLElement.
     *
     * @returns this TextNode.
     */
    setStyle(i) {
      const a = this.getWritable();
      return a.__style = i, a;
    }
    /**
     * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
     * The subscript and superscript formats are mutually exclusive.
     * Prefer using this method to turn specific formats on and off.
     *
     * @param type - TextFormatType to toggle.
     *
     * @returns this TextNode.
     */
    toggleFormat(i) {
      const a = this.getFormat(), u = pr(a, i, null);
      return this.setFormat(u);
    }
    /**
     * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleDirectionless() {
      const i = this.getWritable();
      return i.__detail ^= qe, i;
    }
    /**
     * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
     *
     * @returns this TextNode.
     */
    toggleUnmergeable() {
      const i = this.getWritable();
      return i.__detail ^= nt, i;
    }
    /**
     * Sets the mode of the node.
     *
     * @returns this TextNode.
     */
    setMode(i) {
      const a = ye[i];
      if (this.__mode === a)
        return this;
      const u = this.getWritable();
      return u.__mode = a, u;
    }
    /**
     * Sets the text content of the node.
     *
     * @param text - the string to set as the text value of the node.
     *
     * @returns this TextNode.
     */
    setTextContent(i) {
      if (this.__text === i)
        return this;
      const a = this.getWritable();
      return a.__text = i, a;
    }
    /**
     * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
     *
     * @param _anchorOffset - the offset at which the Selection anchor will be placed.
     * @param _focusOffset - the offset at which the Selection focus will be placed.
     *
     * @returns the new RangeSelection.
     */
    select(i, a) {
      jn();
      let u = i, p = a;
      const y = en(), M = this.getTextContent(), $ = this.__key;
      if (typeof M == "string") {
        const le = M.length;
        u === void 0 && (u = le), p === void 0 && (p = le);
      } else
        u = 0, p = 0;
      if (ft(y)) {
        const le = vr();
        (le === y.anchor.key || le === y.focus.key) && un($), y.setTextNodeRange(this, u, this, p);
      } else
        return tu($, u, $, p, "text", "text");
      return y;
    }
    selectStart() {
      return this.select(0, 0);
    }
    selectEnd() {
      const i = this.getTextContentSize();
      return this.select(i, i);
    }
    /**
     * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
     * specified. Can optionally calculate a new selection after the operation is complete.
     *
     * @param offset - the offset at which the splice operation should begin.
     * @param delCount - the number of characters to delete, starting from the offset.
     * @param newText - the text to insert into the TextNode at the offset.
     * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
     *
     * @returns this TextNode.
     */
    spliceText(i, a, u, p) {
      const y = this.getWritable(), M = y.__text, $ = u.length;
      let le = i;
      le < 0 && (le = $ + le, le < 0 && (le = 0));
      const fe = en();
      if (p && ft(fe)) {
        const Ee = i + $;
        fe.setTextNodeRange(y, Ee, y, Ee);
      }
      const Ce = M.slice(0, le) + u + M.slice(le + a);
      return y.__text = Ce, y;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted before the node, false otherwise.
     */
    canInsertTextBefore() {
      return true;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
     * to insert text into this node. If false, it will insert the text in a new sibling node.
     *
     * @returns true if text can be inserted after the node, false otherwise.
     */
    canInsertTextAfter() {
      return true;
    }
    /**
     * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
     * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
     *
     * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
     *
     * @returns an Array containing the newly-created TextNodes.
     */
    splitText(...i) {
      jn();
      const a = this.getLatest(), u = a.getTextContent(), p = a.__key, y = vr(), M = new Set(i), $ = [], le = u.length;
      let fe = "";
      for (let Tt = 0; Tt < le; Tt++)
        fe !== "" && M.has(Tt) && ($.push(fe), fe = ""), fe += u[Tt];
      fe !== "" && $.push(fe);
      const Ce = $.length;
      if (Ce === 0)
        return [];
      if ($[0] === u)
        return [a];
      const Ee = $[0], xe = a.getParentOrThrow();
      let Ne;
      const Ke = a.getFormat(), Ie = a.getStyle(), Ae = a.__detail;
      let ht = false;
      a.isSegmented() ? (Ne = Mn(Ee), Ne.__format = Ke, Ne.__style = Ie, Ne.__detail = Ae, ht = true) : (Ne = a.getWritable(), Ne.__text = Ee);
      const We = en(), tt = [Ne];
      let Pt = Ee.length;
      for (let Tt = 1; Tt < Ce; Tt++) {
        const $t = $[Tt], Gt = $t.length, an = Mn($t).getWritable();
        an.__format = Ke, an.__style = Ie, an.__detail = Ae;
        const zt = an.__key, Nn = Pt + Gt;
        if (ft(We)) {
          const Vr = We.anchor, bi = We.focus;
          Vr.key === p && Vr.type === "text" && Vr.offset > Pt && Vr.offset <= Nn && (Vr.key = zt, Vr.offset -= Pt, We.dirty = true), bi.key === p && bi.type === "text" && bi.offset > Pt && bi.offset <= Nn && (bi.key = zt, bi.offset -= Pt, We.dirty = true);
        }
        y === p && un(zt), Pt = Nn, tt.push(an);
      }
      Yo(this);
      const Rt = xe.getWritable(), mt = this.getIndexWithinParent();
      return ht ? (Rt.splice(mt, 0, tt), this.remove()) : Rt.splice(mt, 1, tt), ft(We) && zl(We, xe, mt, Ce - 1), tt;
    }
    /**
     * Merges the target TextNode into this TextNode, removing the target node.
     *
     * @param target - the TextNode to merge into this one.
     *
     * @returns this TextNode.
     */
    mergeWithSibling(i) {
      const a = i === this.getPreviousSibling();
      if (!a && i !== this.getNextSibling())
        throw Error("mergeWithSibling: sibling must be a previous or next sibling");
      const u = this.__key, p = i.__key, y = this.__text, M = y.length;
      vr() === p && un(u);
      const le = en();
      if (ft(le)) {
        const xe = le.anchor, Ne = le.focus;
        xe !== null && xe.key === p && (ru(xe, a, u, i, M), le.dirty = true), Ne !== null && Ne.key === p && (ru(Ne, a, u, i, M), le.dirty = true);
      }
      const fe = i.__text, Ce = a ? fe + y : y + fe;
      this.setTextContent(Ce);
      const Ee = this.getWritable();
      return i.remove(), Ee;
    }
    /**
     * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
     * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
     * node class that you create and replace matched text with should return true from this method.
     *
     * @returns true if the node is to be treated as a "text entity", false otherwise.
     */
    isTextEntity() {
      return false;
    }
  }
  function Fl(c) {
    const i = c, a = i.style.fontWeight === "700", u = i.style.textDecoration === "line-through", p = i.style.fontStyle === "italic", y = i.style.textDecoration === "underline", M = i.style.verticalAlign;
    return {
      forChild: ($) => (dt($) && (a && $.toggleFormat("bold"), u && $.toggleFormat("strikethrough"), p && $.toggleFormat("italic"), y && $.toggleFormat("underline"), M === "sub" && $.toggleFormat("subscript"), M === "super" && $.toggleFormat("superscript")), $),
      node: null
    };
  }
  function Bl(c) {
    const a = c.style.fontWeight === "normal";
    return {
      forChild: (u) => (dt(u) && !a && u.toggleFormat("bold"), u),
      node: null
    };
  }
  const Do = /* @__PURE__ */ new WeakMap();
  function Kl(c) {
    return c.nodeName === "PRE" || c.nodeType === Be && c.style !== void 0 && c.style.whiteSpace !== void 0 && c.style.whiteSpace.startsWith("pre");
  }
  function Ys(c) {
    let i, a = c.parentNode;
    const u = [c];
    for (; a !== null && (i = Do.get(a)) === void 0 && !Kl(a); )
      u.push(a), a = a.parentNode;
    const p = i === void 0 ? a : i;
    for (let y = 0; y < u.length; y++)
      Do.set(u[y], p);
    return p;
  }
  function js(c) {
    const i = c;
    if (c.parentElement === null)
      throw Error("Expected parentElement of Text not to be null");
    let u = i.textContent || "";
    if (Ys(i) !== null) {
      const p = u.split(/(\r?\n|\t)/), y = [], M = p.length;
      for (let $ = 0; $ < M; $++) {
        const le = p[$];
        le === `
` || le === `\r
` ? y.push(ci()) : le === "	" ? y.push(Oi()) : le !== "" && y.push(Mn(le));
      }
      return {
        node: y
      };
    }
    if (u = u.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), u === "")
      return {
        node: null
      };
    if (u[0] === " ") {
      let p = i, y = true;
      for (; p !== null && (p = ro(p, false)) !== null; ) {
        const M = p.textContent || "";
        if (M.length > 0) {
          /[ \t\n]$/.test(M) && (u = u.slice(1)), y = false;
          break;
        }
      }
      y && (u = u.slice(1));
    }
    if (u[u.length - 1] === " ") {
      let p = i, y = true;
      for (; p !== null && (p = ro(p, true)) !== null; )
        if ((p.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
          y = false;
          break;
        }
      y && (u = u.slice(0, u.length - 1));
    }
    return u === "" ? {
      node: null
    } : {
      node: Mn(u)
    };
  }
  const Hl = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
  function ro(c, i) {
    let a = c;
    for (; ; ) {
      let u;
      for (; (u = i ? a.nextSibling : a.previousSibling) === null; ) {
        const y = a.parentElement;
        if (y === null)
          return null;
        a = y;
      }
      if (a = u, a.nodeType === Be) {
        const y = a.style.display;
        if (y === "" && a.nodeName.match(Hl) === null || y !== "" && !y.startsWith("inline"))
          return null;
      }
      let p = a;
      for (; (p = i ? a.firstChild : a.lastChild) !== null; )
        a = p;
      if (a.nodeType === Ye)
        return a;
      if (a.nodeName === "BR")
        return null;
    }
  }
  const us = {
    code: "code",
    em: "italic",
    i: "italic",
    s: "strikethrough",
    strong: "bold",
    sub: "subscript",
    sup: "superscript",
    u: "underline"
  };
  function Mr(c) {
    const i = us[c.nodeName.toLowerCase()];
    return i === void 0 ? {
      node: null
    } : {
      forChild: (a) => (dt(a) && !a.hasFormat(i) && a.toggleFormat(i), a),
      node: null
    };
  }
  function Mn(c = "") {
    return Yi(new wi(c));
  }
  function dt(c) {
    return c instanceof wi;
  }
  class di extends wi {
    static getType() {
      return "tab";
    }
    static clone(i) {
      const a = new di(i.__key);
      return a.__text = i.__text, a.__format = i.__format, a.__style = i.__style, a;
    }
    constructor(i) {
      super("	", i), this.__detail = nt;
    }
    static importDOM() {
      return null;
    }
    static importJSON(i) {
      const a = Oi();
      return a.setFormat(i.format), a.setStyle(i.style), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tab",
        version: 1
      };
    }
    setTextContent(i) {
      throw Error("TabNode does not support setTextContent");
    }
    setDetail(i) {
      throw Error("TabNode does not support setDetail");
    }
    setMode(i) {
      throw Error("TabNode does not support setMode");
    }
    canInsertTextBefore() {
      return false;
    }
    canInsertTextAfter() {
      return false;
    }
  }
  function Oi() {
    return Yi(new di());
  }
  function Ao(c) {
    return c instanceof di;
  }
  class fi {
    constructor(i, a, u) {
      this._selection = null, this.key = i, this.offset = a, this.type = u;
    }
    is(i) {
      return this.key === i.key && this.offset === i.offset && this.type === i.type;
    }
    isBefore(i) {
      let a = this.getNode(), u = i.getNode();
      const p = this.offset, y = i.offset;
      if (Ze(a)) {
        const M = a.getDescendantByIndex(p);
        a = M ?? a;
      }
      if (Ze(u)) {
        const M = u.getDescendantByIndex(y);
        u = M ?? u;
      }
      return a === u ? p < y : a.isBefore(u);
    }
    getNode() {
      const i = this.key, a = gn(i);
      if (a === null)
        throw Error("Point.getNode: node not found");
      return a;
    }
    set(i, a, u) {
      const p = this._selection, y = this.key;
      this.key = i, this.offset = a, this.type = u, hs() || (vr() === y && un(i), p !== null && (p.setCachedNodes(null), p.dirty = true));
    }
  }
  function Lr(c, i, a) {
    return new fi(c, i, a);
  }
  function bo(c, i) {
    let a = i.__key, u = c.offset, p = "element";
    if (dt(i)) {
      p = "text";
      const y = i.getTextContentSize();
      u > y && (u = y);
    } else if (!Ze(i)) {
      const y = i.getNextSibling();
      if (dt(y))
        a = y.__key, u = 0, p = "text";
      else {
        const M = i.getParent();
        M && (a = M.__key, u = i.getIndexWithinParent() + 1);
      }
    }
    c.set(a, u, p);
  }
  function Ul(c, i) {
    if (Ze(i)) {
      const a = i.getLastDescendant();
      Ze(a) || dt(a) ? bo(c, a) : bo(c, i);
    } else
      bo(c, i);
  }
  function qs(c, i, a, u) {
    const p = c.getNode(), y = p.getChildAtIndex(c.offset), M = Mn(), $ = Er(p) ? Ai().append(M) : M;
    M.setFormat(a), M.setStyle(u), y === null ? p.append($) : y.insertBefore($), c.is(i) && i.set(M.__key, 0, "text"), c.set(M.__key, 0, "text");
  }
  function qr(c, i, a, u) {
    c.key = i, c.offset = a, c.type = u;
  }
  class qt {
    constructor(i, a) {
      this.anchor = i, this.focus = a, i._selection = this, a._selection = this, this._cachedNodes = null, this.dirty = false;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return cr(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) : false;
    }
    isCollapsed() {
      return false;
    }
    extract() {
      return this.getNodes();
    }
    /**
     * Returns whether the Selection is "backwards", meaning the focus
     * logically precedes the anchor in the EditorState.
     * @returns true if the Selection is backwards, false otherwise.
     */
    isBackward() {
      return this.focus.isBefore(this.anchor);
    }
    /**
     * Returns the character-based offsets of the Selection, accounting for non-text Points
     * by using the children size or text content.
     *
     * @returns the character offsets for the Selection
     */
    getCharacterOffsets() {
      return Gn(this);
    }
  }
  class wn {
    constructor(i) {
      this.dirty = false, this._nodes = i, this._cachedNodes = null;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      if (!ur(i))
        return false;
      const a = this._nodes, u = i._nodes;
      return a.size === u.size && Array.from(a).every((p) => u.has(p));
    }
    add(i) {
      this.dirty = true, this._nodes.add(i), this._cachedNodes = null;
    }
    delete(i) {
      this.dirty = true, this._nodes.delete(i), this._cachedNodes = null;
    }
    clear() {
      this.dirty = true, this._nodes.clear(), this._cachedNodes = null;
    }
    has(i) {
      return this._nodes.has(i);
    }
    clone() {
      return new wn(new Set(this._nodes));
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(i) {
    }
    insertText() {
    }
    insertNodes(i) {
      const a = this.getNodes(), u = a.length, p = a[u - 1];
      let y;
      if (dt(p))
        y = p.select();
      else {
        const M = p.getIndexWithinParent() + 1;
        y = p.getParentOrThrow().select(M, M);
      }
      y.insertNodes(i);
      for (let M = 0; M < u; M++)
        a[M].remove();
    }
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this._nodes, u = [];
      for (const p of a) {
        const y = gn(p);
        y !== null && u.push(y);
      }
      return hs() || (this._cachedNodes = u), u;
    }
    getTextContent() {
      const i = this.getNodes();
      let a = "";
      for (let u = 0; u < i.length; u++)
        a += i[u].getTextContent();
      return a;
    }
  }
  function ft(c) {
    return c instanceof On;
  }
  function cr(c) {
    return c instanceof qt;
  }
  function Ri(c) {
    const [i, , a] = ou(c), u = a.getChildren(), p = u.length, y = u[0].getChildren().length, M = new Array(p);
    for (let $ = 0; $ < p; $++)
      M[$] = new Array(y);
    for (let $ = 0; $ < p; $++) {
      const fe = u[$].getChildren();
      let Ce = 0;
      for (let Ee = 0; Ee < fe.length; Ee++) {
        for (; M[$][Ce]; )
          Ce++;
        const xe = fe[Ee], Ne = xe.__rowSpan || 1, Ke = xe.__colSpan || 1;
        for (let Ie = 0; Ie < Ne; Ie++)
          for (let Ae = 0; Ae < Ke; Ae++)
            M[$ + Ie][Ce + Ae] = xe;
        if (i === xe)
          return {
            colSpan: Ke,
            columnIndex: Ce,
            rowIndex: $,
            rowSpan: Ne
          };
        Ce += Ke;
      }
    }
    return null;
  }
  class zn extends qt {
    constructor(i, a, u) {
      super(a, u), this.gridKey = i;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    is(i) {
      return Qn(i) ? this.gridKey === i.gridKey && this.anchor.is(i.anchor) && this.focus.is(i.focus) : false;
    }
    set(i, a, u) {
      this.dirty = true, this.gridKey = i, this.anchor.key = a, this.focus.key = u, this._cachedNodes = null;
    }
    clone() {
      return new zn(this.gridKey, this.anchor, this.focus);
    }
    isCollapsed() {
      return false;
    }
    extract() {
      return this.getNodes();
    }
    insertRawText(i) {
    }
    insertText() {
    }
    insertNodes(i) {
      const a = this.focus.getNode();
      Ni(a.select(0, a.getChildrenSize())).insertNodes(i);
    }
    // TODO Deprecate this method. It's confusing when used with colspan|rowspan
    getShape() {
      const i = gn(this.anchor.key);
      if (!Pr(i))
        throw Error("Expected GridSelection anchor to be (or a child of) GridCellNode");
      const a = Ri(i);
      if (a === null)
        throw Error("getCellRect: expected to find AnchorNode");
      const u = gn(this.focus.key);
      if (!Pr(u))
        throw Error("Expected GridSelection focus to be (or a child of) GridCellNode");
      const p = Ri(u);
      if (p === null)
        throw Error("getCellRect: expected to find focusCellNode");
      const y = Math.min(a.columnIndex, p.columnIndex), M = Math.max(a.columnIndex, p.columnIndex), $ = Math.min(a.rowIndex, p.rowIndex), le = Math.max(a.rowIndex, p.rowIndex);
      return {
        fromX: Math.min(y, M),
        fromY: Math.min($, le),
        toX: Math.max(y, M),
        toY: Math.max($, le)
      };
    }
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this.anchor.getNode(), u = this.focus.getNode(), p = No(a, Pr), y = No(u, Pr);
      if (!Pr(p))
        throw Error("Expected GridSelection anchor to be (or a child of) GridCellNode");
      if (!Pr(y))
        throw Error("Expected GridSelection focus to be (or a child of) GridCellNode");
      const M = p.getParent();
      if (!Js(M))
        throw Error("Expected anchorCell to have a parent GridRowNode");
      const $ = M.getParent();
      if (!Da($))
        throw Error("Expected tableNode to have a parent GridNode");
      const le = y.getParents()[1];
      if (le !== $) {
        if ($.isParentOf(y)) {
          const Tt = le.getParent();
          if (Tt == null)
            throw Error("Expected focusCellParent to have a parent");
          this.set(this.gridKey, y.getKey(), Tt.getKey());
        } else {
          const Tt = $.getParent();
          if (Tt == null)
            throw Error("Expected gridParent to have a parent");
          this.set(this.gridKey, Tt.getKey(), y.getKey());
        }
        return this.getNodes();
      }
      const [fe, Ce, Ee] = iu($, p, y);
      let xe = Math.min(Ce.startColumn, Ee.startColumn), Ne = Math.min(Ce.startRow, Ee.startRow), Ke = Math.max(Ce.startColumn + Ce.cell.__colSpan - 1, Ee.startColumn + Ee.cell.__colSpan - 1), Ie = Math.max(Ce.startRow + Ce.cell.__rowSpan - 1, Ee.startRow + Ee.cell.__rowSpan - 1), Ae = xe, ht = Ne, We = xe, tt = Ne;
      function Pt(Tt) {
        const {
          cell: $t,
          startColumn: Gt,
          startRow: an
        } = Tt;
        xe = Math.min(xe, Gt), Ne = Math.min(Ne, an), Ke = Math.max(Ke, Gt + $t.__colSpan - 1), Ie = Math.max(Ie, an + $t.__rowSpan - 1);
      }
      for (; xe < Ae || Ne < ht || Ke > We || Ie > tt; ) {
        if (xe < Ae) {
          const Tt = tt - ht, $t = Ae - 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[ht + Gt][$t]);
          Ae = $t;
        }
        if (Ne < ht) {
          const Tt = We - Ae, $t = ht - 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[$t][Ae + Gt]);
          ht = $t;
        }
        if (Ke > We) {
          const Tt = tt - ht, $t = We + 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[ht + Gt][$t]);
          We = $t;
        }
        if (Ie > tt) {
          const Tt = We - Ae, $t = tt + 1;
          for (let Gt = 0; Gt <= Tt; Gt++)
            Pt(fe[$t][Ae + Gt]);
          tt = $t;
        }
      }
      const Rt = [$];
      let mt = null;
      for (let Tt = Ne; Tt <= Ie; Tt++)
        for (let $t = xe; $t <= Ke; $t++) {
          const {
            cell: Gt
          } = fe[Tt][$t], an = Gt.getParent();
          if (!Js(an))
            throw Error("Expected GridCellNode parent to be a GridRowNode");
          an !== mt && Rt.push(an), Rt.push(Gt, ...xi(Gt)), mt = an;
        }
      return hs() || (this._cachedNodes = Rt), Rt;
    }
    getTextContent() {
      const i = this.getNodes();
      let a = "";
      for (let u = 0; u < i.length; u++)
        a += i[u].getTextContent();
      return a;
    }
  }
  function Qn(c) {
    return c instanceof zn;
  }
  class On extends qt {
    constructor(i, a, u, p) {
      super(i, a), this.format = u, this.style = p;
    }
    getCachedNodes() {
      return this._cachedNodes;
    }
    setCachedNodes(i) {
      this._cachedNodes = i;
    }
    /**
     * Used to check if the provided selections is equal to this one by value,
     * inluding anchor, focus, format, and style properties.
     * @param selection - the Selection to compare this one to.
     * @returns true if the Selections are equal, false otherwise.
     */
    is(i) {
      return ft(i) ? this.anchor.is(i.anchor) && this.focus.is(i.focus) && this.format === i.format && this.style === i.style : false;
    }
    /**
     * Returns whether the Selection is "collapsed", meaning the anchor and focus are
     * the same node and have the same offset.
     *
     * @returns true if the Selection is collapsed, false otherwise.
     */
    isCollapsed() {
      return this.anchor.is(this.focus);
    }
    /**
     * Gets all the nodes in the Selection. Uses caching to make it generally suitable
     * for use in hot paths.
     *
     * @returns an Array containing all the nodes in the Selection
     */
    getNodes() {
      const i = this._cachedNodes;
      if (i !== null)
        return i;
      const a = this.anchor, u = this.focus, p = a.isBefore(u), y = p ? a : u, M = p ? u : a;
      let $ = y.getNode(), le = M.getNode();
      const fe = y.offset, Ce = M.offset;
      if (Ze($)) {
        const xe = $.getDescendantByIndex(fe);
        $ = xe ?? $;
      }
      if (Ze(le)) {
        let xe = le.getDescendantByIndex(Ce);
        xe !== null && xe !== $ && le.getChildAtIndex(Ce) === xe && (xe = xe.getPreviousSibling()), le = xe ?? le;
      }
      let Ee;
      return $.is(le) ? Ze($) && $.getChildrenSize() > 0 ? Ee = [] : Ee = [$] : Ee = $.getNodesBetween(le), hs() || (this._cachedNodes = Ee), Ee;
    }
    /**
     * Sets this Selection to be of type "text" at the provided anchor and focus values.
     *
     * @param anchorNode - the anchor node to set on the Selection
     * @param anchorOffset - the offset to set on the Selection
     * @param focusNode - the focus node to set on the Selection
     * @param focusOffset - the focus offset to set on the Selection
     */
    setTextNodeRange(i, a, u, p) {
      qr(this.anchor, i.__key, a, "text"), qr(this.focus, u.__key, p, "text"), this._cachedNodes = null, this.dirty = true;
    }
    /**
     * Gets the (plain) text content of all the nodes in the selection.
     *
     * @returns a string representing the text content of all the nodes in the Selection
     */
    getTextContent() {
      const i = this.getNodes();
      if (i.length === 0)
        return "";
      const a = i[0], u = i[i.length - 1], p = this.anchor, y = this.focus, M = p.isBefore(y), [$, le] = Gn(this);
      let fe = "", Ce = true;
      for (let Ee = 0; Ee < i.length; Ee++) {
        const xe = i[Ee];
        if (Ze(xe) && !xe.isInline())
          Ce || (fe += `
`), xe.isEmpty() ? Ce = false : Ce = true;
        else if (Ce = false, dt(xe)) {
          let Ne = xe.getTextContent();
          xe === a ? xe === u ? (p.type !== "element" || y.type !== "element" || y.offset === p.offset) && (Ne = $ < le ? Ne.slice($, le) : Ne.slice(le, $)) : Ne = M ? Ne.slice($) : Ne.slice(le) : xe === u && (Ne = M ? Ne.slice(0, le) : Ne.slice(0, $)), fe += Ne;
        } else
          (yn(xe) || ui(xe)) && (xe !== u || !this.isCollapsed()) && (fe += xe.getTextContent());
      }
      return fe;
    }
    /**
     * Attempts to map a DOM selection range onto this Lexical Selection,
     * setting the anchor, focus, and type accordingly
     *
     * @param range a DOM Selection range conforming to the StaticRange interface.
     */
    applyDOMRange(i) {
      const a = ln(), p = a.getEditorState()._selection, y = eu(i.startContainer, i.startOffset, i.endContainer, i.endOffset, a, p);
      if (y === null)
        return;
      const [M, $] = y;
      qr(this.anchor, M.key, M.offset, M.type), qr(this.focus, $.key, $.offset, $.type), this._cachedNodes = null;
    }
    /**
     * Creates a new RangeSelection, copying over all the property values from this one.
     *
     * @returns a new RangeSelection with the same property values as this one.
     */
    clone() {
      const i = this.anchor, a = this.focus;
      return new On(Lr(i.key, i.offset, i.type), Lr(a.key, a.offset, a.type), this.format, this.style);
    }
    /**
     * Toggles the provided format on all the TextNodes in the Selection.
     *
     * @param format a string TextFormatType to toggle on the TextNodes in the selection
     */
    toggleFormat(i) {
      this.format = pr(this.format, i, null), this.dirty = true;
    }
    /**
     * Sets the value of the style property on the Selection
     *
     * @param style - the style to set at the value of the style property.
     */
    setStyle(i) {
      this.style = i, this.dirty = true;
    }
    /**
     * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
     * has the specified format.
     *
     * @param type the TextFormatType to check for.
     * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
     */
    hasFormat(i) {
      const a = on[i];
      return (this.format & a) !== 0;
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection.
     * converts tabs, newlines, and carriage returns into LexicalNodes.
     *
     * @param text the text to insert into the Selection
     */
    insertRawText(i) {
      const a = i.split(/(\r?\n|\t)/), u = [], p = a.length;
      for (let y = 0; y < p; y++) {
        const M = a[y];
        M === `
` || M === `\r
` ? u.push(ci()) : M === "	" ? u.push(Oi()) : u.push(Mn(M));
      }
      this.insertNodes(u);
    }
    /**
     * Attempts to insert the provided text into the EditorState at the current Selection as a new
     * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
     *
     * @param text the text to insert into the Selection
     */
    insertText(i) {
      const a = this.anchor, u = this.focus, p = this.isCollapsed() || a.isBefore(u), y = this.format, M = this.style;
      p && a.type === "element" ? qs(a, u, y, M) : !p && u.type === "element" && qs(u, a, y, M);
      const $ = this.getNodes(), le = $.length, fe = p ? a : u, Ce = p ? u : a, Ee = fe.offset, xe = Ce.offset;
      let Ne = $[0];
      if (!dt(Ne))
        throw Error("insertText: first node is not a text node");
      const Ie = Ne.getTextContent().length, Ae = Ne.getParentOrThrow(), ht = le - 1;
      let We = $[ht];
      if (this.isCollapsed() && Ee === Ie && (Ne.isSegmented() || Ne.isToken() || !Ne.canInsertTextAfter() || !Ae.canInsertTextAfter() && Ne.getNextSibling() === null)) {
        let tt = Ne.getNextSibling();
        if ((!dt(tt) || !tt.canInsertTextBefore() || Os(tt)) && (tt = Mn(), tt.setFormat(y), Ae.canInsertTextAfter() ? Ne.insertAfter(tt) : Ae.insertAfter(tt)), tt.select(0, 0), Ne = tt, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (this.isCollapsed() && Ee === 0 && (Ne.isSegmented() || Ne.isToken() || !Ne.canInsertTextBefore() || !Ae.canInsertTextBefore() && Ne.getPreviousSibling() === null)) {
        let tt = Ne.getPreviousSibling();
        if ((!dt(tt) || Os(tt)) && (tt = Mn(), tt.setFormat(y), Ae.canInsertTextBefore() ? Ne.insertBefore(tt) : Ae.insertBefore(tt)), tt.select(), Ne = tt, i !== "") {
          this.insertText(i);
          return;
        }
      } else if (Ne.isSegmented() && Ee !== Ie) {
        const tt = Mn(Ne.getTextContent());
        tt.setFormat(y), Ne.replace(tt), Ne = tt;
      } else if (!this.isCollapsed() && i !== "") {
        const tt = We.getParent();
        if (!Ae.canInsertTextBefore() || !Ae.canInsertTextAfter() || Ze(tt) && (!tt.canInsertTextBefore() || !tt.canInsertTextAfter())) {
          this.insertText(""), Qc(this.anchor, this.focus, null), this.insertText(i);
          return;
        }
      }
      if (le === 1) {
        if (Ne.isToken()) {
          const mt = Mn(i);
          mt.select(), Ne.replace(mt);
          return;
        }
        const tt = Ne.getFormat(), Pt = Ne.getStyle();
        if (Ee === xe && (tt !== y || Pt !== M))
          if (Ne.getTextContent() === "")
            Ne.setFormat(y), Ne.setStyle(M);
          else {
            const mt = Mn(i);
            if (mt.setFormat(y), mt.setStyle(M), mt.select(), Ee === 0)
              Ne.insertBefore(mt, false);
            else {
              const [Tt] = Ne.splitText(Ee);
              Tt.insertAfter(mt, false);
            }
            mt.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
            return;
          }
        else if (Ao(Ne)) {
          const mt = Mn(i);
          mt.setFormat(y), mt.setStyle(M), mt.select(), Ne.replace(mt);
          return;
        }
        const Rt = xe - Ee;
        Ne = Ne.spliceText(Ee, Rt, i, true), Ne.getTextContent() === "" ? Ne.remove() : this.anchor.type === "text" && (Ne.isComposing() ? this.anchor.offset -= i.length : (this.format = tt, this.style = Pt));
      } else {
        const tt = /* @__PURE__ */ new Set([...Ne.getParentKeys(), ...We.getParentKeys()]), Pt = Ze(Ne) ? Ne : Ne.getParentOrThrow();
        let Rt = Ze(We) ? We : We.getParentOrThrow(), mt = We;
        if (!Pt.is(Rt) && Rt.isInline())
          do
            mt = Rt, Rt = Rt.getParentOrThrow();
          while (Rt.isInline());
        if (Ce.type === "text" && (xe !== 0 || We.getTextContent() === "") || Ce.type === "element" && We.getIndexWithinParent() < xe)
          if (dt(We) && !We.isToken() && xe !== We.getTextContentSize()) {
            if (We.isSegmented()) {
              const zt = Mn(We.getTextContent());
              We.replace(zt), We = zt;
            }
            !Er(Ce.getNode()) && Ce.type === "text" && (We = We.spliceText(0, xe, "")), tt.add(We.__key);
          } else {
            const zt = We.getParentOrThrow();
            !zt.canBeEmpty() && zt.getChildrenSize() === 1 ? zt.remove() : We.remove();
          }
        else
          tt.add(We.__key);
        const Tt = Rt.getChildren(), $t = new Set($), Gt = Pt.is(Rt), an = Pt.isInline() && Ne.getNextSibling() === null ? Pt : Ne;
        for (let zt = Tt.length - 1; zt >= 0; zt--) {
          const Nn = Tt[zt];
          if (Nn.is(Ne) || Ze(Nn) && Nn.isParentOf(Ne))
            break;
          Nn.isAttached() && (!$t.has(Nn) || Nn.is(mt) ? Gt || an.insertAfter(Nn, false) : Nn.remove());
        }
        if (!Gt) {
          let zt = Rt, Nn = null;
          for (; zt !== null; ) {
            const Vr = zt.getChildren(), bi = Vr.length;
            (bi === 0 || Vr[bi - 1].is(Nn)) && (tt.delete(zt.__key), Nn = zt), zt = zt.getParent();
          }
        }
        if (!Ne.isToken())
          Ne = Ne.spliceText(Ee, Ie - Ee, i, true), Ne.getTextContent() === "" ? Ne.remove() : Ne.isComposing() && this.anchor.type === "text" && (this.anchor.offset -= i.length);
        else if (Ee === Ie)
          Ne.select();
        else {
          const zt = Mn(i);
          zt.select(), Ne.replace(zt);
        }
        for (let zt = 1; zt < le; zt++) {
          const Nn = $[zt], Vr = Nn.__key;
          tt.has(Vr) || Nn.remove();
        }
      }
    }
    /**
     * Removes the text in the Selection, adjusting the EditorState accordingly.
     */
    removeText() {
      this.insertText("");
    }
    /**
     * Applies the provided format to the TextNodes in the Selection, splitting or
     * merging nodes as necessary.
     *
     * @param formatType the format type to apply to the nodes in the Selection.
     */
    formatText(i) {
      if (this.isCollapsed()) {
        this.toggleFormat(i), un(null);
        return;
      }
      const a = this.getNodes(), u = [];
      for (const We of a)
        dt(We) && u.push(We);
      const p = u.length;
      if (p === 0) {
        this.toggleFormat(i), un(null);
        return;
      }
      const y = this.anchor, M = this.focus, $ = this.isBackward(), le = $ ? M : y, fe = $ ? y : M;
      let Ce = 0, Ee = u[0], xe = le.type === "element" ? 0 : le.offset;
      if (le.type === "text" && xe === Ee.getTextContentSize() && (Ce = 1, Ee = u[1], xe = 0), Ee == null)
        return;
      const Ne = Ee.getFormatFlags(i, null), Ke = p - 1;
      let Ie = u[Ke];
      const Ae = fe.type === "text" ? fe.offset : Ie.getTextContentSize();
      if (Ee.is(Ie)) {
        if (xe === Ae)
          return;
        if (xe === 0 && Ae === Ee.getTextContentSize())
          Ee.setFormat(Ne);
        else {
          const We = Ee.splitText(xe, Ae), tt = xe === 0 ? We[0] : We[1];
          tt.setFormat(Ne), le.type === "text" && le.set(tt.__key, 0, "text"), fe.type === "text" && fe.set(tt.__key, Ae - xe, "text");
        }
        this.format = Ne;
        return;
      }
      xe !== 0 && ([, Ee] = Ee.splitText(xe), xe = 0), Ee.setFormat(Ne);
      const ht = Ie.getFormatFlags(i, Ne);
      Ae > 0 && (Ae !== Ie.getTextContentSize() && ([Ie] = Ie.splitText(Ae)), Ie.setFormat(ht));
      for (let We = Ce + 1; We < Ke; We++) {
        const tt = u[We];
        if (!tt.isToken()) {
          const Pt = tt.getFormatFlags(i, ht);
          tt.setFormat(Pt);
        }
      }
      le.type === "text" && le.set(Ee.__key, xe, "text"), fe.type === "text" && fe.set(Ie.__key, Ae, "text"), this.format = Ne | ht;
    }
    /**
     * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
     * current Selection according to a set of heuristics that determine how surrounding nodes
     * should be changed, replaced, or moved to accomodate the incoming ones.
     *
     * @param nodes - the nodes to insert
     */
    insertNodes(i) {
      if (i.length === 0)
        return;
      if (this.anchor.key === "root") {
        this.insertParagraph();
        const Ae = en();
        if (!ft(Ae))
          throw Error("Expected RangeSelection after insertParagraph");
        return Ae.insertNodes(i);
      }
      const a = ts(this.anchor.getNode(), vi), u = i[i.length - 1];
      if ("__language" in a) {
        if ("__language" in i[0])
          this.insertText(i[0].getTextContent());
        else {
          const Ae = xa(this);
          a.splice(Ae, 0, i), u.selectEnd();
        }
        return;
      }
      const p = (Ae) => (Ze(Ae) || yn(Ae)) && !Ae.isInline();
      if (!i.some(p)) {
        const Ae = xa(this);
        a.splice(Ae, 0, i), u.selectEnd();
        return;
      }
      const y = ng(i), M = y.getLastDescendant(), $ = y.getChildren(), le = (Ae) => "__value" in Ae && "__checked" in Ae, fe = (Ae) => Ze(Ae) && vi(Ae) && !Ae.isEmpty() && Ze(a) && (!a.isEmpty() || le(a)), Ee = !Ze(a) || !a.isEmpty() ? this.insertParagraph() : null, xe = $[$.length - 1];
      let Ne = $[0];
      fe(Ne) && (a.append(...Ne.getChildren()), Ne = $[1]), Ne && Xn(a, Ne);
      const Ke = ts(M, vi);
      Ee && Ze(Ke) && (le(Ee) || vi(xe)) && (Ke.append(...Ee.getChildren()), Ee.remove()), Ze(a) && a.isEmpty() && a.remove(), M.selectEnd();
      const Ie = Ze(a) ? a.getLastChild() : null;
      ui(Ie) && Ke !== a && Ie.remove();
    }
    /**
     * Inserts a new ParagraphNode into the EditorState at the current Selection
     *
     * @returns the newly inserted node.
     */
    insertParagraph() {
      if (this.anchor.key === "root") {
        const M = Ai();
        return Hn().splice(this.anchor.offset, 0, [M]), M.select(), M;
      }
      const i = xa(this), a = ts(this.anchor.getNode(), vi), u = a.getChildAtIndex(i), p = u ? [u, ...u.getNextSiblings()] : [], y = a.insertNewAfter(this, false);
      return y ? (y.append(...p), y.selectStart(), y) : null;
    }
    /**
     * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
     * current Selection.
     */
    insertLineBreak(i) {
      const a = ci();
      if (this.insertNodes([a]), i) {
        const u = a.getParentOrThrow(), p = a.getIndexWithinParent();
        u.select(p, p);
      }
    }
    /**
     * Extracts the nodes in the Selection, splitting nodes where necessary
     * to get offset-level precision.
     *
     * @returns The nodes in the Selection
     */
    extract() {
      const i = this.getNodes(), a = i.length, u = a - 1, p = this.anchor, y = this.focus;
      let M = i[0], $ = i[u];
      const [le, fe] = Gn(this);
      if (a === 0)
        return [];
      if (a === 1) {
        if (dt(M) && !this.isCollapsed()) {
          const Ee = le > fe ? fe : le, xe = le > fe ? le : fe, Ne = M.splitText(Ee, xe), Ke = Ee === 0 ? Ne[0] : Ne[1];
          return Ke != null ? [Ke] : [];
        }
        return [M];
      }
      const Ce = p.isBefore(y);
      if (dt(M)) {
        const Ee = Ce ? le : fe;
        Ee === M.getTextContentSize() ? i.shift() : Ee !== 0 && ([, M] = M.splitText(Ee), i[0] = M);
      }
      if (dt($)) {
        const xe = $.getTextContent().length, Ne = Ce ? fe : le;
        Ne === 0 ? i.pop() : Ne !== xe && ([$] = $.splitText(Ne), i[u] = $);
      }
      return i;
    }
    /**
     * Modifies the Selection according to the parameters and a set of heuristics that account for
     * various node types. Can be used to safely move or extend selection by one logical "unit" without
     * dealing explicitly with all the possible node types.
     *
     * @param alter the type of modification to perform
     * @param isBackward whether or not selection is backwards
     * @param granularity the granularity at which to apply the modification
     */
    modify(i, a, u) {
      const p = this.focus, y = this.anchor, M = i === "move", $ = zr(p, a);
      if (yn($) && !$.isIsolated()) {
        if (M && $.isKeyboardSelectable()) {
          const Ne = Ea();
          Ne.add($.__key), _r(Ne);
          return;
        }
        const xe = a ? $.getPreviousSibling() : $.getNextSibling();
        if (dt(xe)) {
          const Ne = xe.__key, Ke = a ? xe.getTextContent().length : 0;
          p.set(Ne, Ke, "text"), M && y.set(Ne, Ke, "text");
          return;
        } else {
          const Ne = $.getParentOrThrow();
          let Ke, Ie;
          Ze(xe) ? (Ie = xe.__key, Ke = a ? xe.getChildrenSize() : 0) : (Ke = $.getIndexWithinParent(), Ie = Ne.__key, a || Ke++), p.set(Ie, Ke, "element"), M && y.set(Ie, Ke, "element");
          return;
        }
      }
      const le = ln(), fe = sr(le._window);
      if (!fe)
        return;
      const Ce = le._blockCursorElement, Ee = le._rootElement;
      if (Ee !== null && Ce !== null && Ze($) && !$.isInline() && !$.canBeEmpty() && vt(Ce, le, Ee), ds(fe, i, a ? "backward" : "forward", u), fe.rangeCount > 0) {
        const xe = fe.getRangeAt(0), Ne = this.anchor.getNode(), Ke = Er(Ne) ? Ne : mr(Ne);
        if (this.applyDOMRange(xe), this.dirty = true, !M) {
          const Ie = this.getNodes(), Ae = [];
          let ht = false;
          for (let We = 0; We < Ie.length; We++) {
            const tt = Ie[We];
            ut(tt, Ke) ? Ae.push(tt) : ht = true;
          }
          if (ht && Ae.length > 0)
            if (a) {
              const We = Ae[0];
              Ze(We) ? We.selectStart() : We.getParentOrThrow().selectStart();
            } else {
              const We = Ae[Ae.length - 1];
              Ze(We) ? We.selectEnd() : We.getParentOrThrow().selectEnd();
            }
          (fe.anchorNode !== xe.startContainer || fe.anchorOffset !== xe.startOffset) && Di(this);
        }
      }
    }
    /**
     * Performs one logical character deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteCharacter(i) {
      const a = this.isCollapsed();
      if (this.isCollapsed()) {
        const u = this.anchor, p = this.focus;
        let y = u.getNode();
        if (!i && // Delete forward handle case
        (u.type === "element" && Ze(y) && u.offset === y.getChildrenSize() || u.type === "text" && u.offset === y.getTextContentSize())) {
          const $ = y.getParent(), le = y.getNextSibling() || ($ === null ? null : $.getNextSibling());
          if (Ze(le) && le.isShadowRoot())
            return;
        }
        const M = zr(p, i);
        if (yn(M) && !M.isIsolated()) {
          if (M.isKeyboardSelectable() && Ze(y) && y.getChildrenSize() === 0) {
            y.remove();
            const $ = Ea();
            $.add(M.__key), _r($);
          } else
            M.remove(), ln().dispatchCommand(t, void 0);
          return;
        } else if (!i && Ze(M) && Ze(y) && y.isEmpty()) {
          y.remove(), M.selectStart();
          return;
        }
        if (this.modify("extend", i, "character"), this.isCollapsed()) {
          if (i && u.offset === 0 && (u.type === "element" ? u.getNode() : u.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        } else {
          const $ = p.type === "text" ? p.getNode() : null;
          if (y = u.type === "text" ? u.getNode() : null, $ !== null && $.isSegmented()) {
            const le = p.offset, fe = $.getTextContentSize();
            if ($.is(y) || i && le !== fe || !i && le !== 0) {
              Jc($, i, le);
              return;
            }
          } else if (y !== null && y.isSegmented()) {
            const le = u.offset, fe = y.getTextContentSize();
            if (y.is($) || i && le !== 0 || !i && le !== fe) {
              Jc(y, i, le);
              return;
            }
          }
          Wl(this, i);
        }
      }
      if (this.removeText(), i && !a && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
        const u = this.anchor.getNode();
        u.isEmpty() && Er(u.getParent()) && u.getIndexWithinParent() === 0 && u.collapseAtStart(this);
      }
    }
    /**
     * Performs one logical line deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteLine(i) {
      this.isCollapsed() && (this.anchor.type === "text" && this.modify("extend", i, "lineboundary"), (i ? this.focus : this.anchor).offset === 0 && this.modify("extend", i, "character")), this.removeText();
    }
    /**
     * Performs one logical word deletion operation on the EditorState based on the current Selection.
     * Handles different node types.
     *
     * @param isBackward whether or not the selection is backwards.
     */
    deleteWord(i) {
      this.isCollapsed() && this.modify("extend", i, "word"), this.removeText();
    }
  }
  function ur(c) {
    return c instanceof wn;
  }
  function hi(c) {
    const i = c.offset;
    if (c.type === "text")
      return i;
    const a = c.getNode();
    return i === a.getChildrenSize() ? a.getTextContent().length : 0;
  }
  function Gn(c) {
    const i = c.anchor, a = c.focus;
    return i.type === "element" && a.type === "element" && i.key === a.key && i.offset === a.offset ? [0, 0] : [hi(i), hi(a)];
  }
  function Di(c) {
    const i = c.focus, a = c.anchor, u = a.key, p = a.offset, y = a.type;
    qr(a, i.key, i.offset, i.type), qr(i, u, p, y), c._cachedNodes = null;
  }
  function ds(c, i, a, u) {
    c.modify(i, a, u);
  }
  function Wl(c, i) {
    const a = c.anchor, u = c.focus, p = a.getNode(), y = u.getNode();
    if (p === y && a.type === "text" && u.type === "text") {
      const M = a.offset, $ = u.offset, le = M < $, fe = le ? M : $, Ce = le ? $ : M, Ee = Ce - 1;
      if (fe !== Ee) {
        const xe = p.getTextContent().slice(fe, Ce);
        Rs(xe) || (i ? u.offset = Ee : a.offset = Ee);
      }
    }
  }
  function Jc(c, i, a) {
    const u = c, y = u.getTextContent().split(/(?=\s)/g), M = y.length;
    let $ = 0, le = 0;
    for (let Ce = 0; Ce < M; Ce++) {
      const Ee = y[Ce], xe = Ce === M - 1;
      if (le = $, $ += Ee.length, i && $ === a || $ > a || xe) {
        y.splice(Ce, 1), xe && (le = void 0);
        break;
      }
    }
    const fe = y.join("").trim();
    fe === "" ? u.remove() : (u.setTextContent(fe), u.select(le, le));
  }
  function jh(c, i, a) {
    const u = c.getParent();
    return a === null || u === null || !u.canBeEmpty() || u !== a.getNode();
  }
  function Zc(c, i, a, u) {
    let p = i, y;
    if (c.nodeType === Be) {
      let M = false;
      const $ = c.childNodes, le = $.length;
      p === le && (M = true, p = le - 1);
      let fe = $[p], Ce = false;
      if (fe === u._blockCursorElement ? (fe = $[p + 1], Ce = true) : u._blockCursorElement !== null && p--, y = Hr(fe), dt(y))
        p = Vo(y, M);
      else {
        let Ee = Hr(c);
        if (Ee === null)
          return null;
        if (Ze(Ee)) {
          let xe = Ee.getChildAtIndex(p);
          if (Ze(xe) && jh(xe, p, a)) {
            const Ne = M ? xe.getLastDescendant() : xe.getFirstDescendant();
            Ne === null ? (Ee = xe, p = 0) : (xe = Ne, Ee = Ze(xe) ? xe : xe.getParentOrThrow());
          }
          dt(xe) ? (y = xe, Ee = null, p = Vo(xe, M)) : xe !== Ee && M && !Ce && p++;
        } else {
          const xe = Ee.getIndexWithinParent();
          i === 0 && yn(Ee) && Hr(c) === Ee ? p = xe : p = xe + 1, Ee = Ee.getParentOrThrow();
        }
        if (Ze(Ee))
          return Lr(Ee.__key, p, "element");
      }
    } else
      y = Hr(c);
    return dt(y) ? Lr(y.__key, p, "text") : null;
  }
  function Xc(c, i, a) {
    const u = c.offset, p = c.getNode();
    if (u === 0) {
      const y = p.getPreviousSibling(), M = p.getParent();
      if (!i)
        Ze(y) && !a && y.isInline() ? (c.key = y.__key, c.offset = y.getChildrenSize(), c.type = "element") : dt(y) && (c.key = y.__key, c.offset = y.getTextContent().length);
      else if ((a || !i) && y === null && Ze(M) && M.isInline()) {
        const $ = M.getPreviousSibling();
        dt($) && (c.key = $.__key, c.offset = $.getTextContent().length);
      }
    } else if (u === p.getTextContent().length) {
      const y = p.getNextSibling(), M = p.getParent();
      if (i && Ze(y) && y.isInline())
        c.key = y.__key, c.offset = 0, c.type = "element";
      else if ((a || i) && y === null && Ze(M) && M.isInline() && !M.canInsertTextAfter()) {
        const $ = M.getNextSibling();
        dt($) && (c.key = $.__key, c.offset = 0);
      }
    }
  }
  function Qc(c, i, a) {
    if (c.type === "text" && i.type === "text") {
      const u = c.isBefore(i), p = c.is(i);
      Xc(c, u, p), Xc(i, !u, p), p && (i.key = c.key, i.offset = c.offset, i.type = c.type);
      const y = ln();
      if (y.isComposing() && y._compositionKey !== c.key && ft(a)) {
        const M = a.anchor, $ = a.focus;
        qr(c, M.key, M.offset, M.type), qr(i, $.key, $.offset, $.type);
      }
    }
  }
  function eu(c, i, a, u, p, y) {
    if (c === null || a === null || !Kr(p, c, a))
      return null;
    const M = Zc(c, i, ft(y) ? y.anchor : null, p);
    if (M === null)
      return null;
    const $ = Zc(a, u, ft(y) ? y.focus : null, p);
    if ($ === null)
      return null;
    if (M.type === "element" && $.type === "element") {
      const le = Hr(c), fe = Hr(a);
      if (yn(le) && yn(fe))
        return null;
    }
    return Qc(M, $, y), [M, $];
  }
  function qh(c) {
    return Ze(c) && !c.isInline();
  }
  function tu(c, i, a, u, p, y) {
    const M = gi(), $ = new On(Lr(c, i, p), Lr(a, u, y), 0, "");
    return $.dirty = true, M._selection = $, $;
  }
  function Vh() {
    const c = Lr("root", 0, "element"), i = Lr("root", 0, "element");
    return new On(c, i, 0, "");
  }
  function Ea() {
    return new wn(/* @__PURE__ */ new Set());
  }
  function Jh() {
    const c = Lr("root", 0, "element"), i = Lr("root", 0, "element");
    return new zn("root", c, i);
  }
  function Zh(c) {
    const a = c.getEditorState()._selection, u = sr(c._window);
    return ft(a) || a == null ? Ta(a, u, c) : a.clone();
  }
  function Ta(c, i, a) {
    const u = a._window;
    if (u === null)
      return null;
    const p = u.event, y = p ? p.type : void 0, M = y === "selectionchange", $ = !Ft() && (M || y === "beforeinput" || y === "compositionstart" || y === "compositionend" || y === "click" && p && p.detail === 3 || y === "drop" || y === void 0);
    let le, fe, Ce, Ee;
    if (!ft(c) || $) {
      if (i === null)
        return null;
      if (le = i.anchorNode, fe = i.focusNode, Ce = i.anchorOffset, Ee = i.focusOffset, M && ft(c) && !Kr(a, le, fe))
        return c.clone();
    } else
      return c.clone();
    const xe = eu(le, Ce, fe, Ee, a, c);
    if (xe === null)
      return null;
    const [Ne, Ke] = xe;
    return new On(Ne, Ke, ft(c) ? c.format : 0, ft(c) ? c.style : "");
  }
  function en() {
    return gi()._selection;
  }
  function fs() {
    return ln()._editorState._selection;
  }
  function zl(c, i, a, u = 1) {
    const p = c.anchor, y = c.focus, M = p.getNode(), $ = y.getNode();
    if (!i.is(M) && !i.is($))
      return;
    const le = i.__key;
    if (c.isCollapsed()) {
      const fe = p.offset;
      if (a <= fe && u > 0 || a < fe && u < 0) {
        const Ce = Math.max(0, fe + u);
        p.set(le, Ce, "element"), y.set(le, Ce, "element"), nu(c);
      }
    } else {
      const fe = c.isBackward(), Ce = fe ? y : p, Ee = Ce.getNode(), xe = fe ? p : y, Ne = xe.getNode();
      if (i.is(Ee)) {
        const Ke = Ce.offset;
        (a <= Ke && u > 0 || a < Ke && u < 0) && Ce.set(le, Math.max(0, Ke + u), "element");
      }
      if (i.is(Ne)) {
        const Ke = xe.offset;
        (a <= Ke && u > 0 || a < Ke && u < 0) && xe.set(le, Math.max(0, Ke + u), "element");
      }
    }
    nu(c);
  }
  function nu(c) {
    const i = c.anchor, a = i.offset, u = c.focus, p = u.offset, y = i.getNode(), M = u.getNode();
    if (c.isCollapsed()) {
      if (!Ze(y))
        return;
      const $ = y.getChildrenSize(), le = a >= $, fe = le ? y.getChildAtIndex($ - 1) : y.getChildAtIndex(a);
      if (dt(fe)) {
        let Ce = 0;
        le && (Ce = fe.getTextContentSize()), i.set(fe.__key, Ce, "text"), u.set(fe.__key, Ce, "text");
      }
      return;
    }
    if (Ze(y)) {
      const $ = y.getChildrenSize(), le = a >= $, fe = le ? y.getChildAtIndex($ - 1) : y.getChildAtIndex(a);
      if (dt(fe)) {
        let Ce = 0;
        le && (Ce = fe.getTextContentSize()), i.set(fe.__key, Ce, "text");
      }
    }
    if (Ze(M)) {
      const $ = M.getChildrenSize(), le = p >= $, fe = le ? M.getChildAtIndex($ - 1) : M.getChildAtIndex(p);
      if (dt(fe)) {
        let Ce = 0;
        le && (Ce = fe.getTextContentSize()), u.set(fe.__key, Ce, "text");
      }
    }
  }
  function Xh(c, i) {
    const u = i.getEditorState()._selection, p = c._selection;
    if (ft(p)) {
      const y = p.anchor, M = p.focus;
      let $;
      if (y.type === "text" && ($ = y.getNode(), $.selectionTransform(u, p)), M.type === "text") {
        const le = M.getNode();
        $ !== le && le.selectionTransform(u, p);
      }
    }
  }
  function Gl(c, i, a, u, p) {
    let y = null, M = 0, $ = null;
    u !== null ? (y = u.__key, dt(u) ? (M = u.getTextContentSize(), $ = "text") : Ze(u) && (M = u.getChildrenSize(), $ = "element")) : p !== null && (y = p.__key, dt(p) ? $ = "text" : Ze(p) && ($ = "element")), y !== null && $ !== null ? c.set(y, M, $) : (M = i.getIndexWithinParent(), M === -1 && (M = a.getChildrenSize()), c.set(a.__key, M, "element"));
  }
  function ru(c, i, a, u, p) {
    c.type === "text" ? (c.key = a, i || (c.offset += p)) : c.offset > u.getIndexWithinParent() && (c.offset -= 1);
  }
  function Qh(c, i, a, u, p, y, M) {
    const $ = u.anchorNode, le = u.focusNode, fe = u.anchorOffset, Ce = u.focusOffset, Ee = document.activeElement;
    if (p.has("collaboration") && Ee !== y || Ee !== null && Bi(Ee))
      return;
    if (!ft(i)) {
      c !== null && Kr(a, $, le) && u.removeAllRanges();
      return;
    }
    const xe = i.anchor, Ne = i.focus, Ke = xe.key, Ie = Ne.key, Ae = Xo(a, Ke), ht = Xo(a, Ie), We = xe.offset, tt = Ne.offset, Pt = i.format, Rt = i.style, mt = i.isCollapsed();
    let Tt = Ae, $t = ht, Gt = false;
    if (xe.type === "text") {
      Tt = Sn(Ae);
      const an = xe.getNode();
      Gt = an.getFormat() !== Pt || an.getStyle() !== Rt;
    } else
      ft(c) && c.anchor.type === "text" && (Gt = true);
    if (Ne.type === "text" && ($t = Sn(ht)), !(Tt === null || $t === null) && (mt && (c === null || Gt || ft(c) && (c.format !== Pt || c.style !== Rt)) && lt(Pt, Rt, We, Ke, performance.now()), !(fe === We && Ce === tt && $ === Tt && le === $t && // Badly interpreted range selection when collapsed - #1482
    !(u.type === "Range" && mt) && ((Ee === null || !y.contains(Ee)) && y.focus({
      preventScroll: true
    }), xe.type !== "element")))) {
      try {
        u.setBaseAndExtent(Tt, We, $t, tt);
      } catch {
      }
      if (!p.has("skip-scroll-into-view") && i.isCollapsed() && y !== null && y === document.activeElement) {
        const an = i instanceof On && i.anchor.type === "element" ? Tt.childNodes[We] || null : u.rangeCount > 0 ? u.getRangeAt(0) : null;
        if (an !== null) {
          let zt;
          if (an instanceof Text) {
            const Nn = document.createRange();
            Nn.selectNode(an), zt = Nn.getBoundingClientRect();
          } else
            zt = an.getBoundingClientRect();
          Sl(a, zt, y);
        }
      }
      Xe();
    }
  }
  function eg(c) {
    let i = en() || fs();
    i === null && (i = Hn().selectEnd()), i.insertNodes(c);
  }
  function tg() {
    const c = en();
    return c === null ? "" : c.getTextContent();
  }
  function iu(c, i, a) {
    const u = [];
    let p = null, y = null;
    function M(fe, Ce, Ee) {
      const xe = {
        cell: Ee,
        startColumn: Ce,
        startRow: fe
      }, Ne = Ee.__rowSpan, Ke = Ee.__colSpan;
      for (let Ie = 0; Ie < Ne; Ie++) {
        u[fe + Ie] === void 0 && (u[fe + Ie] = []);
        for (let Ae = 0; Ae < Ke; Ae++)
          u[fe + Ie][Ce + Ae] = xe;
      }
      i.is(Ee) && (p = xe), a.is(Ee) && (y = xe);
    }
    function $(fe, Ce) {
      return u[fe] === void 0 || u[fe][Ce] === void 0;
    }
    const le = c.getChildren();
    for (let fe = 0; fe < le.length; fe++) {
      const Ce = le[fe];
      if (!Js(Ce))
        throw Error("Expected GridNode children to be GridRowNode");
      const Ee = Ce.getChildren();
      let xe = 0;
      for (const Ne of Ee) {
        if (!Pr(Ne))
          throw Error("Expected GridRowNode children to be GridCellNode");
        for (; !$(fe, xe); )
          xe++;
        M(fe, xe, Ne), xe += Ne.__colSpan;
      }
    }
    if (p === null)
      throw Error("Anchor not found in Grid");
    if (y === null)
      throw Error("Focus not found in Grid");
    return [u, p, y];
  }
  function ou(c) {
    let i;
    if (c instanceof Ra)
      i = c;
    else if (c instanceof Ot) {
      const p = No(c, Pr);
      if (!Pr(p))
        throw Error("Expected to find a parent GridCellNode");
      i = p;
    } else {
      const p = No(c.getNode(), Pr);
      if (!Pr(p))
        throw Error("Expected to find a parent GridCellNode");
      i = p;
    }
    const a = i.getParent();
    if (!Js(a))
      throw Error("Expected GridCellNode to have a parent GridRowNode");
    const u = a.getParent();
    if (!Da(u))
      throw Error("Expected GridRowNode to have a parent GridNode");
    return [i, a, u];
  }
  function xa(c) {
    c.isCollapsed() || c.removeText();
    const i = c.anchor, a = i.getNode();
    if (!dt(a))
      return i.offset;
    const u = a.getParent();
    if (!u) {
      const le = Ai();
      return Hn().append(le), le.select(), 0;
    }
    const p = a.splitText(i.offset);
    if (p.length === 0)
      return 0;
    const y = i.offset === 0 ? 0 : 1, M = p[0].getIndexWithinParent() + y;
    if (!u.isInline() || M === 0)
      return M;
    const $ = u.getChildAtIndex(M);
    return $ && u.insertNewAfter(c).append($, ...$.getNextSiblings()), u.getIndexWithinParent() + y;
  }
  function ng(c) {
    const i = Ai();
    let a = null;
    for (let u = 0; u < c.length; u++) {
      const p = c[u], y = ui(p);
      if (y || yn(p) && p.isInline() || Ze(p) && p.isInline() || dt(p) || p.isParentRequired()) {
        if (a === null && (a = p.createParentElementNode(), i.append(a), y))
          continue;
        a !== null && a.append(p);
      } else
        i.append(p), a = null;
    }
    return i;
  }
  let Fn = null, Bn = null, dr = false, va = false, Yl = 0;
  const su = {
    characterData: true,
    childList: true,
    subtree: true
  };
  function hs() {
    return dr || Fn !== null && Fn._readOnly;
  }
  function jn() {
    if (dr)
      throw Error("Cannot use method in read-only mode.");
  }
  function lu() {
    if (Yl > 99)
      throw Error("One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.");
  }
  function gi() {
    if (Fn === null)
      throw Error("Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().");
    return Fn;
  }
  function ln() {
    if (Bn === null)
      throw Error("Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().");
    return Bn;
  }
  function rg() {
    return Bn;
  }
  function au(c, i, a) {
    const u = i.__type, p = xr(c, u);
    let y = a.get(u);
    y === void 0 && (y = Array.from(p.transforms), a.set(u, y));
    const M = y.length;
    for (let $ = 0; $ < M && (y[$](i), !!i.isAttached()); $++)
      ;
  }
  function cu(c, i) {
    return c !== void 0 && // We don't want to transform nodes being composed
    c.__key !== i && c.isAttached();
  }
  function ig(c, i) {
    const a = i._dirtyLeaves, u = c._nodeMap;
    for (const p of a) {
      const y = u.get(p);
      dt(y) && y.isAttached() && y.isSimpleText() && !y.isUnmergeable() && vs(y);
    }
  }
  function og(c, i) {
    const a = i._dirtyLeaves, u = i._dirtyElements, p = c._nodeMap, y = vr(), M = /* @__PURE__ */ new Map();
    let $ = a, le = $.size, fe = u, Ce = fe.size;
    for (; le > 0 || Ce > 0; ) {
      if (le > 0) {
        i._dirtyLeaves = /* @__PURE__ */ new Set();
        for (const Ee of $) {
          const xe = p.get(Ee);
          dt(xe) && xe.isAttached() && xe.isSimpleText() && !xe.isUnmergeable() && vs(xe), xe !== void 0 && cu(xe, y) && au(i, xe, M), a.add(Ee);
        }
        if ($ = i._dirtyLeaves, le = $.size, le > 0) {
          Yl++;
          continue;
        }
      }
      i._dirtyLeaves = /* @__PURE__ */ new Set(), i._dirtyElements = /* @__PURE__ */ new Map();
      for (const Ee of fe) {
        const xe = Ee[0], Ne = Ee[1];
        if (xe !== "root" && !Ne)
          continue;
        const Ke = p.get(xe);
        Ke !== void 0 && cu(Ke, y) && au(i, Ke, M), u.set(xe, Ne);
      }
      $ = i._dirtyLeaves, le = $.size, fe = i._dirtyElements, Ce = fe.size, Yl++;
    }
    i._dirtyLeaves = a, i._dirtyElements = u;
  }
  function sg(c) {
    return Sa(c, ln()._nodes);
  }
  function Sa(c, i) {
    const a = c.type, u = i.get(a);
    if (u === void 0)
      throw Error(`parseEditorState: type "${a}" + not found`);
    const p = u.klass;
    if (c.type !== p.getType())
      throw Error(`LexicalNode: Node ${p.name} does not implement .importJSON().`);
    const y = p.importJSON(c), M = c.children;
    if (Ze(y) && Array.isArray(M))
      for (let $ = 0; $ < M.length; $++) {
        const le = M[$], fe = Sa(le, i);
        y.append(fe);
      }
    return y;
  }
  function lg(c, i, a) {
    const u = Oa(), p = Fn, y = dr, M = Bn, $ = i._dirtyElements, le = i._dirtyLeaves, fe = i._cloneNotNeeded, Ce = i._dirtyType;
    i._dirtyElements = /* @__PURE__ */ new Map(), i._dirtyLeaves = /* @__PURE__ */ new Set(), i._cloneNotNeeded = /* @__PURE__ */ new Set(), i._dirtyType = 0, Fn = u, dr = false, Bn = i;
    try {
      const Ee = i._nodes, xe = c.root;
      Sa(xe, Ee), a && a(), u._readOnly = true, du(u);
    } catch (Ee) {
      Ee instanceof Error && i._onError(Ee);
    } finally {
      i._dirtyElements = $, i._dirtyLeaves = le, i._cloneNotNeeded = fe, i._dirtyType = Ce, Fn = p, dr = y, Bn = M;
    }
    return u;
  }
  function uu(c, i) {
    const a = Fn, u = dr, p = Bn;
    Fn = c, dr = true, Bn = null;
    try {
      return i();
    } finally {
      Fn = a, dr = u, Bn = p;
    }
  }
  function du(c) {
    const i = c._nodeMap;
    i.set = () => {
      throw new Error("Cannot call set() on a frozen Lexical node map");
    }, i.clear = () => {
      throw new Error("Cannot call clear() on a frozen Lexical node map");
    }, i.delete = () => {
      throw new Error("Cannot call delete() on a frozen Lexical node map");
    };
  }
  function Mo(c, i) {
    const a = c._pendingEditorState, u = c._rootElement, p = c._headless || u === null;
    if (a === null)
      return;
    const y = c._editorState, M = y._selection, $ = a._selection, le = c._dirtyType !== st, fe = Fn, Ce = dr, Ee = Bn, xe = c._updating, Ne = c._observer;
    let Ke = null;
    if (c._pendingEditorState = null, c._editorState = a, !p && le && Ne !== null) {
      Bn = c, Fn = a, dr = false, c._updating = true;
      try {
        const mt = c._dirtyType, Tt = c._dirtyElements, $t = c._dirtyLeaves;
        Ne.disconnect(), Ke = Jn(y, a, c, mt, Tt, $t);
      } catch (mt) {
        if (mt instanceof Error && c._onError(mt), !va)
          mu(c, null, u, a), Kn(c), c._dirtyType = at, va = true, Mo(c, y), va = false;
        else
          throw mt;
        return;
      } finally {
        Ne.observe(u, su), c._updating = xe, Fn = fe, dr = Ce, Bn = Ee;
      }
    }
    a._readOnly || (a._readOnly = true, du(a), ft($) && (Object.freeze($.anchor), Object.freeze($.focus)), Object.freeze($));
    const Ie = c._dirtyLeaves, Ae = c._dirtyElements, ht = c._normalizedNodes, We = c._updateTags, tt = c._deferred;
    le && (c._dirtyType = st, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements = /* @__PURE__ */ new Map(), c._normalizedNodes = /* @__PURE__ */ new Set(), c._updateTags = /* @__PURE__ */ new Set()), Ol(c, a);
    const Pt = p ? null : sr(c._window);
    if (c._editable && // domSelection will be null in headless
    Pt !== null && (le || $ === null || $.dirty)) {
      Bn = c, Fn = a;
      try {
        if (Ne !== null && Ne.disconnect(), le || $ === null || $.dirty) {
          const mt = c._blockCursorElement;
          mt !== null && vt(mt, c, u), Qh(M, $, c, Pt, We, u);
        }
        Bs(c, u, $), Ne !== null && Ne.observe(u, su);
      } finally {
        Bn = Ee, Fn = fe;
      }
    }
    Ke !== null && cg(c, Ke, We, Ie, y), !ft($) && $ !== null && (M === null || !M.is($)) && c.dispatchCommand(t, void 0);
    const Rt = c._pendingDecorators;
    Rt !== null && (c._decorators = Rt, c._pendingDecorators = null, Vs("decorator", c, true, Rt)), ag(c, i || y, a), Vs("update", c, true, {
      dirtyElements: Ae,
      dirtyLeaves: Ie,
      editorState: a,
      normalizedNodes: ht,
      prevEditorState: i || y,
      tags: We
    }), dg(c, tt), ug(c);
  }
  function ag(c, i, a) {
    const u = Hi(i), p = Hi(a);
    u !== p && Vs("textcontent", c, true, p);
  }
  function cg(c, i, a, u, p) {
    const y = Array.from(c._listeners.mutation), M = y.length;
    for (let $ = 0; $ < M; $++) {
      const [le, fe] = y[$], Ce = i.get(fe);
      Ce !== void 0 && le(Ce, {
        dirtyLeaves: u,
        prevEditorState: p,
        updateTags: a
      });
    }
  }
  function Vs(c, i, a, ...u) {
    const p = i._updating;
    i._updating = a;
    try {
      const y = Array.from(i._listeners[c]);
      for (let M = 0; M < y.length; M++)
        y[M].apply(null, u);
    } finally {
      i._updating = p;
    }
  }
  function fu(c, i, a) {
    if (c._updating === false || Bn !== c) {
      let p = false;
      return c.update(() => {
        p = fu(c, i, a);
      }), p;
    }
    const u = Jo(c);
    for (let p = 4; p >= 0; p--)
      for (let y = 0; y < u.length; y++) {
        const le = u[y]._commands.get(i);
        if (le !== void 0) {
          const fe = le[p];
          if (fe !== void 0) {
            const Ce = Array.from(fe), Ee = Ce.length;
            for (let xe = 0; xe < Ee; xe++)
              if (Ce[xe](a, c) === true)
                return true;
          }
        }
      }
    return false;
  }
  function ug(c) {
    const i = c._updates;
    if (i.length !== 0) {
      const a = i.shift();
      if (a) {
        const [u, p] = a;
        gu(c, u, p);
      }
    }
  }
  function dg(c, i) {
    if (c._deferred = [], i.length !== 0) {
      const a = c._updating;
      c._updating = true;
      try {
        for (let u = 0; u < i.length; u++)
          i[u]();
      } finally {
        c._updating = a;
      }
    }
  }
  function hu(c, i) {
    const a = c._updates;
    let u = i || false;
    for (; a.length !== 0; ) {
      const p = a.shift();
      if (p) {
        const [y, M] = p;
        let $, le;
        M !== void 0 && ($ = M.onUpdate, le = M.tag, M.skipTransforms && (u = true), $ && c._deferred.push($), le && c._updateTags.add(le)), y();
      }
    }
    return u;
  }
  function gu(c, i, a) {
    const u = c._updateTags;
    let p, y, M = false, $ = false;
    a !== void 0 && (p = a.onUpdate, y = a.tag, y != null && u.add(y), M = a.skipTransforms || false, $ = a.discrete || false), p && c._deferred.push(p);
    const le = c._editorState;
    let fe = c._pendingEditorState, Ce = false;
    (fe === null || fe._readOnly) && (fe = c._pendingEditorState = gg(fe || le), Ce = true), fe._flushSync = $;
    const Ee = Fn, xe = dr, Ne = Bn, Ke = c._updating;
    Fn = fe, dr = false, c._updating = true, Bn = c;
    try {
      Ce && (c._headless ? le._selection != null && (fe._selection = le._selection.clone()) : fe._selection = Zh(c));
      const Ae = c._compositionKey;
      i(), M = hu(c, M), Xh(fe, c), c._dirtyType !== st && (M ? ig(fe, c) : og(fe, c), hu(c), Rl(le, fe, c._dirtyLeaves, c._dirtyElements));
      const ht = c._compositionKey;
      Ae !== ht && (fe._flushSync = true);
      const We = fe._selection;
      if (ft(We)) {
        const tt = fe._nodeMap, Pt = We.anchor.key, Rt = We.focus.key;
        if (tt.get(Pt) === void 0 || tt.get(Rt) === void 0)
          throw Error("updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.");
      } else
        ur(We) && We._nodes.size === 0 && (fe._selection = null);
    } catch (Ae) {
      Ae instanceof Error && c._onError(Ae), c._pendingEditorState = le, c._dirtyType = at, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements.clear(), Mo(c);
      return;
    } finally {
      Fn = Ee, dr = xe, Bn = Ne, c._updating = Ke, Yl = 0;
    }
    c._dirtyType !== st || hg(fe, c) ? fe._flushSync ? (fe._flushSync = false, Mo(c)) : Ce && Go(() => {
      Mo(c);
    }) : (fe._flushSync = false, Ce && (u.clear(), c._deferred = [], c._pendingEditorState = null));
  }
  function Nr(c, i, a) {
    c._updating ? c._updates.push([i, a]) : gu(c, i, a);
  }
  class wa extends Ot {
    constructor(i) {
      super(i);
    }
    /**
     * The returned value is added to the LexicalEditor._decorators
     */
    decorate(i, a) {
      throw Error("decorate: base method not extended");
    }
    isIsolated() {
      return false;
    }
    isInline() {
      return true;
    }
    isKeyboardSelectable() {
      return true;
    }
  }
  function yn(c) {
    return c instanceof wa;
  }
  class Lo extends Ot {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(i) {
      super(i), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__indent = 0, this.__dir = null;
    }
    getFormat() {
      return this.getLatest().__format;
    }
    getFormatType() {
      const i = this.getFormat();
      return Wo[i] || "";
    }
    getIndent() {
      return this.getLatest().__indent;
    }
    getChildren() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        i.push(a), a = a.getNextSibling();
      return i;
    }
    getChildrenKeys() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; )
        i.push(a.__key), a = a.getNextSibling();
      return i;
    }
    getChildrenSize() {
      return this.getLatest().__size;
    }
    isEmpty() {
      return this.getChildrenSize() === 0;
    }
    isDirty() {
      const a = ln()._dirtyElements;
      return a !== null && a.has(this.__key);
    }
    isLastChild() {
      const i = this.getLatest(), a = this.getParentOrThrow().getLastChild();
      return a !== null && a.is(i);
    }
    getAllTextNodes() {
      const i = [];
      let a = this.getFirstChild();
      for (; a !== null; ) {
        if (dt(a) && i.push(a), Ze(a)) {
          const u = a.getAllTextNodes();
          i.push(...u);
        }
        a = a.getNextSibling();
      }
      return i;
    }
    getFirstDescendant() {
      let i = this.getFirstChild();
      for (; i !== null; ) {
        if (Ze(i)) {
          const a = i.getFirstChild();
          if (a !== null) {
            i = a;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getLastDescendant() {
      let i = this.getLastChild();
      for (; i !== null; ) {
        if (Ze(i)) {
          const a = i.getLastChild();
          if (a !== null) {
            i = a;
            continue;
          }
        }
        break;
      }
      return i;
    }
    getDescendantByIndex(i) {
      const a = this.getChildren(), u = a.length;
      if (i >= u) {
        const y = a[u - 1];
        return Ze(y) && y.getLastDescendant() || y || null;
      }
      const p = a[i];
      return Ze(p) && p.getFirstDescendant() || p || null;
    }
    getFirstChild() {
      const a = this.getLatest().__first;
      return a === null ? null : gn(a);
    }
    getFirstChildOrThrow() {
      const i = this.getFirstChild();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a first child.`);
      return i;
    }
    getLastChild() {
      const a = this.getLatest().__last;
      return a === null ? null : gn(a);
    }
    getLastChildOrThrow() {
      const i = this.getLastChild();
      if (i === null)
        throw Error(`Expected node ${this.__key} to have a last child.`);
      return i;
    }
    getChildAtIndex(i) {
      const a = this.getChildrenSize();
      let u, p;
      if (i < a / 2) {
        for (u = this.getFirstChild(), p = 0; u !== null && p <= i; ) {
          if (p === i)
            return u;
          u = u.getNextSibling(), p++;
        }
        return null;
      }
      for (u = this.getLastChild(), p = a - 1; u !== null && p >= i; ) {
        if (p === i)
          return u;
        u = u.getPreviousSibling(), p--;
      }
      return null;
    }
    getTextContent() {
      let i = "";
      const a = this.getChildren(), u = a.length;
      for (let p = 0; p < u; p++) {
        const y = a[p];
        i += y.getTextContent(), Ze(y) && p !== u - 1 && !y.isInline() && (i += bt);
      }
      return i;
    }
    getTextContentSize() {
      let i = 0;
      const a = this.getChildren(), u = a.length;
      for (let p = 0; p < u; p++) {
        const y = a[p];
        i += y.getTextContentSize(), Ze(y) && p !== u - 1 && !y.isInline() && (i += bt.length);
      }
      return i;
    }
    getDirection() {
      return this.getLatest().__dir;
    }
    hasFormat(i) {
      if (i !== "") {
        const a = Fr[i];
        return (this.getFormat() & a) !== 0;
      }
      return false;
    }
    // Mutators
    select(i, a) {
      jn();
      const u = en();
      let p = i, y = a;
      const M = this.getChildrenSize();
      if (!this.canBeEmpty()) {
        if (i === 0 && a === 0) {
          const le = this.getFirstChild();
          if (dt(le) || Ze(le))
            return le.select(0, 0);
        } else if ((i === void 0 || i === M) && (a === void 0 || a === M)) {
          const le = this.getLastChild();
          if (dt(le) || Ze(le))
            return le.select();
        }
      }
      p === void 0 && (p = M), y === void 0 && (y = M);
      const $ = this.__key;
      if (ft(u))
        u.anchor.set($, p, "element"), u.focus.set($, y, "element"), u.dirty = true;
      else
        return tu($, p, $, y, "element", "element");
      return u;
    }
    selectStart() {
      const i = this.getFirstDescendant();
      return i ? i.selectStart() : this.select();
    }
    selectEnd() {
      const i = this.getLastDescendant();
      return i ? i.selectEnd() : this.select();
    }
    clear() {
      const i = this.getWritable();
      return this.getChildren().forEach((u) => u.remove()), i;
    }
    append(...i) {
      return this.splice(this.getChildrenSize(), 0, i);
    }
    setDirection(i) {
      const a = this.getWritable();
      return a.__dir = i, a;
    }
    setFormat(i) {
      const a = this.getWritable();
      return a.__format = i !== "" ? Fr[i] : 0, this;
    }
    setIndent(i) {
      const a = this.getWritable();
      return a.__indent = i, this;
    }
    splice(i, a, u) {
      const p = u.length, y = this.getChildrenSize(), M = this.getWritable(), $ = M.__key, le = [], fe = [], Ce = this.getChildAtIndex(i + a);
      let Ee = null, xe = y - a + p;
      if (i !== 0)
        if (i === y)
          Ee = this.getLastChild();
        else {
          const Ke = this.getChildAtIndex(i);
          Ke !== null && (Ee = Ke.getPreviousSibling());
        }
      if (a > 0) {
        let Ke = Ee === null ? this.getFirstChild() : Ee.getNextSibling();
        for (let Ie = 0; Ie < a; Ie++) {
          if (Ke === null)
            throw Error("splice: sibling not found");
          const Ae = Ke.getNextSibling(), ht = Ke.__key, We = Ke.getWritable();
          ei(We), fe.push(ht), Ke = Ae;
        }
      }
      let Ne = Ee;
      for (let Ke = 0; Ke < p; Ke++) {
        const Ie = u[Ke];
        Ne !== null && Ie.is(Ne) && (Ee = Ne = Ne.getPreviousSibling());
        const Ae = Ie.getWritable();
        Ae.__parent === $ && xe--, ei(Ae);
        const ht = Ie.__key;
        if (Ne === null)
          M.__first = ht, Ae.__prev = null;
        else {
          const We = Ne.getWritable();
          We.__next = ht, Ae.__prev = We.__key;
        }
        if (Ie.__key === $)
          throw Error("append: attempting to append self");
        Ae.__parent = $, le.push(ht), Ne = Ie;
      }
      if (i + a === y) {
        if (Ne !== null) {
          const Ke = Ne.getWritable();
          Ke.__next = null, M.__last = Ne.__key;
        }
      } else if (Ce !== null) {
        const Ke = Ce.getWritable();
        if (Ne !== null) {
          const Ie = Ne.getWritable();
          Ke.__prev = Ne.__key, Ie.__next = Ce.__key;
        } else
          Ke.__prev = null;
      }
      if (M.__size = xe, fe.length) {
        const Ke = en();
        if (ft(Ke)) {
          const Ie = new Set(fe), Ae = new Set(le), {
            anchor: ht,
            focus: We
          } = Ke;
          pu(ht, Ie, Ae) && Gl(ht, ht.getNode(), this, Ee, Ce), pu(We, Ie, Ae) && Gl(We, We.getNode(), this, Ee, Ce), xe === 0 && !this.canBeEmpty() && !Or(this) && this.remove();
        }
      }
      return M;
    }
    // JSON serialization
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "element",
        version: 1
      };
    }
    // These are intended to be extends for specific element heuristics.
    insertNewAfter(i, a) {
      return null;
    }
    canIndent() {
      return true;
    }
    /*
     * This method controls the behavior of a the node during backwards
     * deletion (i.e., backspace) when selection is at the beginning of
     * the node (offset 0)
     */
    collapseAtStart(i) {
      return false;
    }
    excludeFromCopy(i) {
      return false;
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return true;
    }
    canReplaceWith(i) {
      return true;
    }
    canInsertAfter(i) {
      return true;
    }
    canBeEmpty() {
      return true;
    }
    canInsertTextBefore() {
      return true;
    }
    canInsertTextAfter() {
      return true;
    }
    isInline() {
      return false;
    }
    // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
    // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
    // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
    // will return the immediate first child underneath TableCellNode instead of RootNode.
    isShadowRoot() {
      return false;
    }
    canMergeWith(i) {
      return false;
    }
    extractWithChild(i, a, u) {
      return false;
    }
  }
  function Ze(c) {
    return c instanceof Lo;
  }
  function pu(c, i, a) {
    let u = c.getNode();
    for (; u; ) {
      const p = u.__key;
      if (i.has(p) && !a.has(p))
        return true;
      u = u.getParent();
    }
    return false;
  }
  class gs extends Lo {
    /** @internal */
    static getType() {
      return "root";
    }
    static clone() {
      return new gs();
    }
    constructor() {
      super("root"), this.__cachedText = null;
    }
    getTopLevelElementOrThrow() {
      throw Error("getTopLevelElementOrThrow: root nodes are not top level elements");
    }
    getTextContent() {
      const i = this.__cachedText;
      return (hs() || ln()._dirtyType === st) && i !== null ? i : super.getTextContent();
    }
    remove() {
      throw Error("remove: cannot be called on root nodes");
    }
    replace(i) {
      throw Error("replace: cannot be called on root nodes");
    }
    insertBefore(i) {
      throw Error("insertBefore: cannot be called on root nodes");
    }
    insertAfter(i) {
      throw Error("insertAfter: cannot be called on root nodes");
    }
    // View
    updateDOM(i, a) {
      return false;
    }
    // Mutate
    append(...i) {
      for (let a = 0; a < i.length; a++) {
        const u = i[a];
        if (!Ze(u) && !yn(u))
          throw Error("rootNode.append: Only element or decorator nodes can be appended to the root node");
      }
      return super.append(...i);
    }
    static importJSON(i) {
      const a = Hn();
      return a.setFormat(i.format), a.setIndent(i.indent), a.setDirection(i.direction), a;
    }
    exportJSON() {
      return {
        children: [],
        direction: this.getDirection(),
        format: this.getFormatType(),
        indent: this.getIndent(),
        type: "root",
        version: 1
      };
    }
    collapseAtStart() {
      return true;
    }
  }
  function fg() {
    return new gs();
  }
  function Er(c) {
    return c instanceof gs;
  }
  function hg(c, i) {
    const a = i.getEditorState()._selection, u = c._selection;
    if (u !== null) {
      if (u.dirty || !u.is(a))
        return true;
    } else if (a !== null)
      return true;
    return false;
  }
  function gg(c) {
    return new jl(new Map(c._nodeMap));
  }
  function Oa() {
    return new jl(/* @__PURE__ */ new Map([["root", fg()]]));
  }
  function _u(c) {
    const i = c.exportJSON(), a = c.constructor;
    if (i.type !== a.getType())
      throw Error(`LexicalNode: Node ${a.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    const u = i.children;
    if (Ze(c)) {
      if (!Array.isArray(u))
        throw Error(`LexicalNode: Node ${a.name} is an element but .exportJSON() does not have a children array.`);
      const p = c.getChildren();
      for (let y = 0; y < p.length; y++) {
        const M = p[y], $ = _u(M);
        u.push($);
      }
    }
    return i;
  }
  class jl {
    constructor(i, a) {
      this._nodeMap = i, this._selection = a || null, this._flushSync = false, this._readOnly = false;
    }
    isEmpty() {
      return this._nodeMap.size === 1 && this._selection === null;
    }
    read(i) {
      return uu(this, i);
    }
    clone(i) {
      const a = new jl(this._nodeMap, i === void 0 ? this._selection : i);
      return a._readOnly = true, a;
    }
    toJSON() {
      return uu(this, () => ({
        root: _u(Hn())
      }));
    }
  }
  class ps extends Lo {
    static getType() {
      return "paragraph";
    }
    static clone(i) {
      return new ps(i.__key);
    }
    // View
    createDOM(i) {
      const a = document.createElement("p"), u = Ei(i.theme, "paragraph");
      return u !== void 0 && a.classList.add(...u), a;
    }
    updateDOM(i, a, u) {
      return false;
    }
    static importDOM() {
      return {
        p: (i) => ({
          conversion: pg,
          priority: 0
        })
      };
    }
    exportDOM(i) {
      const {
        element: a
      } = super.exportDOM(i);
      if (a && To(a)) {
        this.isEmpty() && a.append(document.createElement("br"));
        const u = this.getFormatType();
        a.style.textAlign = u;
        const p = this.getDirection();
        p && (a.dir = p);
        const y = this.getIndent();
        y > 0 && (a.style.textIndent = `${y * 20}px`);
      }
      return {
        element: a
      };
    }
    static importJSON(i) {
      const a = Ai();
      return a.setFormat(i.format), a.setIndent(i.indent), a.setDirection(i.direction), a;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "paragraph",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(i, a) {
      const u = Ai(), p = this.getDirection();
      return u.setDirection(p), this.insertAfter(u, a), u;
    }
    collapseAtStart() {
      const i = this.getChildren();
      if (i.length === 0 || dt(i[0]) && i[0].getTextContent().trim() === "") {
        if (this.getNextSibling() !== null)
          return this.selectNext(), this.remove(), true;
        if (this.getPreviousSibling() !== null)
          return this.selectPrevious(), this.remove(), true;
      }
      return false;
    }
  }
  function pg(c) {
    const i = Ai();
    if (c.style) {
      i.setFormat(c.style.textAlign);
      const a = parseInt(c.style.textIndent, 10) / 20;
      a > 0 && i.setIndent(a);
    }
    return {
      node: i
    };
  }
  function Ai() {
    return Yi(new ps());
  }
  function _g(c) {
    return c instanceof ps;
  }
  const mg = 0, yg = 1, Cg = 2, Ng = 3, Eg = 4;
  function mu(c, i, a, u) {
    const p = c._keyToDOMMap;
    p.clear(), c._editorState = Oa(), c._pendingEditorState = u, c._compositionKey = null, c._dirtyType = st, c._cloneNotNeeded.clear(), c._dirtyLeaves = /* @__PURE__ */ new Set(), c._dirtyElements.clear(), c._normalizedNodes = /* @__PURE__ */ new Set(), c._updateTags = /* @__PURE__ */ new Set(), c._updates = [], c._blockCursorElement = null;
    const y = c._observer;
    y !== null && (y.disconnect(), c._observer = null), i !== null && (i.textContent = ""), a !== null && (a.textContent = "", p.set("root", a));
  }
  function Tg(c, i) {
    const a = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set(), p = (y) => {
      Object.keys(y).forEach((M) => {
        let $ = a.get(M);
        $ === void 0 && ($ = [], a.set(M, $)), $.push(y[M]);
      });
    };
    return c.forEach((y) => {
      const M = y.klass.importDOM != null ? y.klass.importDOM.bind(y.klass) : null;
      if (M == null || u.has(M))
        return;
      u.add(M);
      const $ = M();
      $ !== null && p($);
    }), i && p(i), a;
  }
  function xg(c) {
    const i = c || {}, a = rg(), u = i.theme || {}, p = c === void 0 ? a : i.parentEditor || null, y = i.disableEvents || false, M = Oa(), $ = i.namespace || (p !== null ? p._config.namespace : uo()), le = i.editorState, fe = [gs, wi, Ar, di, ps, ...i.nodes || []], {
      onError: Ce,
      html: Ee
    } = i, xe = i.editable !== void 0 ? i.editable : true;
    let Ne;
    if (c === void 0 && a !== null)
      Ne = a._nodes;
    else {
      Ne = /* @__PURE__ */ new Map();
      for (let Ie = 0; Ie < fe.length; Ie++) {
        let Ae = fe[Ie], ht = null, We = null;
        if (typeof Ae != "function") {
          const mt = Ae;
          Ae = mt.replace, ht = mt.with, We = mt.withKlass || null;
        }
        {
          const mt = Ae.name;
          if (mt !== "RootNode") {
            const Tt = Ae.prototype;
            ["getType", "clone"].forEach(($t) => {
              Ae.hasOwnProperty($t) || console.warn(`${mt} must implement static "${$t}" method`);
            }), // eslint-disable-next-line no-prototype-builtins
            !Ae.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            Ae.hasOwnProperty("exportDOM") && console.warn(`${mt} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`), Tt instanceof wa && (Tt.hasOwnProperty("decorate") || console.warn(`${Tt.constructor.name} must implement "decorate" method`)), Ae.hasOwnProperty("importJSON") || console.warn(`${mt} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`), Tt.hasOwnProperty("exportJSON") || console.warn(`${mt} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
        const tt = Ae.getType(), Pt = Ae.transform(), Rt = /* @__PURE__ */ new Set();
        Pt !== null && Rt.add(Pt), Ne.set(tt, {
          exportDOM: Ee && Ee.export ? Ee.export.get(Ae) : void 0,
          klass: Ae,
          replace: ht,
          replaceWithKlass: We,
          transforms: Rt
        });
      }
    }
    const Ke = new vg(M, p, Ne, {
      disableEvents: y,
      namespace: $,
      theme: u
    }, Ce || console.error, Tg(Ne, Ee ? Ee.import : void 0), xe);
    return le !== void 0 && (Ke._pendingEditorState = le, Ke._dirtyType = at), Ke;
  }
  class vg {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    constructor(i, a, u, p, y, M, $) {
      this._parentEditor = a, this._rootElement = null, this._editorState = i, this._pendingEditorState = null, this._compositionKey = null, this._deferred = [], this._keyToDOMMap = /* @__PURE__ */ new Map(), this._updates = [], this._updating = false, this._listeners = {
        decorator: /* @__PURE__ */ new Set(),
        editable: /* @__PURE__ */ new Set(),
        mutation: /* @__PURE__ */ new Map(),
        root: /* @__PURE__ */ new Set(),
        textcontent: /* @__PURE__ */ new Set(),
        update: /* @__PURE__ */ new Set()
      }, this._commands = /* @__PURE__ */ new Map(), this._config = p, this._nodes = u, this._decorators = {}, this._pendingDecorators = null, this._dirtyType = st, this._cloneNotNeeded = /* @__PURE__ */ new Set(), this._dirtyLeaves = /* @__PURE__ */ new Set(), this._dirtyElements = /* @__PURE__ */ new Map(), this._normalizedNodes = /* @__PURE__ */ new Set(), this._updateTags = /* @__PURE__ */ new Set(), this._observer = null, this._key = uo(), this._onError = y, this._htmlConversions = M, this._editable = $, this._headless = a !== null && a._headless, this._window = null, this._blockCursorElement = null;
    }
    /**
     *
     * @returns true if the editor is currently in "composition" mode due to receiving input
     * through an IME, or 3P extension, for example. Returns false otherwise.
     */
    isComposing() {
      return this._compositionKey != null;
    }
    /**
     * Registers a listener for Editor update event. Will trigger the provided callback
     * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerUpdateListener(i) {
      const a = this._listeners.update;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for for when the editor changes between editable and non-editable states.
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerEditableListener(i) {
      const a = this._listeners.editable;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when the editor's decorator object changes. The decorator object contains
     * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerDecoratorListener(i) {
      const a = this._listeners.decorator;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when Lexical commits an update to the DOM and the text content of
     * the editor changes from the previous state of the editor. If the text content is the
     * same between updates, no notifications to the listeners will happen.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerTextContentListener(i) {
      const a = this._listeners.textcontent;
      return a.add(i), () => {
        a.delete(i);
      };
    }
    /**
     * Registers a listener for when the editor's root DOM element (the content editable
     * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
     *  element. The root listener function is executed directly upon registration and then on
     * any subsequent update.
     *
     * Will trigger the provided callback each time the editor transitions between these states until the
     * teardown function is called.
     *
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerRootListener(i) {
      const a = this._listeners.root;
      return i(this._rootElement, null), a.add(i), () => {
        i(null, this._rootElement), a.delete(i);
      };
    }
    /**
     * Registers a listener that will trigger anytime the provided command
     * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
     * commands and prevent them from propagating to other handlers by returning true.
     *
     * Listeners registered at the same priority level will run deterministically in the order of registration.
     *
     * @param command - the command that will trigger the callback.
     * @param listener - the function that will execute when the command is dispatched.
     * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerCommand(i, a, u) {
      if (u === void 0)
        throw Error('Listener for type "command" requires a "priority".');
      const p = this._commands;
      p.has(i) || p.set(i, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
      const y = p.get(i);
      if (y === void 0)
        throw Error(`registerCommand: Command ${String(i)} not found in command map`);
      const M = y[u];
      return M.add(a), () => {
        M.delete(a), y.every(($) => $.size === 0) && p.delete(i);
      };
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * mutated. The listener will receive a list of nodes along with the type of mutation
     * that was performed on each: created, destroyed, or updated.
     *
     * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
     * {@link LexicalEditor.getElementByKey} can be used for this.
     *
     * @param klass - The class of the node that you want to listen to mutations on.
     * @param listener - The logic you want to run when the node is mutated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerMutationListener(i, a) {
      if (this._nodes.get(i.getType()) === void 0)
        throw Error(`Node ${i.name} has not been registered. Ensure node has been passed to createEditor.`);
      const p = this._listeners.mutation;
      return p.set(a, i), () => {
        p.delete(a);
      };
    }
    /** @internal */
    registerNodeTransformToKlass(i, a) {
      const u = i.getType(), p = this._nodes.get(u);
      if (p === void 0)
        throw Error(`Node ${i.name} has not been registered. Ensure node has been passed to createEditor.`);
      return p.transforms.add(a), p;
    }
    /**
     * Registers a listener that will run when a Lexical node of the provided class is
     * marked dirty during an update. The listener will continue to run as long as the node
     * is marked dirty. There are no guarantees around the order of transform execution!
     *
     * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
     * @param klass - The class of the node that you want to run transforms on.
     * @param listener - The logic you want to run when the node is updated.
     * @returns a teardown function that can be used to cleanup the listener.
     */
    registerNodeTransform(i, a) {
      const u = this.registerNodeTransformToKlass(i, a), p = [u], y = u.replaceWithKlass;
      if (y != null) {
        const M = this.registerNodeTransformToKlass(y, a);
        p.push(M);
      }
      return qo(this, i.getType()), () => {
        p.forEach((M) => M.transforms.delete(a));
      };
    }
    /**
     * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered the provided node type, false otherwise.
     */
    hasNode(i) {
      return this._nodes.has(i.getType());
    }
    /**
     * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
     * depend on have been registered.
     * @returns True if the editor has registered all of the provided node types, false otherwise.
     */
    hasNodes(i) {
      return i.every(this.hasNode.bind(this));
    }
    /**
     * Dispatches a command of the specified type with the specified payload.
     * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
     * for this type, passing them the provided payload.
     * @param type - the type of command listeners to trigger.
     * @param payload - the data to pass as an argument to the command listeners.
     */
    dispatchCommand(i, a) {
      return it(this, i, a);
    }
    /**
     * Gets a map of all decorators in the editor.
     * @returns A mapping of call decorator keys to their decorated content
     */
    getDecorators() {
      return this._decorators;
    }
    /**
     *
     * @returns the current root element of the editor. If you want to register
     * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
     * this reference may not be stable.
     */
    getRootElement() {
      return this._rootElement;
    }
    /**
     * Gets the key of the editor
     * @returns The editor key
     */
    getKey() {
      return this._key;
    }
    /**
     * Imperatively set the root contenteditable element that Lexical listens
     * for events on.
     */
    setRootElement(i) {
      const a = this._rootElement;
      if (i !== a) {
        const u = Ei(this._config.theme, "root"), p = this._pendingEditorState || this._editorState;
        if (this._rootElement = i, mu(this, a, i, p), a !== null && (this._config.disableEvents || Pe(a), u != null && a.classList.remove(...u)), i !== null) {
          const y = Gi(i), M = i.style;
          M.userSelect = "text", M.whiteSpace = "pre-wrap", M.wordBreak = "break-word", i.setAttribute("data-lexical-editor", "true"), this._window = y, this._dirtyType = at, Kn(this), this._updateTags.add("history-merge"), Mo(this), this._config.disableEvents || Ue(i, this), u != null && i.classList.add(...u);
        } else
          this._editorState = p, this._pendingEditorState = null, this._window = null;
        Vs("root", this, false, i, a);
      }
    }
    /**
     * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
     * @returns the HTMLElement rendered by the LexicalNode associated with the key.
     * @param key - the key of the LexicalNode.
     */
    getElementByKey(i) {
      return this._keyToDOMMap.get(i) || null;
    }
    /**
     * Gets the active editor state.
     * @returns The editor state
     */
    getEditorState() {
      return this._editorState;
    }
    /**
     * Imperatively set the EditorState. Triggers reconciliation like an update.
     * @param editorState - the state to set the editor
     * @param options - options for the update.
     */
    setEditorState(i, a) {
      if (i.isEmpty())
        throw Error("setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.");
      Xr(this);
      const u = this._pendingEditorState, p = this._updateTags, y = a !== void 0 ? a.tag : null;
      u !== null && !u.isEmpty() && (y != null && p.add(y), Mo(this)), this._pendingEditorState = i, this._dirtyType = at, this._dirtyElements.set("root", false), this._compositionKey = null, y != null && p.add(y), Mo(this);
    }
    /**
     * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
     * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
     * deserliazation from JSON stored in a database uses this method.
     * @param maybeStringifiedEditorState
     * @param updateFn
     * @returns
     */
    parseEditorState(i, a) {
      const u = typeof i == "string" ? JSON.parse(i) : i;
      return lg(u, this, a);
    }
    /**
     * Executes an update to the editor state. The updateFn callback is the ONLY place
     * where Lexical editor state can be safely mutated.
     * @param updateFn - A function that has access to writable editor state.
     * @param options - A bag of options to control the behavior of the update.
     * @param options.onUpdate - A function to run once the update is complete.
     * Useful for synchronizing updates in some cases.
     * @param options.skipTransforms - Setting this to true will suppress all node
     * transforms for this update cycle.
     * @param options.tag - A tag to identify this update, in an update listener, for instance.
     * Some tags are reserved by the core and control update behavior in different ways.
     * @param options.discrete - If true, prevents this update from being batched, forcing it to
     * run synchronously.
     */
    update(i, a) {
      Nr(this, i, a);
    }
    /**
     * Focuses the editor
     * @param callbackFn - A function to run after the editor is focused.
     * @param options - A bag of options
     * @param options.defaultSelection - Where to move selection when the editor is
     * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
     */
    focus(i, a = {}) {
      const u = this._rootElement;
      u !== null && (u.setAttribute("autocapitalize", "off"), Nr(this, () => {
        const p = en(), y = Hn();
        p !== null ? p.dirty = true : y.getChildrenSize() !== 0 && (a.defaultSelection === "rootStart" ? y.selectStart() : y.selectEnd());
      }, {
        onUpdate: () => {
          u.removeAttribute("autocapitalize"), i && i();
        },
        tag: "focus"
      }), this._pendingEditorState === null && u.removeAttribute("autocapitalize"));
    }
    /**
     * Removes focus from the editor.
     */
    blur() {
      const i = this._rootElement;
      i !== null && i.blur();
      const a = sr(this._window);
      a !== null && a.removeAllRanges();
    }
    /**
     * Returns true if the editor is editable, false otherwise.
     * @returns True if the editor is editable, false otherwise.
     */
    isEditable() {
      return this._editable;
    }
    /**
     * Sets the editable property of the editor. When false, the
     * editor will not listen for user events on the underling contenteditable.
     * @param editable - the value to set the editable mode to.
     */
    setEditable(i) {
      this._editable !== i && (this._editable = i, Vs("editable", this, true, i));
    }
    /**
     * Returns a JSON-serializable javascript object NOT a JSON string.
     * You still must call JSON.stringify (or something else) to turn the
     * state into a string you can transfer over the wire and store in a database.
     *
     * See {@link LexicalNode.exportJSON}
     *
     * @returns A JSON-serializable javascript object
     */
    toJSON() {
      return {
        editorState: this._editorState.toJSON()
      };
    }
  }
  class Ra extends Lo {
    /** @internal */
    constructor(i, a) {
      super(a), this.__colSpan = i, this.__rowSpan = 1;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        colSpan: this.__colSpan,
        rowSpan: this.__rowSpan
      };
    }
    getColSpan() {
      return this.__colSpan;
    }
    setColSpan(i) {
      return this.getWritable().__colSpan = i, this;
    }
    getRowSpan() {
      return this.__rowSpan;
    }
    setRowSpan(i) {
      return this.getWritable().__rowSpan = i, this;
    }
  }
  function Pr(c) {
    return c instanceof Ra;
  }
  class yu extends Lo {
  }
  function Da(c) {
    return c instanceof yu;
  }
  class Cu extends Lo {
  }
  function Js(c) {
    return c instanceof Cu;
  }
  return $e.$INTERNAL_isPointSelection = cr, $e.$addUpdateTag = ii, $e.$applyNodeReplacement = Yi, $e.$copyNode = $s, $e.$createLineBreakNode = ci, $e.$createNodeSelection = Ea, $e.$createParagraphNode = Ai, $e.$createRangeSelection = Vh, $e.$createTabNode = Oi, $e.$createTextNode = Mn, $e.$getAdjacentNode = zr, $e.$getNearestNodeFromDOMNode = or, $e.$getNearestRootOrShadowRoot = mr, $e.$getNodeByKey = gn, $e.$getPreviousSelection = fs, $e.$getRoot = Hn, $e.$getSelection = en, $e.$getTextContent = tg, $e.$hasAncestor = ut, $e.$hasUpdateTag = Ca, $e.$insertNodes = eg, $e.$isBlockElementNode = qh, $e.$isDecoratorNode = yn, $e.$isElementNode = Ze, $e.$isInlineElementOrDecoratorNode = wl, $e.$isLeafNode = Qr, $e.$isLineBreakNode = ui, $e.$isNodeSelection = ur, $e.$isParagraphNode = _g, $e.$isRangeSelection = ft, $e.$isRootNode = Er, $e.$isRootOrShadowRoot = Or, $e.$isTabNode = Ao, $e.$isTextNode = dt, $e.$nodesOfType = ks, $e.$normalizeSelection__EXPERIMENTAL = Ni, $e.$parseSerializedNode = sg, $e.$selectAll = Is, $e.$setCompositionKey = un, $e.$setSelection = _r, $e.$splitNode = es, $e.BLUR_COMMAND = J, $e.CAN_REDO_COMMAND = g, $e.CAN_UNDO_COMMAND = _, $e.CLEAR_EDITOR_COMMAND = Q, $e.CLEAR_HISTORY_COMMAND = b, $e.CLICK_COMMAND = r, $e.COMMAND_PRIORITY_CRITICAL = Eg, $e.COMMAND_PRIORITY_EDITOR = mg, $e.COMMAND_PRIORITY_HIGH = Ng, $e.COMMAND_PRIORITY_LOW = yg, $e.COMMAND_PRIORITY_NORMAL = Cg, $e.CONTROLLED_TEXT_INSERTION_COMMAND = C, $e.COPY_COMMAND = ne, $e.CUT_COMMAND = Y, $e.DELETE_CHARACTER_COMMAND = o, $e.DELETE_LINE_COMMAND = x, $e.DELETE_WORD_COMMAND = S, $e.DEPRECATED_$computeGridMap = iu, $e.DEPRECATED_$createGridSelection = Jh, $e.DEPRECATED_$getGridCellNodeRect = Ri, $e.DEPRECATED_$getNodeTriplet = ou, $e.DEPRECATED_$isGridCellNode = Pr, $e.DEPRECATED_$isGridNode = Da, $e.DEPRECATED_$isGridRowNode = Js, $e.DEPRECATED_$isGridSelection = Qn, $e.DEPRECATED_GridCellNode = Ra, $e.DEPRECATED_GridNode = yu, $e.DEPRECATED_GridRowNode = Cu, $e.DRAGEND_COMMAND = j, $e.DRAGOVER_COMMAND = w, $e.DRAGSTART_COMMAND = P, $e.DROP_COMMAND = Z, $e.DecoratorNode = wa, $e.ElementNode = Lo, $e.FOCUS_COMMAND = A, $e.FORMAT_ELEMENT_COMMAND = ee, $e.FORMAT_TEXT_COMMAND = D, $e.INDENT_CONTENT_COMMAND = me, $e.INSERT_LINE_BREAK_COMMAND = f, $e.INSERT_PARAGRAPH_COMMAND = h, $e.INSERT_TAB_COMMAND = q, $e.KEY_ARROW_DOWN_COMMAND = B, $e.KEY_ARROW_LEFT_COMMAND = U, $e.KEY_ARROW_RIGHT_COMMAND = v, $e.KEY_ARROW_UP_COMMAND = K, $e.KEY_BACKSPACE_COMMAND = re, $e.KEY_DELETE_COMMAND = V, $e.KEY_DOWN_COMMAND = N, $e.KEY_ENTER_COMMAND = z, $e.KEY_ESCAPE_COMMAND = de, $e.KEY_MODIFIER_COMMAND = ce, $e.KEY_SPACE_COMMAND = te, $e.KEY_TAB_COMMAND = G, $e.LineBreakNode = Ar, $e.MOVE_TO_END = F, $e.MOVE_TO_START = I, $e.OUTDENT_CONTENT_COMMAND = pe, $e.PASTE_COMMAND = T, $e.ParagraphNode = ps, $e.REDO_COMMAND = H, $e.REMOVE_TEXT_COMMAND = O, $e.RootNode = gs, $e.SELECTION_CHANGE_COMMAND = t, $e.SELECT_ALL_COMMAND = W, $e.TabNode = di, $e.TextNode = wi, $e.UNDO_COMMAND = k, $e.createCommand = e, $e.createEditor = xg, $e.getNearestEditorFromDOMNode = ao, $e.isHTMLAnchorElement = Eo, $e.isHTMLElement = To, $e.isSelectionCapturedInDecoratorInput = Bi, $e.isSelectionWithinEditor = Kr, $e;
}
var $a;
var Ku;
function kt() {
  return Ku || (Ku = 1, $a = true ? Wp() : Up()), $a;
}
var Fa = {};
var Uu;
function Gp() {
  if (Uu)
    return Fa;
  Uu = 1;
  var e = kn(), t = kt(), r = import_react.default;
  const o = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
  var h = o ? r.useLayoutEffect : r.useEffect;
  const C = {
    tag: "history-merge"
  };
  function T({
    initialConfig: S,
    children: x
  }) {
    const D = r.useMemo(
      () => {
        const {
          theme: k,
          namespace: H,
          editor__DEPRECATED: N,
          nodes: v,
          onError: F,
          editorState: U,
          html: I
        } = S, K = e.createLexicalComposerContext(null, k);
        let B = N || null;
        if (B === null) {
          const z = t.createEditor({
            editable: S.editable,
            html: I,
            namespace: H,
            nodes: v,
            onError: (te) => F(te, z),
            theme: k
          });
          O(z, U), B = z;
        }
        return [B, K];
      },
      // We only do this for init
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    return h(() => {
      const k = S.editable, [H] = D;
      H.setEditable(k !== void 0 ? k : true);
    }, []), r.createElement(e.LexicalComposerContext.Provider, {
      value: D
    }, x);
  }
  function O(S, x) {
    if (x !== null) {
      if (x === void 0)
        S.update(() => {
          const D = t.$getRoot();
          if (D.isEmpty()) {
            const k = t.$createParagraphNode();
            D.append(k);
            const H = o ? document.activeElement : null;
            (t.$getSelection() !== null || H !== null && H === S.getRootElement()) && k.select();
          }
        }, C);
      else if (x !== null)
        switch (typeof x) {
          case "string": {
            const D = S.parseEditorState(x);
            S.setEditorState(D, C);
            break;
          }
          case "object": {
            S.setEditorState(x, C);
            break;
          }
          case "function": {
            S.update(() => {
              t.$getRoot().isEmpty() && x(S);
            }, C);
            break;
          }
        }
    }
  }
  return Fa.LexicalComposer = T, Fa;
}
var Yp = true ? Gp() : zp();
var jp = Yp;
var Ha;
var zu;
function Vp() {
  if (zu)
    return Ha;
  zu = 1;
  var e = kn(), t = import_react.default, f = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function h(O) {
    const [S] = e.useLexicalComposerContext(), x = t.useMemo(() => O(S), [S, O]), D = t.useRef(x.initialValueFn()), [k, H] = t.useState(D.current);
    return f(() => {
      const {
        initialValueFn: N,
        subscribe: v
      } = x, F = N();
      return D.current !== F && (D.current = F, H(F)), v((U) => {
        D.current = U, H(U);
      });
    }, [x, O]), k;
  }
  function C(O) {
    return {
      initialValueFn: () => O.isEditable(),
      subscribe: (S) => O.registerEditableListener(S)
    };
  }
  function T() {
    return h(C);
  }
  return Ha = T, Ha;
}
var Ua;
var Gu;
function oh() {
  return Gu || (Gu = 1, Ua = true ? Vp() : qp()), Ua;
}
var Pi = {};
var ju;
function Zp() {
  if (ju)
    return Pi;
  ju = 1;
  var e = kt();
  function t(O, S) {
    let x = O.getFirstChild(), D = 0;
    e:
      for (; x !== null; ) {
        if (e.$isElementNode(x)) {
          const N = x.getFirstChild();
          if (N !== null) {
            x = N;
            continue;
          }
        } else if (e.$isTextNode(x)) {
          const N = x.getTextContentSize();
          if (D + N > S)
            return {
              node: x,
              offset: S - D
            };
          D += N;
        }
        const k = x.getNextSibling();
        if (k !== null) {
          x = k;
          continue;
        }
        let H = x.getParent();
        for (; H !== null; ) {
          const N = H.getNextSibling();
          if (N !== null) {
            x = N;
            continue e;
          }
          H = H.getParent();
        }
        break;
      }
    return null;
  }
  function r(O, S = true) {
    if (O)
      return false;
    let x = f();
    return S && (x = x.trim()), x === "";
  }
  function o(O, S) {
    return () => r(O, S);
  }
  function f() {
    return e.$getRoot().getTextContent();
  }
  function h(O) {
    if (!r(O, false))
      return false;
    const x = e.$getRoot().getChildren(), D = x.length;
    if (D > 1)
      return false;
    for (let k = 0; k < D; k++) {
      const H = x[k];
      if (e.$isDecoratorNode(H))
        return false;
      if (e.$isElementNode(H)) {
        if (!e.$isParagraphNode(H) || H.__indent !== 0)
          return false;
        const N = H.getChildren(), v = N.length;
        for (let F = 0; F < v; F++) {
          const U = N[k];
          if (!e.$isTextNode(U))
            return false;
        }
      }
    }
    return true;
  }
  function C(O) {
    return () => h(O);
  }
  function T(O, S, x, D) {
    const k = (K) => K instanceof x, H = (K) => {
      const B = e.$createTextNode(K.getTextContent());
      B.setFormat(K.getFormat()), K.replace(B);
    }, N = (K) => K.getLatest().__mode, v = (K) => {
      if (!K.isSimpleText())
        return;
      const B = K.getPreviousSibling();
      let z = K.getTextContent(), te = K, re;
      if (e.$isTextNode(B)) {
        const de = B.getTextContent(), V = de + z, G = S(V);
        if (k(B))
          if (G === null || N(B) !== 0) {
            H(B);
            return;
          } else {
            const q = G.end - de.length;
            if (q > 0) {
              const me = z.slice(0, q), pe = de + me;
              if (B.select(), B.setTextContent(pe), q === z.length)
                K.remove();
              else {
                const Z = z.slice(q);
                K.setTextContent(Z);
              }
              return;
            }
          }
        else if (G === null || G.start < de.length)
          return;
      }
      for (; ; ) {
        re = S(z);
        let de = re === null ? "" : z.slice(re.end);
        if (z = de, de === "") {
          const q = te.getNextSibling();
          if (e.$isTextNode(q)) {
            de = te.getTextContent() + q.getTextContent();
            const me = S(de);
            if (me === null) {
              k(q) ? H(q) : q.markDirty();
              return;
            } else if (me.start !== 0)
              return;
          }
        } else {
          const q = S(de);
          if (q !== null && q.start === 0)
            return;
        }
        if (re === null)
          return;
        if (re.start === 0 && e.$isTextNode(B) && B.isTextEntity())
          continue;
        let V;
        re.start === 0 ? [V, te] = te.splitText(re.end) : [, V, te] = te.splitText(re.start, re.end);
        const G = D(V);
        if (G.setFormat(V.getFormat()), V.replace(G), te == null)
          return;
      }
    }, F = (K) => {
      const B = K.getTextContent(), z = S(B);
      if (z === null || z.start !== 0) {
        H(K);
        return;
      }
      if (B.length > z.end) {
        K.splitText(z.end);
        return;
      }
      const te = K.getPreviousSibling();
      e.$isTextNode(te) && te.isTextEntity() && (H(te), H(K));
      const re = K.getNextSibling();
      e.$isTextNode(re) && re.isTextEntity() && (H(re), k(K) && H(K));
    }, U = O.registerNodeTransform(e.TextNode, v), I = O.registerNodeTransform(x, F);
    return [U, I];
  }
  return Pi.$canShowPlaceholder = h, Pi.$canShowPlaceholderCurry = C, Pi.$findTextIntersectionFromCharacters = t, Pi.$isRootTextContentEmpty = r, Pi.$isRootTextContentEmptyCurry = o, Pi.$rootTextContent = f, Pi.registerLexicalTextEntity = T, Pi;
}
var Wa;
var qu;
function sh() {
  return qu || (qu = 1, Wa = true ? Zp() : Jp()), Wa;
}
var In = {};
var Ju;
function Qp() {
  if (Ju)
    return In;
  Ju = 1;
  var e = kt();
  const t = /* @__PURE__ */ new Map();
  function r(P) {
    let w = P;
    for (; w != null; ) {
      if (w.nodeType === Node.TEXT_NODE)
        return w;
      w = w.firstChild;
    }
    return null;
  }
  function o(P) {
    const w = P.parentNode;
    if (w == null)
      throw new Error("Should never happen");
    return [w, Array.from(w.childNodes).indexOf(P)];
  }
  function f(P, w, j, ne, Y) {
    const W = w.getKey(), Q = ne.getKey(), b = document.createRange();
    let g = P.getElementByKey(W), _ = P.getElementByKey(Q), A = j, J = Y;
    if (e.$isTextNode(w) && (g = r(g)), e.$isTextNode(ne) && (_ = r(_)), w === void 0 || ne === void 0 || g === null || _ === null)
      return null;
    g.nodeName === "BR" && ([g, A] = o(g)), _.nodeName === "BR" && ([_, J] = o(_));
    const ce = g.firstChild;
    g === _ && ce != null && ce.nodeName === "BR" && A === 0 && J === 0 && (J = 1);
    try {
      b.setStart(g, A), b.setEnd(_, J);
    } catch {
      return null;
    }
    return b.collapsed && (A !== J || W !== Q) && (b.setStart(_, J), b.setEnd(g, A)), b;
  }
  function h(P, w) {
    const j = P.getRootElement();
    if (j === null)
      return [];
    const ne = j.getBoundingClientRect(), Y = getComputedStyle(j), W = parseFloat(Y.paddingLeft) + parseFloat(Y.paddingRight), Q = Array.from(w.getClientRects());
    let b = Q.length;
    Q.sort((_, A) => {
      const J = _.top - A.top;
      return Math.abs(J) <= 3 ? _.left - A.left : J;
    });
    let g;
    for (let _ = 0; _ < b; _++) {
      const A = Q[_], J = g && g.top <= A.top && g.top + g.height > A.top && g.left + g.width > A.left, ce = A.width + W === ne.width;
      if (J || ce) {
        Q.splice(_--, 1), b--;
        continue;
      }
      g = A;
    }
    return Q;
  }
  function C(P) {
    const w = {}, j = P.split(";");
    for (const ne of j)
      if (ne !== "") {
        const [Y, W] = ne.split(/:([^]+)/);
        Y && W && (w[Y.trim()] = W.trim());
      }
    return w;
  }
  function T(P) {
    let w = t.get(P);
    return w === void 0 && (w = C(P), t.set(P, w)), Object.freeze(w), w;
  }
  function O(P) {
    let w = "";
    for (const j in P)
      j && (w += `${j}: ${P[j]};`);
    return w;
  }
  function S(P, w) {
    return P.__first = w.__first, P.__last = w.__last, P.__size = w.__size, P.__format = w.__format, P.__indent = w.__indent, P.__dir = w.__dir, P;
  }
  function x(P, w) {
    return P.__format = w.__format, P.__style = w.__style, P.__mode = w.__mode, P.__detail = w.__detail, P;
  }
  function D(P) {
    const j = P.constructor.clone(P);
    return j.__parent = P.__parent, j.__next = P.__next, j.__prev = P.__prev, e.$isElementNode(P) && e.$isElementNode(j) ? S(j, P) : e.$isTextNode(P) && e.$isTextNode(j) ? x(j, P) : j;
  }
  function k(P, w) {
    if (w.isSelected() && !w.isSegmented() && !w.isToken() && e.$INTERNAL_isPointSelection(P)) {
      const j = P.anchor.getNode(), ne = P.focus.getNode(), Y = w.is(j), W = w.is(ne);
      if (Y || W) {
        const Q = P.isBackward(), [b, g] = P.getCharacterOffsets(), _ = j.is(ne), A = w.is(Q ? ne : j), J = w.is(Q ? j : ne);
        let ce = 0, ge;
        if (_)
          ce = b > g ? g : b, ge = b > g ? b : g;
        else if (A)
          ce = Q ? g : b, ge = void 0;
        else if (J) {
          const ae = Q ? b : g;
          ce = 0, ge = ae;
        }
        return w.__text = w.__text.slice(ce, ge), w;
      }
    }
    return w;
  }
  function H(P) {
    return P.type === "text" ? P.offset === P.getNode().getTextContentSize() : P.offset === P.getNode().getChildrenSize();
  }
  function N(P, w, j) {
    let ne = w.getNode(), Y = j;
    if (e.$isElementNode(ne)) {
      const W = ne.getDescendantByIndex(w.offset);
      W !== null && (ne = W);
    }
    for (; Y > 0 && ne !== null; ) {
      if (e.$isElementNode(ne)) {
        const _ = ne.getLastDescendant();
        _ !== null && (ne = _);
      }
      let W = ne.getPreviousSibling(), Q = 0;
      if (W === null) {
        let _ = ne.getParentOrThrow(), A = _.getPreviousSibling();
        for (; A === null; ) {
          if (_ = _.getParent(), _ === null) {
            W = null;
            break;
          }
          A = _.getPreviousSibling();
        }
        _ !== null && (Q = _.isInline() ? 0 : 2, W = A);
      }
      let b = ne.getTextContent();
      b === "" && e.$isElementNode(ne) && !ne.isInline() && (b = `

`);
      const g = b.length;
      if (!e.$isTextNode(ne) || Y >= g) {
        const _ = ne.getParent();
        ne.remove(), _ != null && _.getChildrenSize() === 0 && !e.$isRootNode(_) && _.remove(), Y -= g + Q, ne = W;
      } else {
        const _ = ne.getKey(), A = P.getEditorState().read(() => {
          const ge = e.$getNodeByKey(_);
          return e.$isTextNode(ge) && ge.isSimpleText() ? ge.getTextContent() : null;
        }), J = g - Y, ce = b.slice(0, J);
        if (A !== null && A !== b) {
          const ge = e.$getPreviousSelection();
          let ae = ne;
          if (ne.isSimpleText())
            ne.setTextContent(A);
          else {
            const Te = e.$createTextNode(A);
            ne.replace(Te), ae = Te;
          }
          if (e.$isRangeSelection(ge) && ge.isCollapsed()) {
            const Te = ge.anchor.offset;
            ae.select(Te, Te);
          }
        } else if (ne.isSimpleText()) {
          const ge = w.key === _;
          let ae = w.offset;
          ae < Y && (ae = g);
          const Te = ge ? ae - Y : 0, Me = ge ? ae : J;
          if (ge && Te === 0) {
            const [ze] = ne.splitText(Te, Me);
            ze.remove();
          } else {
            const [, ze] = ne.splitText(Te, Me);
            ze.remove();
          }
        } else {
          const ge = e.$createTextNode(ce);
          ne.replace(ge);
        }
        Y = 0;
      }
    }
  }
  function v(P) {
    const w = P.getStyle(), j = C(w);
    t.set(w, j);
  }
  function F(P, w) {
    const j = T("getStyle" in P ? P.getStyle() : P.style), ne = Object.entries(w).reduce((W, [Q, b]) => (b === null ? delete W[Q] : W[Q] = b, W), {
      ...j
    }), Y = O(ne);
    P.setStyle(Y), t.set(Y, ne);
  }
  function U(P, w) {
    const j = P.getNodes(), ne = j.length;
    if (e.DEPRECATED_$isGridSelection(P)) {
      const ie = e.$createRangeSelection(), ue = ie.anchor, we = ie.focus;
      for (let Le = 0; Le < ne; Le++) {
        const Be = j[Le];
        e.DEPRECATED_$isGridCellNode(Be) && (ue.set(Be.getKey(), 0, "element"), we.set(Be.getKey(), Be.getChildrenSize(), "element"), U(e.$normalizeSelection__EXPERIMENTAL(ie), w));
      }
      e.$setSelection(P);
      return;
    }
    const Y = ne - 1;
    let W = j[0], Q = j[Y];
    if (P.isCollapsed() && e.$isRangeSelection(P)) {
      F(P, w);
      return;
    }
    const b = P.anchor, g = P.focus, A = W.getTextContent().length, J = g.offset;
    let ce = b.offset;
    const ge = b.isBefore(g);
    let ae = ge ? ce : J, Te = ge ? J : ce;
    const Me = ge ? b.type : g.type, ze = ge ? g.type : b.type, oe = ge ? g.key : b.key;
    if (e.$isTextNode(W) && ae === A) {
      const ie = W.getNextSibling();
      e.$isTextNode(ie) && (ce = 0, ae = 0, W = ie);
    }
    if (j.length === 1) {
      if (e.$isTextNode(W)) {
        if (ae = Me === "element" ? 0 : ce > J ? J : ce, Te = ze === "element" ? A : ce > J ? ce : J, ae === Te)
          return;
        if (ae === 0 && Te === A)
          F(W, w), W.select(ae, Te);
        else {
          const ie = W.splitText(ae, Te), ue = ae === 0 ? ie[0] : ie[1];
          F(ue, w), ue.select(0, Te - ae);
        }
      }
    } else {
      if (e.$isTextNode(W) && ae < W.getTextContentSize() && (ae !== 0 && (W = W.splitText(ae)[1], ae = 0, b.set(W.getKey(), ae, "text")), F(W, w)), e.$isTextNode(Q)) {
        const ue = Q.getTextContent().length;
        Q.__key !== oe && Te !== 0 && (Te = ue), Te !== ue && ([Q] = Q.splitText(Te)), Te !== 0 && F(Q, w);
      }
      for (let ie = 1; ie < Y; ie++) {
        const ue = j[ie], we = ue.getKey();
        e.$isTextNode(ue) && we !== W.getKey() && we !== Q.getKey() && !ue.isToken() && F(ue, w);
      }
    }
  }
  function I(P, w) {
    if (P.anchor.key === "root") {
      const Y = w(), W = e.$getRoot(), Q = W.getFirstChild();
      Q ? Q.replace(Y, true) : W.append(Y);
      return;
    }
    const j = P.getNodes(), ne = ee(P.anchor.getNode(), Z);
    ne && j.indexOf(ne) === -1 && j.push(ne);
    for (let Y = 0; Y < j.length; Y++) {
      const W = j[Y];
      if (!Z(W))
        continue;
      const Q = w();
      Q.setFormat(W.getFormatType()), Q.setIndent(W.getIndent()), W.replace(Q, true);
    }
  }
  function K(P) {
    return P.getNode().isAttached();
  }
  function B(P) {
    let w = P;
    for (; w !== null && !e.$isRootOrShadowRoot(w); ) {
      const j = w.getLatest(), ne = w.getParent();
      j.getChildrenSize() === 0 && w.remove(true), w = ne;
    }
  }
  function z(P, w, j = null) {
    const ne = P.getNodes(), Y = ne.length, W = P.anchor;
    if (Y === 0 || Y === 1 && W.type === "element" && W.getNode().getChildrenSize() === 0) {
      const g = W.type === "text" ? W.getNode().getParentOrThrow() : W.getNode(), _ = g.getChildren();
      let A = w();
      A.setFormat(g.getFormatType()), A.setIndent(g.getIndent()), _.forEach((J) => A.append(J)), j && (A = j.append(A)), g.replace(A);
      return;
    }
    let Q = null, b = [];
    for (let g = 0; g < Y; g++) {
      const _ = ne[g];
      e.$isRootOrShadowRoot(_) ? (te(P, b, b.length, w, j), b = [], Q = _) : Q === null || Q !== null && e.$hasAncestor(_, Q) ? b.push(_) : (te(P, b, b.length, w, j), b = [_]);
    }
    te(P, b, b.length, w, j);
  }
  function te(P, w, j, ne, Y = null) {
    if (w.length === 0)
      return;
    const W = w[0], Q = /* @__PURE__ */ new Map(), b = [];
    let g = e.$isElementNode(W) ? W : W.getParentOrThrow();
    g.isInline() && (g = g.getParentOrThrow());
    let _ = false;
    for (; g !== null; ) {
      const ae = g.getPreviousSibling();
      if (ae !== null) {
        g = ae, _ = true;
        break;
      }
      if (g = g.getParentOrThrow(), e.$isRootOrShadowRoot(g))
        break;
    }
    const A = /* @__PURE__ */ new Set();
    for (let ae = 0; ae < j; ae++) {
      const Te = w[ae];
      e.$isElementNode(Te) && Te.getChildrenSize() === 0 && A.add(Te.getKey());
    }
    const J = /* @__PURE__ */ new Set();
    for (let ae = 0; ae < j; ae++) {
      const Te = w[ae];
      let Me = Te.getParent();
      if (Me !== null && Me.isInline() && (Me = Me.getParent()), Me !== null && e.$isLeafNode(Te) && !J.has(Te.getKey())) {
        const ze = Me.getKey();
        if (Q.get(ze) === void 0) {
          const oe = ne();
          oe.setFormat(Me.getFormatType()), oe.setIndent(Me.getIndent()), b.push(oe), Q.set(ze, oe), Me.getChildren().forEach((ie) => {
            oe.append(ie), J.add(ie.getKey()), e.$isElementNode(ie) && ie.getChildrenKeys().forEach((ue) => J.add(ue));
          }), B(Me);
        }
      } else if (A.has(Te.getKey())) {
        const ze = ne();
        ze.setFormat(Te.getFormatType()), ze.setIndent(Te.getIndent()), b.push(ze), Te.remove(true);
      }
    }
    if (Y !== null)
      for (let ae = 0; ae < b.length; ae++) {
        const Te = b[ae];
        Y.append(Te);
      }
    let ce = null;
    if (e.$isRootOrShadowRoot(g))
      if (_)
        if (Y !== null)
          g.insertAfter(Y);
        else
          for (let ae = b.length - 1; ae >= 0; ae--) {
            const Te = b[ae];
            g.insertAfter(Te);
          }
      else {
        const ae = g.getFirstChild();
        if (e.$isElementNode(ae) && (g = ae), ae === null)
          if (Y)
            g.append(Y);
          else
            for (let Te = 0; Te < b.length; Te++) {
              const Me = b[Te];
              g.append(Me), ce = Me;
            }
        else if (Y !== null)
          ae.insertBefore(Y);
        else
          for (let Te = 0; Te < b.length; Te++) {
            const Me = b[Te];
            ae.insertBefore(Me), ce = Me;
          }
      }
    else if (Y)
      g.insertAfter(Y);
    else
      for (let ae = b.length - 1; ae >= 0; ae--) {
        const Te = b[ae];
        g.insertAfter(Te), ce = Te;
      }
    const ge = e.$getPreviousSelection();
    e.$isRangeSelection(ge) && K(ge.anchor) && K(ge.focus) ? e.$setSelection(ge.clone()) : ce !== null ? ce.selectEnd() : P.dirty = true;
  }
  function re(P, w) {
    const j = e.$getAdjacentNode(P.focus, w);
    return e.$isDecoratorNode(j) && !j.isIsolated() || e.$isElementNode(j) && !j.isInline() && !j.canBeEmpty();
  }
  function de(P, w, j, ne) {
    P.modify(w ? "extend" : "move", j, ne);
  }
  function V(P) {
    const w = P.anchor.getNode();
    return (e.$isRootNode(w) ? w : w.getParentOrThrow()).getDirection() === "rtl";
  }
  function G(P, w, j) {
    const ne = V(P);
    de(P, w, j ? !ne : ne, "character");
  }
  function q(P) {
    const w = P.anchor, j = P.focus, W = w.getNode().getTopLevelElementOrThrow().getParentOrThrow();
    let Q = W.getFirstDescendant(), b = W.getLastDescendant(), g = "element", _ = "element", A = 0;
    e.$isTextNode(Q) ? g = "text" : !e.$isElementNode(Q) && Q !== null && (Q = Q.getParentOrThrow()), e.$isTextNode(b) ? (_ = "text", A = b.getTextContentSize()) : !e.$isElementNode(b) && b !== null && (b = b.getParentOrThrow()), Q && b && (w.set(Q.getKey(), 0, g), j.set(b.getKey(), A, _));
  }
  function me(P, w, j) {
    const ne = P.getStyle(), Y = T(ne);
    return Y !== null && Y[w] || j;
  }
  function pe(P, w, j = "") {
    let ne = null;
    const Y = P.getNodes(), W = P.anchor, Q = P.focus, b = P.isBackward(), g = b ? Q.offset : W.offset, _ = b ? Q.getNode() : W.getNode();
    if (P.isCollapsed() && P.style !== "") {
      const A = P.style, J = T(A);
      if (J !== null && w in J)
        return J[w];
    }
    for (let A = 0; A < Y.length; A++) {
      const J = Y[A];
      if (!(A !== 0 && g === 0 && J.is(_)) && e.$isTextNode(J)) {
        const ce = me(J, w, j);
        if (ne === null)
          ne = ce;
        else if (ne !== ce) {
          ne = "";
          break;
        }
      }
    }
    return ne === null ? j : ne;
  }
  function Z(P) {
    if (e.$isDecoratorNode(P) && !P.isInline())
      return true;
    if (!e.$isElementNode(P) || e.$isRootOrShadowRoot(P))
      return false;
    const w = P.getFirstChild(), j = w === null || e.$isLineBreakNode(w) || e.$isTextNode(w) || w.isInline();
    return !P.isInline() && P.canBeEmpty() !== false && j;
  }
  function ee(P, w) {
    let j = P;
    for (; j !== null && j.getParent() !== null && !w(j); )
      j = j.getParentOrThrow();
    return w(j) ? j : null;
  }
  return In.$addNodeStyle = v, In.$cloneWithProperties = D, In.$getSelectionStyleValueForProperty = pe, In.$isAtNodeEnd = H, In.$isParentElementRTL = V, In.$moveCaretSelection = de, In.$moveCharacter = G, In.$patchStyleText = U, In.$selectAll = q, In.$setBlocksType = I, In.$shouldOverrideDefaultCharacterSelection = re, In.$sliceSelectedTextNodeContent = k, In.$wrapNodes = z, In.createDOMRange = f, In.createRectsFromDOMRange = h, In.getStyleObjectFromCSS = T, In.trimTextContentFromAnchor = N, In;
}
var za;
var Zu;
function oo() {
  return Zu || (Zu = 1, za = true ? Qp() : Xp()), za;
}
var hn = {};
var Qu;
function t_() {
  if (Qu)
    return hn;
  Qu = 1;
  var e = oo(), t = kt();
  function r(...re) {
    return () => {
      re.forEach((de) => de());
    };
  }
  function o(re) {
    return `${re}px`;
  }
  const f = {
    attributes: true,
    characterData: true,
    childList: true,
    subtree: true
  };
  function h(re, de, V) {
    let G = null, q = null, me = null, pe = [];
    const Z = document.createElement("div");
    function ee() {
      if (G === null)
        throw Error("Unexpected null rootDOMNode");
      if (q === null)
        throw Error("Unexpected null parentDOMNode");
      const {
        left: ne,
        top: Y
      } = G.getBoundingClientRect(), W = q, Q = e.createRectsFromDOMRange(re, de);
      Z.isConnected || W.append(Z);
      let b = false;
      for (let g = 0; g < Q.length; g++) {
        const _ = Q[g], A = pe[g] || document.createElement("div"), J = A.style;
        J.position !== "absolute" && (J.position = "absolute", b = true);
        const ce = o(_.left - ne);
        J.left !== ce && (J.left = ce, b = true);
        const ge = o(_.top - Y);
        J.top !== ge && (A.style.top = ge, b = true);
        const ae = o(_.width);
        J.width !== ae && (A.style.width = ae, b = true);
        const Te = o(_.height);
        J.height !== Te && (A.style.height = Te, b = true), A.parentNode !== Z && (Z.append(A), b = true), pe[g] = A;
      }
      for (; pe.length > Q.length; )
        pe.pop();
      b && V(pe);
    }
    function P() {
      q = null, G = null, me !== null && me.disconnect(), me = null, Z.remove();
      for (const ne of pe)
        ne.remove();
      pe = [];
    }
    function w() {
      const ne = re.getRootElement();
      if (ne === null)
        return P();
      const Y = ne.parentElement;
      if (!(Y instanceof HTMLElement))
        return P();
      P(), G = ne, q = Y, me = new MutationObserver((W) => {
        const Q = re.getRootElement(), b = Q && Q.parentElement;
        if (Q !== G || b !== q)
          return w();
        for (const g of W)
          if (!Z.contains(g.target))
            return ee();
      }), me.observe(Y, f), ee();
    }
    const j = re.registerRootListener(w);
    return () => {
      j(), P();
    };
  }
  function C(re, de) {
    let V = null, G = null, q = null, me = null, pe = () => {
    };
    function Z(ee) {
      ee.read(() => {
        const P = t.$getSelection();
        if (!t.$isRangeSelection(P)) {
          V = null, G = null, q = null, me = null, pe(), pe = () => {
          };
          return;
        }
        const {
          anchor: w,
          focus: j
        } = P, ne = w.getNode(), Y = ne.getKey(), W = w.offset, Q = j.getNode(), b = Q.getKey(), g = j.offset, _ = re.getElementByKey(Y), A = re.getElementByKey(b), J = V === null || _ === null || W !== G || Y !== V.getKey() || ne !== V && (!(V instanceof t.TextNode) || ne.updateDOM(V, _, re._config)), ce = q === null || A === null || g !== me || b !== q.getKey() || Q !== q && (!(q instanceof t.TextNode) || Q.updateDOM(q, A, re._config));
        if (J || ce) {
          const ge = re.getElementByKey(w.getNode().getKey()), ae = re.getElementByKey(j.getNode().getKey());
          if (ge !== null && ae !== null && ge.tagName === "SPAN" && ae.tagName === "SPAN") {
            const Te = document.createRange();
            let Me, ze, oe, ie;
            j.isBefore(w) ? (Me = ae, ze = j.offset, oe = ge, ie = w.offset) : (Me = ge, ze = w.offset, oe = ae, ie = j.offset);
            const ue = Me.firstChild;
            if (ue === null)
              throw Error("Expected text node to be first child of span");
            const we = oe.firstChild;
            if (we === null)
              throw Error("Expected text node to be first child of span");
            Te.setStart(ue, ze), Te.setEnd(we, ie), pe(), pe = h(re, Te, (Le) => {
              for (const Be of Le) {
                const Ye = Be.style;
                Ye.background !== "Highlight" && (Ye.background = "Highlight"), Ye.color !== "HighlightText" && (Ye.color = "HighlightText"), Ye.zIndex !== "-1" && (Ye.zIndex = "-1"), Ye.pointerEvents !== "none" && (Ye.pointerEvents = "none"), Ye.marginTop !== o(-1.5) && (Ye.marginTop = o(-1.5)), Ye.paddingTop !== o(4) && (Ye.paddingTop = o(4)), Ye.paddingBottom !== o(0) && (Ye.paddingBottom = o(0));
              }
              de !== void 0 && de(Le);
            });
          }
        }
        V = ne, G = W, q = Q, me = g;
      });
    }
    return Z(re.getEditorState()), r(re.registerUpdateListener(({
      editorState: ee
    }) => Z(ee)), pe, () => {
      pe();
    });
  }
  function T(re, ...de) {
    de.forEach((V) => {
      if (typeof V == "string") {
        const G = V.split(" ").filter((q) => q !== "");
        re.classList.add(...G);
      }
    });
  }
  function O(re, ...de) {
    de.forEach((V) => {
      typeof V == "string" && re.classList.remove(...V.split(" "));
    });
  }
  function S(re, de) {
    for (const V of de)
      if (re.type.startsWith(V))
        return true;
    return false;
  }
  function x(re, de) {
    const V = re[Symbol.iterator]();
    return new Promise((G, q) => {
      const me = [], pe = () => {
        const {
          done: Z,
          value: ee
        } = V.next();
        if (Z)
          return G(me);
        const P = new FileReader();
        P.addEventListener("error", q), P.addEventListener("load", () => {
          const w = P.result;
          typeof w == "string" && me.push({
            file: ee,
            result: w
          }), pe();
        }), S(ee, de) ? P.readAsDataURL(ee) : pe();
      };
      pe();
    });
  }
  function D(re, de) {
    const V = [], G = (re || t.$getRoot()).getLatest(), q = de || (t.$isElementNode(G) ? G.getLastDescendant() : G);
    let me = G, pe = k(me);
    for (; me !== null && !me.is(q); )
      if (V.push({
        depth: pe,
        node: me
      }), t.$isElementNode(me) && me.getChildrenSize() > 0)
        me = me.getFirstChild(), pe++;
      else {
        let Z = null;
        for (; Z === null && me !== null; )
          Z = me.getNextSibling(), Z === null ? (me = me.getParent(), pe--) : me = Z;
      }
    return me !== null && me.is(q) && V.push({
      depth: pe,
      node: me
    }), V;
  }
  function k(re) {
    let de = re, V = 0;
    for (; (de = de.getParent()) !== null; )
      V++;
    return V;
  }
  function H(re, de) {
    let V = re;
    for (; V != null; ) {
      if (V instanceof de)
        return V;
      V = V.getParent();
    }
    return null;
  }
  function N(re) {
    const de = v(re, (V) => t.$isElementNode(V) && !V.isInline());
    if (!t.$isElementNode(de))
      throw Error(`Expected node ${re.__key} to have closest block element node.`);
    return de;
  }
  function v(re, de) {
    let V = re;
    for (; V !== t.$getRoot() && V != null; ) {
      if (de(V))
        return V;
      V = V.getParent();
    }
    return null;
  }
  function F(re, de, V, G) {
    const q = (Z) => Z instanceof de, me = (Z) => {
      const ee = Z.getChildren();
      for (let j = 0; j < ee.length; j++) {
        const ne = ee[j];
        if (q(ne))
          return null;
      }
      let P = Z, w = Z;
      for (; P !== null; )
        if (w = P, P = P.getParent(), q(P))
          return {
            child: w,
            parent: P
          };
      return null;
    }, pe = (Z) => {
      const ee = me(Z);
      if (ee !== null) {
        const {
          child: P,
          parent: w
        } = ee;
        if (P.is(Z)) {
          G(w, Z);
          const j = P.getNextSiblings(), ne = j.length;
          if (w.insertAfter(P), ne !== 0) {
            const Y = V(w);
            P.insertAfter(Y);
            for (let W = 0; W < ne; W++)
              Y.append(j[W]);
          }
          !w.canBeEmpty() && w.getChildrenSize() === 0 && w.remove();
        }
      }
    };
    return re.registerNodeTransform(de, pe);
  }
  function U(re, de) {
    const G = /* @__PURE__ */ new Map(), q = re._pendingEditorState;
    for (const [pe, Z] of de._nodeMap) {
      const ee = e.$cloneWithProperties(Z);
      t.$isTextNode(ee) && (ee.__text = Z.__text), G.set(pe, ee);
    }
    q && (q._nodeMap = G), re._dirtyType = 2;
    const me = de._selection;
    t.$setSelection(me === null ? null : me.clone());
  }
  function I(re) {
    const de = t.$getSelection() || t.$getPreviousSelection();
    if (t.$isRangeSelection(de)) {
      const {
        focus: V
      } = de, G = V.getNode(), q = V.offset;
      if (t.$isRootOrShadowRoot(G)) {
        const me = G.getChildAtIndex(q);
        me == null ? G.append(re) : me.insertBefore(re), re.selectNext();
      } else {
        let me, pe;
        t.$isTextNode(G) ? (me = G.getParentOrThrow(), pe = G.getIndexWithinParent(), q > 0 && (pe += 1, G.splitText(q))) : (me = G, pe = q);
        const [, Z] = t.$splitNode(me, pe);
        Z.insertBefore(re), Z.selectStart();
      }
    } else {
      if (de != null) {
        const G = de.getNodes();
        G[G.length - 1].getTopLevelElementOrThrow().insertAfter(re);
      } else
        t.$getRoot().append(re);
      const V = t.$createParagraphNode();
      re.insertAfter(V), V.select();
    }
    return re.getLatest();
  }
  function K(re, de) {
    const V = de();
    return re.replace(V), V.append(re), V;
  }
  function B(re, de) {
    return re !== null ? Object.getPrototypeOf(re).constructor.name === de.name : false;
  }
  function z(re, de) {
    const V = [];
    for (let G = 0; G < re.length; G++) {
      const q = de(re[G]);
      q !== null && V.push(q);
    }
    return V;
  }
  function te(re, de) {
    const V = re.getFirstChild();
    V !== null ? V.insertBefore(de) : re.append(de);
  }
  return hn.$splitNode = t.$splitNode, hn.isHTMLAnchorElement = t.isHTMLAnchorElement, hn.isHTMLElement = t.isHTMLElement, hn.$dfs = D, hn.$filter = z, hn.$findMatchingParent = v, hn.$getNearestBlockElementAncestorOrThrow = N, hn.$getNearestNodeOfType = H, hn.$insertFirst = te, hn.$insertNodeToNearestRoot = I, hn.$restoreEditorState = U, hn.$wrapNodeInElement = K, hn.addClassNamesToElement = T, hn.isMimeType = S, hn.markSelection = C, hn.mediaFileReader = x, hn.mergeRegister = r, hn.objectKlassEquals = B, hn.positionNodeOnRange = h, hn.registerNestedElementResolver = F, hn.removeClassNamesFromElement = O, hn;
}
var Ga;
var ed;
function Jt() {
  return ed || (ed = 1, Ga = true ? t_() : e_()), Ga;
}
var ja = {};
var nd;
function r_() {
  if (nd)
    return ja;
  nd = 1;
  var e = kt();
  function t(r) {
    const o = window.location.origin, f = (h) => {
      if (h.origin !== o)
        return;
      const C = r.getRootElement();
      if (document.activeElement !== C)
        return;
      const T = h.data;
      if (typeof T == "string") {
        let O;
        try {
          O = JSON.parse(T);
        } catch {
          return;
        }
        if (O && O.protocol === "nuanria_messaging" && O.type === "request") {
          const S = O.payload;
          if (S && S.functionId === "makeChanges") {
            const x = S.args;
            if (x) {
              const [D, k, H, N, v, F] = x;
              r.update(() => {
                const U = e.$getSelection();
                if (e.$isRangeSelection(U)) {
                  const I = U.anchor;
                  let K = I.getNode(), B = 0, z = 0;
                  if (e.$isTextNode(K) && D >= 0 && k >= 0 && (B = D, z = D + k, U.setTextNodeRange(K, B, K, z)), (B !== z || H !== "") && (U.insertRawText(H), K = I.getNode()), e.$isTextNode(K)) {
                    B = N, z = N + v;
                    const te = K.getTextContentSize();
                    B = B > te ? te : B, z = z > te ? te : z, U.setTextNodeRange(K, B, K, z);
                  }
                  h.stopImmediatePropagation();
                }
              });
            }
          }
        }
      }
    };
    return window.addEventListener("message", f, true), () => {
      window.removeEventListener("message", f, true);
    };
  }
  return ja.registerDragonSupport = t, ja;
}
var qa;
var rd;
function lh() {
  return rd || (rd = 1, qa = true ? r_() : n_()), qa;
}
var Jl = {};
var od;
function o_() {
  if (od)
    return Jl;
  od = 1;
  var e = oo(), t = Jt(), r = kt();
  function o(S, x) {
    const D = x.body ? x.body.childNodes : [];
    let k = [];
    for (let H = 0; H < D.length; H++) {
      const N = D[H];
      if (!T.has(N.nodeName)) {
        const v = O(N, S);
        v !== null && (k = k.concat(v));
      }
    }
    return k;
  }
  function f(S, x) {
    if (typeof document > "u" || typeof window > "u")
      throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
    const D = document.createElement("div"), H = r.$getRoot().getChildren();
    for (let N = 0; N < H.length; N++) {
      const v = H[N];
      h(S, v, D, x);
    }
    return D.innerHTML;
  }
  function h(S, x, D, k = null) {
    let H = k != null ? x.isSelected(k) : true;
    const N = r.$isElementNode(x) && x.excludeFromCopy("html");
    let v = x;
    if (k !== null) {
      let te = e.$cloneWithProperties(x);
      te = r.$isTextNode(te) && k != null ? e.$sliceSelectedTextNodeContent(k, te) : te, v = te;
    }
    const F = r.$isElementNode(v) ? v.getChildren() : [], U = S._nodes.get(v.getType());
    let I;
    U && U.exportDOM !== void 0 ? I = U.exportDOM(S, v) : I = v.exportDOM(S);
    const {
      element: K,
      after: B
    } = I;
    if (!K)
      return false;
    const z = document.createDocumentFragment();
    for (let te = 0; te < F.length; te++) {
      const re = F[te], de = h(S, re, z, k);
      !H && r.$isElementNode(x) && de && x.extractWithChild(re, k, "html") && (H = true);
    }
    if (H && !N) {
      if (t.isHTMLElement(K) && K.append(z), D.append(K), B) {
        const te = B.call(v, K);
        te && K.replaceWith(te);
      }
    } else
      D.append(z);
    return H;
  }
  function C(S, x) {
    const {
      nodeName: D
    } = S, k = x._htmlConversions.get(D.toLowerCase());
    let H = null;
    if (k !== void 0)
      for (const N of k) {
        const v = N(S);
        v !== null && (H === null || H.priority < v.priority) && (H = v);
      }
    return H !== null ? H.conversion : null;
  }
  const T = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
  function O(S, x, D = /* @__PURE__ */ new Map(), k) {
    let H = [];
    if (T.has(S.nodeName))
      return H;
    let N = null;
    const v = C(S, x), F = v ? v(S) : null;
    let U = null;
    if (F !== null) {
      U = F.after;
      const B = F.node;
      if (N = Array.isArray(B) ? B[B.length - 1] : B, N !== null) {
        for (const [, z] of D)
          if (N = z(N, k), !N)
            break;
        N && H.push(...Array.isArray(B) ? B : [N]);
      }
      F.forChild != null && D.set(S.nodeName, F.forChild);
    }
    const I = S.childNodes;
    let K = [];
    for (let B = 0; B < I.length; B++)
      K.push(...O(I[B], x, new Map(D), N));
    return U != null && (K = U(K)), N == null ? H = H.concat(K) : r.$isElementNode(N) && N.append(...K), H;
  }
  return Jl.$generateHtmlFromNodes = f, Jl.$generateNodesFromDOM = o, Jl;
}
var Va;
var sd;
function ah() {
  return sd || (sd = 1, Va = true ? o_() : i_()), Va;
}
var _i = {};
var ad;
function l_() {
  if (ad)
    return _i;
  ad = 1;
  var e = ah(), t = oo(), r = Jt(), o = kt();
  const f = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", h = (B) => f ? (B || window).getSelection() : null;
  function C(B) {
    const z = o.$getSelection();
    if (z == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(z) && z.isCollapsed() || z.getNodes().length === 0 ? "" : e.$generateHtmlFromNodes(B, z);
  }
  function T(B) {
    const z = o.$getSelection();
    if (z == null)
      throw Error("Expected valid LexicalSelection");
    return o.$isRangeSelection(z) && z.isCollapsed() || z.getNodes().length === 0 ? null : JSON.stringify(N(B, z));
  }
  function O(B, z) {
    const te = B.getData("text/plain") || B.getData("text/uri-list");
    te != null && z.insertRawText(te);
  }
  function S(B, z, te) {
    const re = B.getData("application/x-lexical-editor");
    if (re)
      try {
        const G = JSON.parse(re);
        if (G.namespace === te._config.namespace && Array.isArray(G.nodes)) {
          const q = v(G.nodes);
          return x(te, q, z);
        }
      } catch {
      }
    const de = B.getData("text/html");
    if (de)
      try {
        const q = new DOMParser().parseFromString(de, "text/html"), me = e.$generateNodesFromDOM(te, q);
        return x(te, me, z);
      } catch {
      }
    const V = B.getData("text/plain") || B.getData("text/uri-list");
    if (V != null)
      if (o.$isRangeSelection(z)) {
        const G = V.split(/(\r?\n|\t)/);
        G[G.length - 1] === "" && G.pop();
        for (let q = 0; q < G.length; q++) {
          const me = G[q];
          me === `
` || me === `\r
` ? z.insertParagraph() : me === "	" ? z.insertNodes([o.$createTabNode()]) : z.insertText(me);
        }
      } else
        z.insertRawText(V);
  }
  function x(B, z, te) {
    const re = o.DEPRECATED_$isGridSelection(te), de = o.$isRangeSelection(te);
    if ((re || de && r.$findMatchingParent(te.anchor.getNode(), (G) => o.DEPRECATED_$isGridCellNode(G)) !== null && r.$findMatchingParent(te.focus.getNode(), (G) => o.DEPRECATED_$isGridCellNode(G)) !== null) && z.length === 1 && o.DEPRECATED_$isGridNode(z[0])) {
      D(z, te, false, B);
      return;
    }
    te.insertNodes(z);
  }
  function D(B, z, te, re) {
    if (B.length !== 1 || !o.DEPRECATED_$isGridNode(B[0]))
      throw Error("$mergeGridNodesStrategy: Expected Grid insertion.");
    const de = B[0], V = de.getChildren(), G = de.getFirstChildOrThrow().getChildrenSize(), q = de.getChildrenSize(), me = r.$findMatchingParent(z.anchor.getNode(), (J) => o.DEPRECATED_$isGridCellNode(J)), pe = me && r.$findMatchingParent(me, (J) => o.DEPRECATED_$isGridRowNode(J)), Z = pe && r.$findMatchingParent(pe, (J) => o.DEPRECATED_$isGridNode(J));
    if (!o.DEPRECATED_$isGridCellNode(me) || !o.DEPRECATED_$isGridRowNode(pe) || !o.DEPRECATED_$isGridNode(Z))
      throw Error("$mergeGridNodesStrategy: Expected selection to be inside of a Grid.");
    const ee = pe.getIndexWithinParent(), P = Math.min(Z.getChildrenSize() - 1, ee + q - 1), w = me.getIndexWithinParent(), j = Math.min(pe.getChildrenSize() - 1, w + G - 1), ne = Math.min(w, j), Y = Math.min(ee, P), W = Math.max(w, j), Q = Math.max(ee, P), b = Z.getChildren();
    let g = 0, _, A;
    for (let J = Y; J <= Q; J++) {
      const ce = b[J];
      if (!o.DEPRECATED_$isGridRowNode(ce))
        throw Error("getNodes: expected to find GridRowNode");
      const ge = V[g];
      if (!o.DEPRECATED_$isGridRowNode(ge))
        throw Error("getNodes: expected to find GridRowNode");
      const ae = ce.getChildren(), Te = ge.getChildren();
      let Me = 0;
      for (let ze = ne; ze <= W; ze++) {
        const oe = ae[ze];
        if (!o.DEPRECATED_$isGridCellNode(oe))
          throw Error("getNodes: expected to find GridCellNode");
        const ie = Te[Me];
        if (!o.DEPRECATED_$isGridCellNode(ie))
          throw Error("getNodes: expected to find GridCellNode");
        J === Y && ze === ne ? _ = oe.getKey() : J === Q && ze === W && (A = oe.getKey());
        const ue = oe.getChildren();
        ie.getChildren().forEach((we) => {
          o.$isTextNode(we) && o.$createParagraphNode().append(we), oe.append(we);
        }), ue.forEach((we) => we.remove()), Me++;
      }
      g++;
    }
    if (_ && A) {
      const J = o.DEPRECATED_$createGridSelection();
      J.set(Z.getKey(), _, A), o.$setSelection(J), re.dispatchCommand(o.SELECTION_CHANGE_COMMAND, void 0);
    }
  }
  function k(B) {
    const z = B.exportJSON(), te = B.constructor;
    if (z.type !== te.getType())
      throw Error(`LexicalNode: Node ${te.name} does not implement .exportJSON().`);
    const re = z.children;
    if (o.$isElementNode(B) && !Array.isArray(re))
      throw Error(`LexicalNode: Node ${te.name} is an element but .exportJSON() does not have a children array.`);
    return z;
  }
  function H(B, z, te, re = []) {
    let de = z != null ? te.isSelected(z) : true;
    const V = o.$isElementNode(te) && te.excludeFromCopy("html");
    let G = te;
    if (z !== null) {
      let pe = t.$cloneWithProperties(te);
      pe = o.$isTextNode(pe) && z != null ? t.$sliceSelectedTextNodeContent(z, pe) : pe, G = pe;
    }
    const q = o.$isElementNode(G) ? G.getChildren() : [], me = k(G);
    if (o.$isTextNode(G)) {
      const pe = G.__text;
      pe.length > 0 ? me.text = pe : de = false;
    }
    for (let pe = 0; pe < q.length; pe++) {
      const Z = q[pe], ee = H(B, z, Z, me.children);
      !de && o.$isElementNode(te) && ee && te.extractWithChild(Z, z, "clone") && (de = true);
    }
    if (de && !V)
      re.push(me);
    else if (Array.isArray(me.children))
      for (let pe = 0; pe < me.children.length; pe++) {
        const Z = me.children[pe];
        re.push(Z);
      }
    return de;
  }
  function N(B, z) {
    const te = [], de = o.$getRoot().getChildren();
    for (let V = 0; V < de.length; V++) {
      const G = de[V];
      H(B, z, G, te);
    }
    return {
      namespace: B._config.namespace,
      nodes: te
    };
  }
  function v(B) {
    const z = [];
    for (let te = 0; te < B.length; te++) {
      const re = B[te], de = o.$parseSerializedNode(re);
      o.$isTextNode(de) && t.$addNodeStyle(de), z.push(de);
    }
    return z;
  }
  const F = 50;
  let U = null;
  async function I(B, z) {
    if (U !== null)
      return false;
    if (z !== null)
      return new Promise((q, me) => {
        B.update(() => {
          q(K(B, z));
        });
      });
    const te = B.getRootElement(), re = B._window == null ? window.document : B._window.document, de = h(B._window);
    if (te === null || de === null)
      return false;
    const V = re.createElement("span");
    V.style.cssText = "position: fixed; top: -1000px;", V.append(re.createTextNode("#")), te.append(V);
    const G = new Range();
    return G.setStart(V, 0), G.setEnd(V, 1), de.removeAllRanges(), de.addRange(G), new Promise((q, me) => {
      const pe = B.registerCommand(o.COPY_COMMAND, (Z) => (r.objectKlassEquals(Z, ClipboardEvent) && (pe(), U !== null && (window.clearTimeout(U), U = null), q(K(B, Z))), true), o.COMMAND_PRIORITY_CRITICAL);
      U = window.setTimeout(() => {
        pe(), U = null, q(false);
      }, F), re.execCommand("copy"), V.remove();
    });
  }
  function K(B, z) {
    const te = h(B._window);
    if (!te)
      return false;
    const re = te.anchorNode, de = te.focusNode;
    if (re !== null && de !== null && !o.isSelectionWithinEditor(B, re, de))
      return false;
    z.preventDefault();
    const V = z.clipboardData, G = o.$getSelection();
    if (V === null || G === null)
      return false;
    const q = C(B), me = T(B);
    let pe = "";
    return G !== null && (pe = G.getTextContent()), q !== null && V.setData("text/html", q), me !== null && V.setData("application/x-lexical-editor", me), V.setData("text/plain", pe), true;
  }
  return _i.$generateJSONFromSelectedNodes = N, _i.$generateNodesFromSerializedNodes = v, _i.$getHtmlContent = C, _i.$getLexicalContent = T, _i.$insertDataTransferForPlainText = O, _i.$insertDataTransferForRichText = S, _i.$insertGeneratedNodes = x, _i.copyToClipboard = I, _i;
}
var Ja;
var cd;
function ch() {
  return cd || (cd = 1, Ja = true ? l_() : s_()), Ja;
}
var Zr = {};
var dd;
function c_() {
  if (dd)
    return Zr;
  dd = 1;
  var e = ch(), t = oo(), r = Jt(), o = kt();
  function f(pe, Z) {
    if (typeof document.caretRangeFromPoint < "u") {
      const ee = document.caretRangeFromPoint(pe, Z);
      return ee === null ? null : {
        node: ee.startContainer,
        offset: ee.startOffset
      };
    } else if (document.caretPositionFromPoint !== "undefined") {
      const ee = document.caretPositionFromPoint(pe, Z);
      return ee === null ? null : {
        node: ee.offsetNode,
        offset: ee.offset
      };
    } else
      return null;
  }
  const h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", C = h && "documentMode" in document ? document.documentMode : null, T = h && "InputEvent" in window && !C ? "getTargetRanges" in new window.InputEvent("input") : false, O = h && /Version\/[\d.]+.*Safari/.test(navigator.userAgent), S = h && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, x = h && /^(?=.*Chrome).*/i.test(navigator.userAgent), D = h && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !x, k = o.createCommand("DRAG_DROP_PASTE_FILE");
  class H extends o.ElementNode {
    static getType() {
      return "quote";
    }
    static clone(Z) {
      return new H(Z.__key);
    }
    constructor(Z) {
      super(Z);
    }
    // View
    createDOM(Z) {
      const ee = document.createElement("blockquote");
      return r.addClassNamesToElement(ee, Z.theme.quote), ee;
    }
    updateDOM(Z, ee) {
      return false;
    }
    static importDOM() {
      return {
        blockquote: (Z) => ({
          conversion: K,
          priority: 0
        })
      };
    }
    exportDOM(Z) {
      const {
        element: ee
      } = super.exportDOM(Z);
      if (ee && r.isHTMLElement(ee)) {
        this.isEmpty() && ee.append(document.createElement("br"));
        const P = this.getFormatType();
        ee.style.textAlign = P;
        const w = this.getDirection();
        w && (ee.dir = w);
      }
      return {
        element: ee
      };
    }
    static importJSON(Z) {
      const ee = N();
      return ee.setFormat(Z.format), ee.setIndent(Z.indent), ee.setDirection(Z.direction), ee;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "quote"
      };
    }
    // Mutation
    insertNewAfter(Z, ee) {
      const P = o.$createParagraphNode(), w = this.getDirection();
      return P.setDirection(w), this.insertAfter(P, ee), P;
    }
    collapseAtStart() {
      const Z = o.$createParagraphNode();
      return this.getChildren().forEach((P) => Z.append(P)), this.replace(Z), true;
    }
  }
  function N() {
    return o.$applyNodeReplacement(new H());
  }
  function v(pe) {
    return pe instanceof H;
  }
  class F extends o.ElementNode {
    /** @internal */
    static getType() {
      return "heading";
    }
    static clone(Z) {
      return new F(Z.__tag, Z.__key);
    }
    constructor(Z, ee) {
      super(ee), this.__tag = Z;
    }
    getTag() {
      return this.__tag;
    }
    // View
    createDOM(Z) {
      const ee = this.__tag, P = document.createElement(ee), j = Z.theme.heading;
      if (j !== void 0) {
        const ne = j[ee];
        r.addClassNamesToElement(P, ne);
      }
      return P;
    }
    updateDOM(Z, ee) {
      return false;
    }
    static importDOM() {
      return {
        h1: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h2: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h3: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h4: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h5: (Z) => ({
          conversion: I,
          priority: 0
        }),
        h6: (Z) => ({
          conversion: I,
          priority: 0
        }),
        p: (Z) => {
          const P = Z.firstChild;
          return P !== null && U(P) ? {
            conversion: () => ({
              node: null
            }),
            priority: 3
          } : null;
        },
        span: (Z) => U(Z) ? {
          conversion: (ee) => ({
            node: B("h1")
          }),
          priority: 3
        } : null
      };
    }
    exportDOM(Z) {
      const {
        element: ee
      } = super.exportDOM(Z);
      if (ee && r.isHTMLElement(ee)) {
        this.isEmpty() && ee.append(document.createElement("br"));
        const P = this.getFormatType();
        ee.style.textAlign = P;
        const w = this.getDirection();
        w && (ee.dir = w);
      }
      return {
        element: ee
      };
    }
    static importJSON(Z) {
      const ee = B(Z.tag);
      return ee.setFormat(Z.format), ee.setIndent(Z.indent), ee.setDirection(Z.direction), ee;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        tag: this.getTag(),
        type: "heading",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(Z, ee = true) {
      const P = Z ? Z.anchor.offset : 0, w = P === this.getTextContentSize() || !Z ? o.$createParagraphNode() : B(this.getTag()), j = this.getDirection();
      if (w.setDirection(j), this.insertAfter(w, ee), P === 0 && !this.isEmpty() && Z) {
        const ne = o.$createParagraphNode();
        ne.select(), this.replace(ne, true);
      }
      return w;
    }
    collapseAtStart() {
      const Z = this.isEmpty() ? o.$createParagraphNode() : B(this.getTag());
      return this.getChildren().forEach((P) => Z.append(P)), this.replace(Z), true;
    }
    extractWithChild() {
      return true;
    }
  }
  function U(pe) {
    return pe.nodeName.toLowerCase() === "span" ? pe.style.fontSize === "26pt" : false;
  }
  function I(pe) {
    const Z = pe.nodeName.toLowerCase();
    let ee = null;
    return (Z === "h1" || Z === "h2" || Z === "h3" || Z === "h4" || Z === "h5" || Z === "h6") && (ee = B(Z), pe.style !== null && ee.setFormat(pe.style.textAlign)), {
      node: ee
    };
  }
  function K(pe) {
    const Z = N();
    return pe.style !== null && Z.setFormat(pe.style.textAlign), {
      node: Z
    };
  }
  function B(pe) {
    return o.$applyNodeReplacement(new F(pe));
  }
  function z(pe) {
    return pe instanceof F;
  }
  function te(pe, Z) {
    pe.preventDefault(), Z.update(() => {
      const ee = o.$getSelection(), P = pe instanceof InputEvent || pe instanceof KeyboardEvent ? null : pe.clipboardData;
      P != null && o.$INTERNAL_isPointSelection(ee) && e.$insertDataTransferForRichText(P, ee, Z);
    }, {
      tag: "paste"
    });
  }
  async function re(pe, Z) {
    await e.copyToClipboard(Z, r.objectKlassEquals(pe, ClipboardEvent) ? pe : null), Z.update(() => {
      const ee = o.$getSelection();
      o.$isRangeSelection(ee) ? ee.removeText() : o.$isNodeSelection(ee) && ee.getNodes().forEach((P) => P.remove());
    });
  }
  function de(pe) {
    let Z = null;
    if (pe instanceof DragEvent ? Z = pe.dataTransfer : pe instanceof ClipboardEvent && (Z = pe.clipboardData), Z === null)
      return [false, [], false];
    const ee = Z.types, P = ee.includes("Files"), w = ee.includes("text/html") || ee.includes("text/plain");
    return [P, Array.from(Z.files), w];
  }
  function V(pe) {
    const Z = o.$getSelection();
    if (!o.$isRangeSelection(Z))
      return false;
    const ee = /* @__PURE__ */ new Set(), P = Z.getNodes();
    for (let w = 0; w < P.length; w++) {
      const j = P[w], ne = j.getKey();
      if (ee.has(ne))
        continue;
      const Y = r.$getNearestBlockElementAncestorOrThrow(j), W = Y.getKey();
      Y.canIndent() && !ee.has(W) && (ee.add(W), pe(Y));
    }
    return ee.size > 0;
  }
  function G(pe) {
    const Z = o.$getNearestNodeFromDOMNode(pe);
    return o.$isDecoratorNode(Z);
  }
  function q(pe) {
    const Z = pe.focus;
    return Z.key === "root" && Z.offset === o.$getRoot().getChildrenSize();
  }
  function me(pe) {
    return r.mergeRegister(pe.registerCommand(o.CLICK_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isNodeSelection(P) ? (P.clear(), true) : false;
    }, 0), pe.registerCommand(o.DELETE_CHARACTER_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.deleteCharacter(ee), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DELETE_WORD_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.deleteWord(ee), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DELETE_LINE_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.deleteLine(ee), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.CONTROLLED_TEXT_INSERTION_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (typeof ee == "string")
        o.$INTERNAL_isPointSelection(P) && P.insertText(ee);
      else {
        if (!o.$INTERNAL_isPointSelection(P))
          return false;
        const w = ee.dataTransfer;
        if (w != null)
          e.$insertDataTransferForRichText(w, P, pe);
        else if (o.$isRangeSelection(P)) {
          const j = ee.data;
          return j && P.insertText(j), true;
        }
      }
      return true;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.REMOVE_TEXT_COMMAND, () => {
      const ee = o.$getSelection();
      return o.$isRangeSelection(ee) ? (ee.removeText(), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.FORMAT_TEXT_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.formatText(ee), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.FORMAT_ELEMENT_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (!o.$isRangeSelection(P) && !o.$isNodeSelection(P))
        return false;
      const w = P.getNodes();
      for (const j of w) {
        const ne = r.$findMatchingParent(j, (Y) => o.$isElementNode(Y) && !Y.isInline());
        ne !== null && ne.setFormat(ee);
      }
      return true;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INSERT_LINE_BREAK_COMMAND, (ee) => {
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (P.insertLineBreak(ee), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INSERT_PARAGRAPH_COMMAND, () => {
      const ee = o.$getSelection();
      return o.$isRangeSelection(ee) ? (ee.insertParagraph(), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INSERT_TAB_COMMAND, () => (o.$insertNodes([o.$createTabNode()]), true), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.INDENT_CONTENT_COMMAND, () => V((ee) => {
      const P = ee.getIndent();
      ee.setIndent(P + 1);
    }), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.OUTDENT_CONTENT_COMMAND, () => V((ee) => {
      const P = ee.getIndent();
      P > 0 && ee.setIndent(P - 1);
    }), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_UP_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P) && !G(ee.target)) {
        const w = P.getNodes();
        if (w.length > 0)
          return w[0].selectPrevious(), true;
      } else if (o.$isRangeSelection(P)) {
        const w = o.$getAdjacentNode(P.focus, true);
        if (!ee.shiftKey && o.$isDecoratorNode(w) && !w.isIsolated() && !w.isInline())
          return w.selectPrevious(), ee.preventDefault(), true;
      }
      return false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_DOWN_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P)) {
        const w = P.getNodes();
        if (w.length > 0)
          return w[0].selectNext(0, 0), true;
      } else if (o.$isRangeSelection(P)) {
        if (q(P))
          return ee.preventDefault(), true;
        const w = o.$getAdjacentNode(P.focus, false);
        if (!ee.shiftKey && o.$isDecoratorNode(w) && !w.isIsolated() && !w.isInline())
          return w.selectNext(), ee.preventDefault(), true;
      }
      return false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_LEFT_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P)) {
        const w = P.getNodes();
        if (w.length > 0)
          return ee.preventDefault(), w[0].selectPrevious(), true;
      }
      if (!o.$isRangeSelection(P))
        return false;
      if (t.$shouldOverrideDefaultCharacterSelection(P, true)) {
        const w = ee.shiftKey;
        return ee.preventDefault(), t.$moveCharacter(P, w, true), true;
      }
      return false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ARROW_RIGHT_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (o.$isNodeSelection(P) && !G(ee.target)) {
        const j = P.getNodes();
        if (j.length > 0)
          return ee.preventDefault(), j[0].selectNext(0, 0), true;
      }
      if (!o.$isRangeSelection(P))
        return false;
      const w = ee.shiftKey;
      return t.$shouldOverrideDefaultCharacterSelection(P, false) ? (ee.preventDefault(), t.$moveCharacter(P, w, false), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_BACKSPACE_COMMAND, (ee) => {
      if (G(ee.target))
        return false;
      const P = o.$getSelection();
      if (!o.$isRangeSelection(P))
        return false;
      ee.preventDefault();
      const {
        anchor: w
      } = P, j = w.getNode();
      return P.isCollapsed() && w.offset === 0 && !o.$isRootNode(j) && r.$getNearestBlockElementAncestorOrThrow(j).getIndent() > 0 ? pe.dispatchCommand(o.OUTDENT_CONTENT_COMMAND, void 0) : pe.dispatchCommand(o.DELETE_CHARACTER_COMMAND, true);
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_DELETE_COMMAND, (ee) => {
      if (G(ee.target))
        return false;
      const P = o.$getSelection();
      return o.$isRangeSelection(P) ? (ee.preventDefault(), pe.dispatchCommand(o.DELETE_CHARACTER_COMMAND, false)) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ENTER_COMMAND, (ee) => {
      const P = o.$getSelection();
      if (!o.$isRangeSelection(P))
        return false;
      if (ee !== null) {
        if ((S || O || D) && T)
          return false;
        if (ee.preventDefault(), ee.shiftKey)
          return pe.dispatchCommand(o.INSERT_LINE_BREAK_COMMAND, false);
      }
      return pe.dispatchCommand(o.INSERT_PARAGRAPH_COMMAND, void 0);
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.KEY_ESCAPE_COMMAND, () => {
      const ee = o.$getSelection();
      return o.$isRangeSelection(ee) ? (pe.blur(), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DROP_COMMAND, (ee) => {
      const [, P] = de(ee);
      if (P.length > 0) {
        const j = ee.clientX, ne = ee.clientY, Y = f(j, ne);
        if (Y !== null) {
          const {
            offset: W,
            node: Q
          } = Y, b = o.$getNearestNodeFromDOMNode(Q);
          if (b !== null) {
            const g = o.$createRangeSelection();
            if (o.$isTextNode(b))
              g.anchor.set(b.getKey(), W, "text"), g.focus.set(b.getKey(), W, "text");
            else {
              const A = b.getParentOrThrow().getKey(), J = b.getIndexWithinParent() + 1;
              g.anchor.set(A, J, "element"), g.focus.set(A, J, "element");
            }
            const _ = o.$normalizeSelection__EXPERIMENTAL(g);
            o.$setSelection(_);
          }
          pe.dispatchCommand(k, P);
        }
        return ee.preventDefault(), true;
      }
      const w = o.$getSelection();
      return !!o.$isRangeSelection(w);
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DRAGSTART_COMMAND, (ee) => {
      const [P] = de(ee), w = o.$getSelection();
      return !(P && !o.$isRangeSelection(w));
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.DRAGOVER_COMMAND, (ee) => {
      const [P] = de(ee), w = o.$getSelection();
      if (P && !o.$isRangeSelection(w))
        return false;
      const j = ee.clientX, ne = ee.clientY, Y = f(j, ne);
      if (Y !== null) {
        const W = o.$getNearestNodeFromDOMNode(Y.node);
        o.$isDecoratorNode(W) && ee.preventDefault();
      }
      return true;
    }, o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.SELECT_ALL_COMMAND, () => (o.$selectAll(), true), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.COPY_COMMAND, (ee) => (e.copyToClipboard(pe, r.objectKlassEquals(ee, ClipboardEvent) ? ee : null), true), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.CUT_COMMAND, (ee) => (re(ee, pe), true), o.COMMAND_PRIORITY_EDITOR), pe.registerCommand(o.PASTE_COMMAND, (ee) => {
      const [, P, w] = de(ee);
      if (P.length > 0 && !w)
        return pe.dispatchCommand(k, P), true;
      if (o.isSelectionCapturedInDecoratorInput(ee.target))
        return false;
      const j = o.$getSelection();
      return o.$INTERNAL_isPointSelection(j) ? (te(ee, pe), true) : false;
    }, o.COMMAND_PRIORITY_EDITOR));
  }
  return Zr.$createHeadingNode = B, Zr.$createQuoteNode = N, Zr.$isHeadingNode = z, Zr.$isQuoteNode = v, Zr.DRAG_DROP_PASTE = k, Zr.HeadingNode = F, Zr.QuoteNode = H, Zr.eventFiles = de, Zr.registerRichText = me, Zr;
}
var Za;
var fd;
function $c() {
  return fd || (fd = 1, Za = true ? c_() : a_()), Za;
}
var Xa = {};
var gd;
function d_() {
  if (gd)
    return Xa;
  gd = 1;
  var e = kn(), t = oh(), r = import_react.default, o = sh(), f = Jt(), h = import_react_dom.default, C = lh(), T = $c(), x = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? r.useLayoutEffect : r.useEffect;
  function D(U) {
    return U.getEditorState().read(o.$canShowPlaceholderCurry(U.isComposing()));
  }
  function k(U) {
    const [I, K] = r.useState(() => D(U));
    return x(() => {
      function B() {
        const z = D(U);
        K(z);
      }
      return B(), f.mergeRegister(U.registerUpdateListener(() => {
        B();
      }), U.registerEditableListener(() => {
        B();
      }));
    }, [U]), I;
  }
  function H(U, I) {
    const [K, B] = r.useState(() => U.getDecorators());
    return x(() => U.registerDecoratorListener((z) => {
      h.flushSync(() => {
        B(z);
      });
    }), [U]), r.useEffect(() => {
      B(U.getDecorators());
    }, [U]), r.useMemo(() => {
      const z = [], te = Object.keys(K);
      for (let re = 0; re < te.length; re++) {
        const de = te[re], V = r.createElement(I, {
          onError: (q) => U._onError(q)
        }, r.createElement(r.Suspense, {
          fallback: null
        }, K[de])), G = U.getElementByKey(de);
        G !== null && z.push(h.createPortal(V, G, de));
      }
      return z;
    }, [I, K, U]);
  }
  function N(U) {
    x(() => f.mergeRegister(T.registerRichText(U), C.registerDragonSupport(U)), [U]);
  }
  function v({
    contentEditable: U,
    placeholder: I,
    ErrorBoundary: K
  }) {
    const [B] = e.useLexicalComposerContext(), z = H(B, K);
    return N(B), r.createElement(r.Fragment, null, U, r.createElement(F, {
      content: I
    }), z);
  }
  function F({
    content: U
  }) {
    const [I] = e.useLexicalComposerContext(), K = k(I), B = t();
    return K ? typeof U == "function" ? U(B) : U : null;
  }
  return Xa.RichTextPlugin = v, Xa;
}
var f_ = true ? d_() : u_();
var h_ = f_;
var ec = {};
var _d;
function p_() {
  if (_d)
    return ec;
  _d = 1;
  var e = kn(), t = import_react.default;
  function r() {
    return r = Object.assign ? Object.assign.bind() : function(T) {
      for (var O = 1; O < arguments.length; O++) {
        var S = arguments[O];
        for (var x in S)
          Object.prototype.hasOwnProperty.call(S, x) && (T[x] = S[x]);
      }
      return T;
    }, r.apply(this, arguments);
  }
  var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? t.useLayoutEffect : t.useEffect;
  function C({
    ariaActiveDescendant: T,
    ariaAutoComplete: O,
    ariaControls: S,
    ariaDescribedBy: x,
    ariaExpanded: D,
    ariaLabel: k,
    ariaLabelledBy: H,
    ariaMultiline: N,
    ariaOwns: v,
    ariaRequired: F,
    autoCapitalize: U,
    className: I,
    id: K,
    role: B = "textbox",
    spellCheck: z = true,
    style: te,
    tabIndex: re,
    "data-testid": de,
    ...V
  }) {
    const [G] = e.useLexicalComposerContext(), [q, me] = t.useState(false), pe = t.useCallback((Z) => {
      G.setRootElement(Z);
    }, [G]);
    return h(() => (me(G.isEditable()), G.registerEditableListener((Z) => {
      me(Z);
    })), [G]), t.createElement("div", r({}, V, {
      "aria-activedescendant": q ? T : void 0,
      "aria-autocomplete": q ? O : "none",
      "aria-controls": q ? S : void 0,
      "aria-describedby": x,
      "aria-expanded": q && B === "combobox" ? !!D : void 0,
      "aria-label": k,
      "aria-labelledby": H,
      "aria-multiline": N,
      "aria-owns": q ? v : void 0,
      "aria-readonly": q ? void 0 : true,
      "aria-required": F,
      autoCapitalize: U,
      className: I,
      contentEditable: q,
      "data-testid": de,
      id: K,
      ref: pe,
      role: B,
      spellCheck: z,
      style: te,
      tabIndex: re
    }));
  }
  return ec.ContentEditable = C, ec;
}
var __ = true ? p_() : g_();
var m_ = __;
var nc;
var yd;
function C_() {
  if (yd)
    return nc;
  yd = 1;
  var e = import_react.default;
  function t(T, O) {
    return t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(x, D) {
      return x.__proto__ = D, x;
    }, t(T, O);
  }
  function r(T, O) {
    T.prototype = Object.create(O.prototype), T.prototype.constructor = T, t(T, O);
  }
  var o = function(O, S) {
    return O === void 0 && (O = []), S === void 0 && (S = []), O.length !== S.length || O.some(function(x, D) {
      return !Object.is(x, S[D]);
    });
  }, f = {
    error: null
  }, h = function(T) {
    r(O, T);
    function O() {
      for (var x, D = arguments.length, k = new Array(D), H = 0; H < D; H++)
        k[H] = arguments[H];
      return x = T.call.apply(T, [this].concat(k)) || this, x.state = f, x.resetErrorBoundary = function() {
        for (var N, v = arguments.length, F = new Array(v), U = 0; U < v; U++)
          F[U] = arguments[U];
        x.props.onReset == null || (N = x.props).onReset.apply(N, F), x.reset();
      }, x;
    }
    O.getDerivedStateFromError = function(D) {
      return {
        error: D
      };
    };
    var S = O.prototype;
    return S.reset = function() {
      this.setState(f);
    }, S.componentDidCatch = function(D, k) {
      var H, N;
      (H = (N = this.props).onError) == null || H.call(N, D, k);
    }, S.componentDidUpdate = function(D, k) {
      var H = this.state.error, N = this.props.resetKeys;
      if (H !== null && k.error !== null && o(D.resetKeys, N)) {
        var v, F;
        (v = (F = this.props).onResetKeysChange) == null || v.call(F, D.resetKeys, N), this.reset();
      }
    }, S.render = function() {
      var D = this.state.error, k = this.props, H = k.fallbackRender, N = k.FallbackComponent, v = k.fallback;
      if (D !== null) {
        var F = {
          error: D,
          resetErrorBoundary: this.resetErrorBoundary
        };
        if (e.isValidElement(v))
          return v;
        if (typeof H == "function")
          return H(F);
        if (N)
          return e.createElement(N, F);
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
      return this.props.children;
    }, O;
  }(e.Component);
  function C({
    children: T,
    onError: O
  }) {
    return e.createElement(h, {
      fallback: e.createElement("div", {
        style: {
          border: "1px solid #f00",
          color: "#f00",
          padding: "8px"
        }
      }, "An error was thrown."),
      onError: O
    }, T);
  }
  return nc = C, nc;
}
var N_ = true ? C_() : y_();
var E_ = N_;
var T_ = bc(E_);
var Vn = {};
var Nd;
function v_() {
  if (Nd)
    return Vn;
  Nd = 1;
  var e = kt(), t = Jt();
  function r(Y) {
    let W = 1, Q = Y.getParent();
    for (; Q != null; ) {
      if (de(Q)) {
        const b = Q.getParent();
        if (ee(b)) {
          W++, Q = b.getParent();
          continue;
        }
        throw Error("A ListItemNode must have a ListNode for a parent.");
      }
      return W;
    }
    return W;
  }
  function o(Y) {
    let W = Y.getParent();
    if (!ee(W))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    let Q = W;
    for (; Q !== null; )
      Q = Q.getParent(), ee(Q) && (W = Q);
    return W;
  }
  function f(Y) {
    let W = [];
    const Q = Y.getChildren().filter(de);
    for (let b = 0; b < Q.length; b++) {
      const g = Q[b], _ = g.getFirstChild();
      ee(_) ? W = W.concat(f(_)) : W.push(g);
    }
    return W;
  }
  function h(Y) {
    return de(Y) && ee(Y.getFirstChild());
  }
  function C(Y) {
    let W = Y;
    for (; W.getNextSibling() == null && W.getPreviousSibling() == null; ) {
      const Q = W.getParent();
      if (Q == null || !(de(W) || ee(W)))
        break;
      W = Q;
    }
    W.remove();
  }
  function T(Y) {
    return re().append(Y);
  }
  function O(Y, W) {
    return de(Y) && (W.length === 0 || W.length === 1 && Y.is(W[0]) && Y.getChildrenSize() === 0);
  }
  function S(Y) {
    const W = Y.getParent();
    let Q = 1;
    if (W != null)
      if (ee(W))
        Q = W.getStart();
      else
        throw Error("$getListItemValue: list node is not parent of list item node");
    const b = Y.getPreviousSiblings();
    for (let g = 0; g < b.length; g++) {
      const _ = b[g];
      de(_) && !ee(_.getFirstChild()) && Q++;
    }
    return Q;
  }
  function x(Y, W) {
    Y.update(() => {
      const Q = e.$getSelection();
      if (e.$INTERNAL_isPointSelection(Q)) {
        const b = Q.getNodes(), _ = Q.anchor.getNode(), A = _.getParent();
        if (O(_, b)) {
          const J = Z(W);
          if (e.$isRootOrShadowRoot(A)) {
            _.replace(J);
            const ce = re();
            e.$isElementNode(_) && (ce.setFormat(_.getFormatType()), ce.setIndent(_.getIndent())), J.append(ce);
          } else if (de(_)) {
            const ce = _.getParentOrThrow();
            D(J, ce.getChildren()), ce.replace(J);
          }
          return;
        } else {
          const J = /* @__PURE__ */ new Set();
          for (let ce = 0; ce < b.length; ce++) {
            const ge = b[ce];
            if (e.$isElementNode(ge) && ge.isEmpty() && !de(ge) && !J.has(ge.getKey())) {
              k(ge, W);
              continue;
            }
            if (e.$isLeafNode(ge)) {
              let ae = ge.getParent();
              for (; ae != null; ) {
                const Te = ae.getKey();
                if (ee(ae)) {
                  if (!J.has(Te)) {
                    const Me = Z(W);
                    D(Me, ae.getChildren()), ae.replace(Me), v(Me), J.add(Te);
                  }
                  break;
                } else {
                  const Me = ae.getParent();
                  if (e.$isRootOrShadowRoot(Me) && !J.has(Te)) {
                    J.add(Te), k(ae, W);
                    break;
                  }
                  ae = Me;
                }
              }
            }
          }
        }
      }
    });
  }
  function D(Y, W) {
    Y.splice(Y.getChildrenSize(), 0, W);
  }
  function k(Y, W) {
    if (ee(Y))
      return Y;
    const Q = Y.getPreviousSibling(), b = Y.getNextSibling(), g = re();
    if (g.setFormat(Y.getFormatType()), g.setIndent(Y.getIndent()), D(g, Y.getChildren()), ee(Q) && W === Q.getListType())
      return Q.append(g), Y.remove(), ee(b) && W === b.getListType() && (D(Q, b.getChildren()), b.remove()), Q;
    if (ee(b) && W === b.getListType())
      return b.getFirstChildOrThrow().insertBefore(g), Y.remove(), b;
    {
      const _ = Z(W);
      return _.append(g), Y.replace(_), v(_), _;
    }
  }
  function H(Y, W) {
    const Q = Y.getLastChild(), b = W.getFirstChild();
    Q && b && h(Q) && h(b) && (H(Q.getFirstChild(), b.getFirstChild()), b.remove());
    const g = W.getChildren();
    g.length > 0 && (Y.append(...g), v(Y)), W.remove();
  }
  function N(Y) {
    Y.update(() => {
      const W = e.$getSelection();
      if (e.$isRangeSelection(W)) {
        const Q = /* @__PURE__ */ new Set(), b = W.getNodes(), g = W.anchor.getNode();
        if (O(g, b))
          Q.add(o(g));
        else
          for (let _ = 0; _ < b.length; _++) {
            const A = b[_];
            if (e.$isLeafNode(A)) {
              const J = t.$getNearestNodeOfType(A, K);
              J != null && Q.add(o(J));
            }
          }
        for (const _ of Q) {
          let A = _;
          const J = f(_);
          for (const ce of J) {
            const ge = e.$createParagraphNode();
            D(ge, ce.getChildren()), A.insertAfter(ge), A = ge, ce.__key === W.anchor.key && W.anchor.set(ge.getKey(), 0, "element"), ce.__key === W.focus.key && W.focus.set(ge.getKey(), 0, "element"), ce.remove();
          }
          _.remove();
        }
      }
    });
  }
  function v(Y, W) {
    const Q = W || Y.getChildren();
    if (Q !== void 0)
      for (let b = 0; b < Q.length; b++) {
        const g = Q[b];
        if (de(g)) {
          const _ = g.getValue(), A = S(g);
          _ !== A && g.setValue(A);
        }
      }
  }
  function F(Y) {
    const W = /* @__PURE__ */ new Set();
    if (h(Y) || W.has(Y.getKey()))
      return;
    const Q = Y.getParent(), b = Y.getNextSibling(), g = Y.getPreviousSibling();
    if (h(b) && h(g)) {
      const _ = g.getFirstChild();
      if (ee(_)) {
        _.append(Y);
        const A = b.getFirstChild();
        if (ee(A)) {
          const J = A.getChildren();
          D(_, J), b.remove(), W.add(b.getKey());
        }
        v(_);
      }
    } else if (h(b)) {
      const _ = b.getFirstChild();
      if (ee(_)) {
        const A = _.getFirstChild();
        A !== null && A.insertBefore(Y), v(_);
      }
    } else if (h(g)) {
      const _ = g.getFirstChild();
      ee(_) && (_.append(Y), v(_));
    } else if (ee(Q)) {
      const _ = re(), A = Z(Q.getListType());
      _.append(A), A.append(Y), g ? g.insertAfter(_) : b ? b.insertBefore(_) : Q.append(_), v(A);
    }
    ee(Q) && v(Q);
  }
  function U(Y) {
    if (h(Y))
      return;
    const W = Y.getParent(), Q = W ? W.getParent() : void 0, b = Q ? Q.getParent() : void 0;
    if (ee(b) && de(Q) && ee(W)) {
      const g = W ? W.getFirstChild() : void 0, _ = W ? W.getLastChild() : void 0;
      if (Y.is(g))
        Q.insertBefore(Y), W.isEmpty() && Q.remove();
      else if (Y.is(_))
        Q.insertAfter(Y), W.isEmpty() && Q.remove();
      else {
        const A = W.getListType(), J = re(), ce = Z(A);
        J.append(ce), Y.getPreviousSiblings().forEach((Te) => ce.append(Te));
        const ge = re(), ae = Z(A);
        ge.append(ae), D(ae, Y.getNextSiblings()), Q.insertBefore(J), Q.insertAfter(ge), Q.replace(Y);
      }
      v(W), v(b);
    }
  }
  function I() {
    const Y = e.$getSelection();
    if (!e.$isRangeSelection(Y) || !Y.isCollapsed())
      return false;
    const W = Y.anchor.getNode();
    if (!de(W) || W.getChildrenSize() !== 0)
      return false;
    const Q = o(W), b = W.getParent();
    if (!ee(b))
      throw Error("A ListItemNode must have a ListNode for a parent.");
    const g = b.getParent();
    let _;
    if (e.$isRootOrShadowRoot(g))
      _ = e.$createParagraphNode(), Q.insertAfter(_);
    else if (de(g))
      _ = re(), g.insertAfter(_);
    else
      return false;
    _.select();
    const A = W.getNextSiblings();
    if (A.length > 0) {
      const J = Z(b.getListType());
      if (e.$isParagraphNode(_))
        _.insertAfter(J);
      else {
        const ce = re();
        ce.append(J), _.insertAfter(ce);
      }
      A.forEach((ce) => {
        ce.remove(), J.append(ce);
      });
    }
    return C(W), true;
  }
  class K extends e.ElementNode {
    /** @internal */
    /** @internal */
    static getType() {
      return "listitem";
    }
    static clone(W) {
      return new K(W.__value, W.__checked, W.__key);
    }
    constructor(W, Q, b) {
      super(b), this.__value = W === void 0 ? 1 : W, this.__checked = Q;
    }
    createDOM(W) {
      const Q = document.createElement("li"), b = this.getParent();
      return ee(b) && b.getListType() === "check" && z(Q, this, null), Q.value = this.__value, B(Q, W.theme, this), Q;
    }
    updateDOM(W, Q, b) {
      const g = this.getParent();
      return ee(g) && g.getListType() === "check" && z(Q, this, W), Q.value = this.__value, B(Q, b.theme, this), false;
    }
    static transform() {
      return (W) => {
        const Q = W.getParent();
        ee(Q) && (v(Q), Q.getListType() !== "check" && W.getChecked() != null && W.setChecked(void 0));
      };
    }
    static importDOM() {
      return {
        li: (W) => ({
          conversion: te,
          priority: 0
        })
      };
    }
    static importJSON(W) {
      const Q = re();
      return Q.setChecked(W.checked), Q.setValue(W.value), Q.setFormat(W.format), Q.setDirection(W.direction), Q;
    }
    exportDOM(W) {
      const Q = this.createDOM(W._config);
      return Q.style.textAlign = this.getFormatType(), {
        element: Q
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        checked: this.getChecked(),
        type: "listitem",
        value: this.getValue(),
        version: 1
      };
    }
    append(...W) {
      for (let Q = 0; Q < W.length; Q++) {
        const b = W[Q];
        if (e.$isElementNode(b) && this.canMergeWith(b)) {
          const g = b.getChildren();
          this.append(...g), b.remove();
        } else
          super.append(b);
      }
      return this;
    }
    replace(W, Q) {
      if (de(W))
        return super.replace(W);
      this.setIndent(0);
      const b = this.getParentOrThrow();
      if (!ee(b))
        return W;
      if (b.__first === this.getKey())
        b.insertBefore(W);
      else if (b.__last === this.getKey())
        b.insertAfter(W);
      else {
        const g = Z(b.getListType());
        let _ = this.getNextSibling();
        for (; _; ) {
          const A = _;
          _ = _.getNextSibling(), g.append(A);
        }
        b.insertAfter(W), W.insertAfter(g);
      }
      return Q && this.getChildren().forEach((g) => {
        W.append(g);
      }), this.remove(), b.getChildrenSize() === 0 && b.remove(), W;
    }
    insertAfter(W, Q = true) {
      const b = this.getParentOrThrow();
      if (!ee(b))
        throw Error("insertAfter: list node is not parent of list item node");
      const g = this.getNextSiblings();
      if (de(W)) {
        const _ = super.insertAfter(W, Q), A = W.getParentOrThrow();
        return ee(A) && v(A), _;
      }
      if (ee(W)) {
        let _ = W;
        const A = W.getChildren();
        for (let J = A.length - 1; J >= 0; J--)
          _ = A[J], this.insertAfter(_, Q);
        return _;
      }
      if (b.insertAfter(W, Q), g.length !== 0) {
        const _ = Z(b.getListType());
        g.forEach((A) => _.append(A)), W.insertAfter(_, Q);
      }
      return W;
    }
    remove(W) {
      const Q = this.getPreviousSibling(), b = this.getNextSibling();
      if (super.remove(W), Q && b && h(Q) && h(b))
        H(Q.getFirstChild(), b.getFirstChild()), b.remove();
      else if (b) {
        const g = b.getParent();
        ee(g) && v(g);
      }
    }
    insertNewAfter(W, Q = true) {
      const b = re(this.__checked == null ? void 0 : false);
      return this.insertAfter(b, Q), b;
    }
    collapseAtStart(W) {
      const Q = e.$createParagraphNode();
      this.getChildren().forEach((J) => Q.append(J));
      const g = this.getParentOrThrow(), _ = g.getParentOrThrow(), A = de(_);
      if (g.getChildrenSize() === 1)
        if (A)
          g.remove(), _.select();
        else {
          g.insertBefore(Q), g.remove();
          const J = W.anchor, ce = W.focus, ge = Q.getKey();
          J.type === "element" && J.getNode().is(this) && J.set(ge, J.offset, "element"), ce.type === "element" && ce.getNode().is(this) && ce.set(ge, ce.offset, "element");
        }
      else
        g.insertBefore(Q), this.remove();
      return true;
    }
    getValue() {
      return this.getLatest().__value;
    }
    setValue(W) {
      const Q = this.getWritable();
      Q.__value = W;
    }
    getChecked() {
      return this.getLatest().__checked;
    }
    setChecked(W) {
      const Q = this.getWritable();
      Q.__checked = W;
    }
    toggleChecked() {
      this.setChecked(!this.__checked);
    }
    getIndent() {
      const W = this.getParent();
      if (W === null)
        return this.getLatest().__indent;
      let Q = W.getParentOrThrow(), b = 0;
      for (; de(Q); )
        Q = Q.getParentOrThrow().getParentOrThrow(), b++;
      return b;
    }
    setIndent(W) {
      if (!(typeof W == "number" && W > -1))
        throw Error("Invalid indent value.");
      let Q = this.getIndent();
      for (; Q !== W; )
        Q < W ? (F(this), Q++) : (U(this), Q--);
      return this;
    }
    insertBefore(W) {
      if (de(W)) {
        const Q = this.getParentOrThrow();
        if (ee(Q)) {
          const b = this.getNextSiblings();
          v(Q, b);
        }
      }
      return super.insertBefore(W);
    }
    canInsertAfter(W) {
      return de(W);
    }
    canReplaceWith(W) {
      return de(W);
    }
    canMergeWith(W) {
      return e.$isParagraphNode(W) || de(W);
    }
    extractWithChild(W, Q) {
      if (!e.$isRangeSelection(Q))
        return false;
      const b = Q.anchor.getNode(), g = Q.focus.getNode();
      return this.isParentOf(b) && this.isParentOf(g) && this.getTextContent().length === Q.getTextContent().length;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return Z("bullet");
    }
  }
  function B(Y, W, Q) {
    const b = [], g = [], _ = W.list, A = _ ? _.listitem : void 0;
    let J;
    if (_ && _.nested && (J = _.nested.listitem), A !== void 0) {
      const ce = A.split(" ");
      b.push(...ce);
    }
    if (_) {
      const ce = Q.getParent(), ge = ee(ce) && ce.getListType() === "check", ae = Q.getChecked();
      (!ge || ae) && g.push(_.listitemUnchecked), (!ge || !ae) && g.push(_.listitemChecked), ge && b.push(ae ? _.listitemChecked : _.listitemUnchecked);
    }
    if (J !== void 0) {
      const ce = J.split(" ");
      Q.getChildren().some((ge) => ee(ge)) ? b.push(...ce) : g.push(...ce);
    }
    g.length > 0 && t.removeClassNamesFromElement(Y, ...g), b.length > 0 && t.addClassNamesToElement(Y, ...b);
  }
  function z(Y, W, Q, b) {
    ee(W.getFirstChild()) ? (Y.removeAttribute("role"), Y.removeAttribute("tabIndex"), Y.removeAttribute("aria-checked")) : (Y.setAttribute("role", "checkbox"), Y.setAttribute("tabIndex", "-1"), (!Q || W.__checked !== Q.__checked) && Y.setAttribute("aria-checked", W.getChecked() ? "true" : "false"));
  }
  function te(Y) {
    const W = t.isHTMLElement(Y) && Y.getAttribute("aria-checked") === "true";
    return {
      node: re(W)
    };
  }
  function re(Y) {
    return e.$applyNodeReplacement(new K(void 0, Y));
  }
  function de(Y) {
    return Y instanceof K;
  }
  class V extends e.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "list";
    }
    static clone(W) {
      const Q = W.__listType || pe[W.__tag];
      return new V(Q, W.__start, W.__key);
    }
    constructor(W, Q, b) {
      super(b);
      const g = pe[W] || W;
      this.__listType = g, this.__tag = g === "number" ? "ol" : "ul", this.__start = Q;
    }
    getTag() {
      return this.__tag;
    }
    setListType(W) {
      const Q = this.getWritable();
      Q.__listType = W, Q.__tag = W === "number" ? "ol" : "ul";
    }
    getListType() {
      return this.__listType;
    }
    getStart() {
      return this.__start;
    }
    // View
    createDOM(W, Q) {
      const b = this.__tag, g = document.createElement(b);
      return this.__start !== 1 && g.setAttribute("start", String(this.__start)), g.__lexicalListType = this.__listType, G(g, W.theme, this), g;
    }
    updateDOM(W, Q, b) {
      return W.__tag !== this.__tag ? true : (G(Q, b.theme, this), false);
    }
    static importDOM() {
      return {
        ol: (W) => ({
          conversion: me,
          priority: 0
        }),
        ul: (W) => ({
          conversion: me,
          priority: 0
        })
      };
    }
    static importJSON(W) {
      const Q = Z(W.listType, W.start);
      return Q.setFormat(W.format), Q.setIndent(W.indent), Q.setDirection(W.direction), Q;
    }
    exportDOM(W) {
      const {
        element: Q
      } = super.exportDOM(W);
      return Q && t.isHTMLElement(Q) && (this.__start !== 1 && Q.setAttribute("start", String(this.__start)), this.__listType === "check" && Q.setAttribute("__lexicalListType", "check")), {
        element: Q
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        listType: this.getListType(),
        start: this.getStart(),
        tag: this.getTag(),
        type: "list",
        version: 1
      };
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
    append(...W) {
      for (let Q = 0; Q < W.length; Q++) {
        const b = W[Q];
        if (de(b))
          super.append(b);
        else {
          const g = re();
          if (ee(b))
            g.append(b);
          else if (e.$isElementNode(b)) {
            const _ = e.$createTextNode(b.getTextContent());
            g.append(_);
          } else
            g.append(b);
          super.append(g);
        }
      }
      return v(this), this;
    }
    extractWithChild(W) {
      return de(W);
    }
  }
  function G(Y, W, Q) {
    const b = [], g = [], _ = W.list;
    if (_ !== void 0) {
      const A = _[`${Q.__tag}Depth`] || [], J = r(Q) - 1, ce = J % A.length, ge = A[ce], ae = _[Q.__tag];
      let Te;
      const Me = _.nested;
      if (Me !== void 0 && Me.list && (Te = Me.list), ae !== void 0 && b.push(ae), ge !== void 0) {
        const ze = ge.split(" ");
        b.push(...ze);
        for (let oe = 0; oe < A.length; oe++)
          oe !== ce && g.push(Q.__tag + oe);
      }
      if (Te !== void 0) {
        const ze = Te.split(" ");
        J > 1 ? b.push(...ze) : g.push(...ze);
      }
    }
    g.length > 0 && t.removeClassNamesFromElement(Y, ...g), b.length > 0 && t.addClassNamesToElement(Y, ...b);
  }
  function q(Y) {
    const W = [];
    for (let Q = 0; Q < Y.length; Q++) {
      const b = Y[Q];
      if (de(b)) {
        W.push(b);
        const g = b.getChildren();
        g.length > 1 && g.forEach((_) => {
          ee(_) && W.push(T(_));
        });
      } else
        W.push(T(b));
    }
    return W;
  }
  function me(Y) {
    const W = Y.nodeName.toLowerCase();
    let Q = null;
    if (W === "ol") {
      const b = Y.start;
      Q = Z("number", b);
    } else
      W === "ul" && (t.isHTMLElement(Y) && Y.getAttribute("__lexicallisttype") === "check" ? Q = Z("check") : Q = Z("bullet"));
    return {
      after: q,
      node: Q
    };
  }
  const pe = {
    ol: "number",
    ul: "bullet"
  };
  function Z(Y, W = 1) {
    return e.$applyNodeReplacement(new V(Y, W));
  }
  function ee(Y) {
    return Y instanceof V;
  }
  const P = e.createCommand("INSERT_UNORDERED_LIST_COMMAND"), w = e.createCommand("INSERT_ORDERED_LIST_COMMAND"), j = e.createCommand("INSERT_CHECK_LIST_COMMAND"), ne = e.createCommand("REMOVE_LIST_COMMAND");
  return Vn.$createListItemNode = re, Vn.$createListNode = Z, Vn.$getListDepth = r, Vn.$handleListInsertParagraph = I, Vn.$isListItemNode = de, Vn.$isListNode = ee, Vn.INSERT_CHECK_LIST_COMMAND = j, Vn.INSERT_ORDERED_LIST_COMMAND = w, Vn.INSERT_UNORDERED_LIST_COMMAND = P, Vn.ListItemNode = K, Vn.ListNode = V, Vn.REMOVE_LIST_COMMAND = ne, Vn.insertList = x, Vn.removeList = N, Vn;
}
var ic;
var Ed;
function Fc() {
  return Ed || (Ed = 1, ic = true ? v_() : x_()), ic;
}
var oc = {};
var xd;
function w_() {
  if (xd)
    return oc;
  xd = 1;
  var e = Fc(), t = kn(), r = import_react.default, o = Jt(), f = kt();
  function h(T) {
    r.useEffect(() => o.mergeRegister(T.registerCommand(e.INSERT_ORDERED_LIST_COMMAND, () => (e.insertList(T, "number"), true), f.COMMAND_PRIORITY_LOW), T.registerCommand(e.INSERT_UNORDERED_LIST_COMMAND, () => (e.insertList(T, "bullet"), true), f.COMMAND_PRIORITY_LOW), T.registerCommand(e.REMOVE_LIST_COMMAND, () => (e.removeList(T), true), f.COMMAND_PRIORITY_LOW), T.registerCommand(f.INSERT_PARAGRAPH_COMMAND, () => !!e.$handleListInsertParagraph(), f.COMMAND_PRIORITY_LOW)), [T]);
  }
  function C() {
    const [T] = t.useLexicalComposerContext();
    return r.useEffect(() => {
      if (!T.hasNodes([e.ListNode, e.ListItemNode]))
        throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
    }, [T]), h(T), null;
  }
  return oc.ListPlugin = C, oc;
}
var O_ = true ? w_() : S_();
var R_ = O_;
var yi = {};
var Sd;
function A_() {
  if (Sd)
    return yi;
  Sd = 1;
  var e = Jt(), t = kt();
  const r = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
  class o extends t.ElementNode {
    /** @internal */
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "link";
    }
    static clone(N) {
      return new o(N.__url, {
        rel: N.__rel,
        target: N.__target,
        title: N.__title
      }, N.__key);
    }
    constructor(N, v = {}, F) {
      super(F);
      const {
        target: U = null,
        rel: I = null,
        title: K = null
      } = v;
      this.__url = N, this.__target = U, this.__rel = I, this.__title = K;
    }
    createDOM(N) {
      const v = document.createElement("a");
      return v.href = this.sanitizeUrl(this.__url), this.__target !== null && (v.target = this.__target), this.__rel !== null && (v.rel = this.__rel), this.__title !== null && (v.title = this.__title), e.addClassNamesToElement(v, N.theme.link), v;
    }
    updateDOM(N, v, F) {
      const U = this.__url, I = this.__target, K = this.__rel, B = this.__title;
      return U !== N.__url && (v.href = U), I !== N.__target && (I ? v.target = I : v.removeAttribute("target")), K !== N.__rel && (K ? v.rel = K : v.removeAttribute("rel")), B !== N.__title && (B ? v.title = B : v.removeAttribute("title")), false;
    }
    static importDOM() {
      return {
        a: (N) => ({
          conversion: f,
          priority: 1
        })
      };
    }
    static importJSON(N) {
      const v = h(N.url, {
        rel: N.rel,
        target: N.target,
        title: N.title
      });
      return v.setFormat(N.format), v.setIndent(N.indent), v.setDirection(N.direction), v;
    }
    sanitizeUrl(N) {
      try {
        const v = new URL(N);
        if (!r.has(v.protocol))
          return "about:blank";
      } catch {
        return N;
      }
      return N;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        rel: this.getRel(),
        target: this.getTarget(),
        title: this.getTitle(),
        type: "link",
        url: this.getURL(),
        version: 1
      };
    }
    getURL() {
      return this.getLatest().__url;
    }
    setURL(N) {
      const v = this.getWritable();
      v.__url = N;
    }
    getTarget() {
      return this.getLatest().__target;
    }
    setTarget(N) {
      const v = this.getWritable();
      v.__target = N;
    }
    getRel() {
      return this.getLatest().__rel;
    }
    setRel(N) {
      const v = this.getWritable();
      v.__rel = N;
    }
    getTitle() {
      return this.getLatest().__title;
    }
    setTitle(N) {
      const v = this.getWritable();
      v.__title = N;
    }
    insertNewAfter(N, v = true) {
      const F = h(this.__url, {
        rel: this.__rel,
        target: this.__target,
        title: this.__title
      });
      return this.insertAfter(F, v), F;
    }
    canInsertTextBefore() {
      return false;
    }
    canInsertTextAfter() {
      return false;
    }
    canBeEmpty() {
      return false;
    }
    isInline() {
      return true;
    }
    extractWithChild(N, v, F) {
      if (!t.$isRangeSelection(v))
        return false;
      const U = v.anchor.getNode(), I = v.focus.getNode();
      return this.isParentOf(U) && this.isParentOf(I) && v.getTextContent().length > 0;
    }
  }
  function f(H) {
    let N = null;
    if (e.isHTMLAnchorElement(H)) {
      const v = H.textContent;
      (v !== null && v !== "" || H.children.length > 0) && (N = h(H.getAttribute("href") || "", {
        rel: H.getAttribute("rel"),
        target: H.getAttribute("target"),
        title: H.getAttribute("title")
      }));
    }
    return {
      node: N
    };
  }
  function h(H, N) {
    return t.$applyNodeReplacement(new o(H, N));
  }
  function C(H) {
    return H instanceof o;
  }
  class T extends o {
    static getType() {
      return "autolink";
    }
    static clone(N) {
      return new T(N.__url, {
        rel: N.__rel,
        target: N.__target,
        title: N.__title
      }, N.__key);
    }
    static importJSON(N) {
      const v = O(N.url, {
        rel: N.rel,
        target: N.target,
        title: N.title
      });
      return v.setFormat(N.format), v.setIndent(N.indent), v.setDirection(N.direction), v;
    }
    static importDOM() {
      return null;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "autolink",
        version: 1
      };
    }
    insertNewAfter(N, v = true) {
      const F = this.getParentOrThrow().insertNewAfter(N, v);
      if (t.$isElementNode(F)) {
        const U = O(this.__url, {
          rel: this.__rel,
          target: this.__target,
          title: this.__title
        });
        return F.append(U), U;
      }
      return null;
    }
  }
  function O(H, N) {
    return t.$applyNodeReplacement(new T(H, N));
  }
  function S(H) {
    return H instanceof T;
  }
  const x = t.createCommand("TOGGLE_LINK_COMMAND");
  function D(H, N = {}) {
    const {
      target: v,
      title: F
    } = N, U = N.rel === void 0 ? "noreferrer" : N.rel, I = t.$getSelection();
    if (!t.$isRangeSelection(I))
      return;
    const K = I.extract();
    if (H === null)
      K.forEach((B) => {
        const z = B.getParent();
        if (C(z)) {
          const te = z.getChildren();
          for (let re = 0; re < te.length; re++)
            z.insertBefore(te[re]);
          z.remove();
        }
      });
    else {
      if (K.length === 1) {
        const te = K[0], re = k(te, C);
        if (re !== null) {
          re.setURL(H), v !== void 0 && re.setTarget(v), U !== null && re.setRel(U), F !== void 0 && re.setTitle(F);
          return;
        }
      }
      let B = null, z = null;
      K.forEach((te) => {
        const re = te.getParent();
        if (!(re === z || re === null || t.$isElementNode(te) && !te.isInline())) {
          if (C(re)) {
            z = re, re.setURL(H), v !== void 0 && re.setTarget(v), U !== null && z.setRel(U), F !== void 0 && z.setTitle(F);
            return;
          }
          if (re.is(B) || (B = re, z = h(H, {
            rel: U,
            target: v,
            title: F
          }), C(re) ? te.getPreviousSibling() === null ? re.insertBefore(z) : re.insertAfter(z) : te.insertBefore(z)), C(te)) {
            if (te.is(z))
              return;
            if (z !== null) {
              const de = te.getChildren();
              for (let V = 0; V < de.length; V++)
                z.append(de[V]);
            }
            te.remove();
            return;
          }
          z !== null && z.append(te);
        }
      });
    }
  }
  function k(H, N) {
    let v = H;
    for (; v !== null && v.getParent() !== null && !N(v); )
      v = v.getParentOrThrow();
    return N(v) ? v : null;
  }
  return yi.$createAutoLinkNode = O, yi.$createLinkNode = h, yi.$isAutoLinkNode = S, yi.$isLinkNode = C, yi.AutoLinkNode = T, yi.LinkNode = o, yi.TOGGLE_LINK_COMMAND = x, yi.toggleLink = D, yi;
}
var lc;
var wd;
function Bc() {
  return wd || (wd = 1, lc = true ? A_() : D_()), lc;
}
var ac = {};
var Rd;
function M_() {
  if (Rd)
    return ac;
  Rd = 1;
  var e = Bc(), t = kn(), r = Jt(), o = kt(), f = import_react.default;
  function h({
    validateUrl: C
  }) {
    const [T] = t.useLexicalComposerContext();
    return f.useEffect(() => {
      if (!T.hasNodes([e.LinkNode]))
        throw new Error("LinkPlugin: LinkNode not registered on editor");
      return r.mergeRegister(T.registerCommand(e.TOGGLE_LINK_COMMAND, (O) => {
        if (O === null)
          return e.toggleLink(O), true;
        if (typeof O == "string")
          return C === void 0 || C(O) ? (e.toggleLink(O), true) : false;
        {
          const {
            url: S,
            target: x,
            rel: D,
            title: k
          } = O;
          return e.toggleLink(S, {
            rel: D,
            target: x,
            title: k
          }), true;
        }
      }, o.COMMAND_PRIORITY_LOW), C !== void 0 ? T.registerCommand(o.PASTE_COMMAND, (O) => {
        const S = o.$getSelection();
        if (!o.$isRangeSelection(S) || S.isCollapsed() || !(O instanceof ClipboardEvent) || O.clipboardData == null)
          return false;
        const x = O.clipboardData.getData("text");
        return C(x) ? S.getNodes().some((D) => o.$isElementNode(D)) ? false : (T.dispatchCommand(e.TOGGLE_LINK_COMMAND, x), O.preventDefault(), true) : false;
      }, o.COMMAND_PRIORITY_LOW) : () => {
      });
    }, [T, C]), null;
  }
  return ac.LinkPlugin = h, ac;
}
var L_ = true ? M_() : b_();
var P_ = L_;
var Ut = {};
var Ad;
function k_() {
  if (Ad)
    return Ut;
  Ad = 1;
  var e = kt(), t = Jt();
  const r = /^(\d+(?:\.\d+)?)px$/, o = {
    BOTH: 3,
    COLUMN: 2,
    NO_STATUS: 0,
    ROW: 1
  };
  class f extends e.DEPRECATED_GridCellNode {
    /** @internal */
    /** @internal */
    /** @internal */
    static getType() {
      return "tablecell";
    }
    static clone(se) {
      const he = new f(se.__headerState, se.__colSpan, se.__width, se.__key);
      return he.__rowSpan = se.__rowSpan, he.__backgroundColor = se.__backgroundColor, he;
    }
    static importDOM() {
      return {
        td: (se) => ({
          conversion: h,
          priority: 0
        }),
        th: (se) => ({
          conversion: h,
          priority: 0
        })
      };
    }
    static importJSON(se) {
      const he = se.colSpan || 1, Oe = se.rowSpan || 1, be = C(se.headerState, he, se.width || void 0);
      return be.__rowSpan = Oe, be.__backgroundColor = se.backgroundColor || null, be;
    }
    constructor(se = o.NO_STATUS, he = 1, Oe, be) {
      super(he, be), this.__headerState = se, this.__width = Oe, this.__backgroundColor = null;
    }
    createDOM(se) {
      const he = document.createElement(this.getTag());
      return this.__width && (he.style.width = `${this.__width}px`), this.__colSpan > 1 && (he.colSpan = this.__colSpan), this.__rowSpan > 1 && (he.rowSpan = this.__rowSpan), this.__backgroundColor !== null && (he.style.backgroundColor = this.__backgroundColor), t.addClassNamesToElement(he, se.theme.tableCell, this.hasHeader() && se.theme.tableCellHeader), he;
    }
    exportDOM(se) {
      const {
        element: he
      } = super.exportDOM(se);
      if (he) {
        const Oe = he, be = 700, Re = this.getParentOrThrow().getChildrenSize();
        Oe.style.border = "1px solid black", this.__colSpan > 1 && (Oe.colSpan = this.__colSpan), this.__rowSpan > 1 && (Oe.rowSpan = this.__rowSpan), Oe.style.width = `${this.getWidth() || Math.max(90, be / Re)}px`, Oe.style.verticalAlign = "top", Oe.style.textAlign = "start";
        const He = this.getBackgroundColor();
        He !== null ? Oe.style.backgroundColor = He : this.hasHeader() && (Oe.style.backgroundColor = "#f2f3f5");
      }
      return {
        element: he
      };
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        backgroundColor: this.getBackgroundColor(),
        headerState: this.__headerState,
        type: "tablecell",
        width: this.getWidth()
      };
    }
    getTag() {
      return this.hasHeader() ? "th" : "td";
    }
    setHeaderStyles(se) {
      const he = this.getWritable();
      return he.__headerState = se, this.__headerState;
    }
    getHeaderStyles() {
      return this.getLatest().__headerState;
    }
    setWidth(se) {
      const he = this.getWritable();
      return he.__width = se, this.__width;
    }
    getWidth() {
      return this.getLatest().__width;
    }
    getBackgroundColor() {
      return this.getLatest().__backgroundColor;
    }
    setBackgroundColor(se) {
      this.getWritable().__backgroundColor = se;
    }
    toggleHeaderStyle(se) {
      const he = this.getWritable();
      return (he.__headerState & se) === se ? he.__headerState -= se : he.__headerState += se, he;
    }
    hasHeaderState(se) {
      return (this.getHeaderStyles() & se) === se;
    }
    hasHeader() {
      return this.getLatest().__headerState !== o.NO_STATUS;
    }
    updateDOM(se) {
      return se.__headerState !== this.__headerState || se.__width !== this.__width || se.__colSpan !== this.__colSpan || se.__rowSpan !== this.__rowSpan || se.__backgroundColor !== this.__backgroundColor;
    }
    isShadowRoot() {
      return true;
    }
    collapseAtStart() {
      return true;
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
  }
  function h(ve) {
    const se = ve, he = ve.nodeName.toLowerCase();
    let Oe;
    r.test(se.style.width) && (Oe = parseFloat(se.style.width));
    const be = C(he === "th" ? o.ROW : o.NO_STATUS, se.colSpan, Oe);
    be.__rowSpan = se.rowSpan;
    const Re = se.style.backgroundColor;
    return Re !== "" && (be.__backgroundColor = Re), {
      forChild: (He, Ve) => {
        if (T(Ve) && !e.$isElementNode(He)) {
          const Qe = e.$createParagraphNode();
          return e.$isLineBreakNode(He) && He.getTextContent() === `
` ? null : (Qe.append(He), Qe);
        }
        return He;
      },
      node: be
    };
  }
  function C(ve, se = 1, he) {
    return e.$applyNodeReplacement(new f(ve, se, he));
  }
  function T(ve) {
    return ve instanceof f;
  }
  class O extends e.DEPRECATED_GridRowNode {
    /** @internal */
    static getType() {
      return "tablerow";
    }
    static clone(se) {
      return new O(se.__height, se.__key);
    }
    static importDOM() {
      return {
        tr: (se) => ({
          conversion: S,
          priority: 0
        })
      };
    }
    static importJSON(se) {
      return x(se.height);
    }
    constructor(se, he) {
      super(he), this.__height = se;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "tablerow",
        version: 1
      };
    }
    createDOM(se) {
      const he = document.createElement("tr");
      return this.__height && (he.style.height = `${this.__height}px`), t.addClassNamesToElement(he, se.theme.tableRow), he;
    }
    isShadowRoot() {
      return true;
    }
    setHeight(se) {
      const he = this.getWritable();
      return he.__height = se, this.__height;
    }
    getHeight() {
      return this.getLatest().__height;
    }
    updateDOM(se) {
      return se.__height !== this.__height;
    }
    canBeEmpty() {
      return false;
    }
    canIndent() {
      return false;
    }
  }
  function S(ve) {
    const se = ve;
    let he;
    return r.test(se.style.height) && (he = parseFloat(se.style.height)), {
      node: x(he)
    };
  }
  function x(ve) {
    return e.$applyNodeReplacement(new O(ve));
  }
  function D(ve) {
    return ve instanceof O;
  }
  const k = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", H = (ve) => k ? (ve || window).getSelection() : null;
  class N {
    constructor(se, he) {
      this.isHighlightingCells = false, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.listenersToRemove = /* @__PURE__ */ new Set(), this.tableNodeKey = he, this.editor = se, this.grid = {
        cells: [],
        columns: 0,
        rows: 0
      }, this.gridSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = false, this.trackTableGrid();
    }
    getGrid() {
      return this.grid;
    }
    removeListeners() {
      Array.from(this.listenersToRemove).forEach((se) => se());
    }
    trackTableGrid() {
      const se = new MutationObserver((he) => {
        this.editor.update(() => {
          let Oe = false;
          for (let Re = 0; Re < he.length; Re++) {
            const Qe = he[Re].target.nodeName;
            if (Qe === "TABLE" || Qe === "TR") {
              Oe = true;
              break;
            }
          }
          if (!Oe)
            return;
          const be = this.editor.getElementByKey(this.tableNodeKey);
          if (!be)
            throw new Error("Expected to find TableElement in DOM");
          this.grid = B(be);
        });
      });
      this.editor.update(() => {
        const he = this.editor.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        this.grid = B(he), se.observe(he, {
          childList: true,
          subtree: true
        });
      });
    }
    clearHighlight() {
      const se = this.editor;
      this.isHighlightingCells = false, this.anchorX = -1, this.anchorY = -1, this.focusX = -1, this.focusY = -1, this.gridSelection = null, this.anchorCellNodeKey = null, this.focusCellNodeKey = null, this.anchorCell = null, this.focusCell = null, this.hasHijackedSelectionStyles = false, this.enableHighlightStyle(), se.update(() => {
        const he = e.$getNodeByKey(this.tableNodeKey);
        if (!g(he))
          throw new Error("Expected TableNode.");
        const Oe = se.getElementByKey(this.tableNodeKey);
        if (!Oe)
          throw new Error("Expected to find TableElement in DOM");
        const be = B(Oe);
        z(se, be, null), e.$setSelection(null), se.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    enableHighlightStyle() {
      const se = this.editor;
      se.update(() => {
        const he = se.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        t.removeClassNamesFromElement(he, se._config.theme.tableSelection), he.classList.remove("disable-selection"), this.hasHijackedSelectionStyles = false;
      });
    }
    disableHighlightStyle() {
      const se = this.editor;
      se.update(() => {
        const he = se.getElementByKey(this.tableNodeKey);
        if (!he)
          throw new Error("Expected to find TableElement in DOM");
        t.addClassNamesToElement(he, se._config.theme.tableSelection), this.hasHijackedSelectionStyles = true;
      });
    }
    updateTableGridSelection(se) {
      if (se != null && se.gridKey === this.tableNodeKey) {
        const he = this.editor;
        this.gridSelection = se, this.isHighlightingCells = true, this.disableHighlightStyle(), z(he, this.grid, this.gridSelection);
      } else
        se == null ? this.clearHighlight() : (this.tableNodeKey = se.gridKey, this.updateTableGridSelection(se));
    }
    setFocusCellForSelection(se, he = false) {
      const Oe = this.editor;
      Oe.update(() => {
        const be = e.$getNodeByKey(this.tableNodeKey);
        if (!g(be))
          throw new Error("Expected TableNode.");
        if (!Oe.getElementByKey(this.tableNodeKey))
          throw new Error("Expected to find TableElement in DOM");
        const He = se.x, Ve = se.y;
        if (this.focusCell = se, this.anchorCell !== null) {
          const Qe = H(Oe._window);
          Qe && Qe.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);
        }
        if (!this.isHighlightingCells && (this.anchorX !== He || this.anchorY !== Ve || he))
          this.isHighlightingCells = true, this.disableHighlightStyle();
        else if (He === this.focusX && Ve === this.focusY)
          return;
        if (this.focusX = He, this.focusY = Ve, this.isHighlightingCells) {
          const Qe = e.$getNearestNodeFromDOMNode(se.elem);
          if (this.gridSelection != null && this.anchorCellNodeKey != null && T(Qe)) {
            const ct = Qe.getKey();
            this.gridSelection = this.gridSelection.clone() || e.DEPRECATED_$createGridSelection(), this.focusCellNodeKey = ct, this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey), e.$setSelection(this.gridSelection), Oe.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0), z(Oe, this.grid, this.gridSelection);
          }
        }
      });
    }
    setAnchorCellForSelection(se) {
      this.isHighlightingCells = false, this.anchorCell = se, this.anchorX = se.x, this.anchorY = se.y, this.editor.update(() => {
        const he = e.$getNearestNodeFromDOMNode(se.elem);
        if (T(he)) {
          const Oe = he.getKey();
          this.gridSelection = this.gridSelection != null ? this.gridSelection.clone() : e.DEPRECATED_$createGridSelection(), this.anchorCellNodeKey = Oe;
        }
      });
    }
    formatCells(se) {
      this.editor.update(() => {
        const he = e.$getSelection();
        if (!e.DEPRECATED_$isGridSelection(he))
          throw Error("Expected grid selection");
        const Oe = e.$createRangeSelection(), be = Oe.anchor, Re = Oe.focus;
        he.getNodes().forEach((He) => {
          T(He) && He.getTextContentSize() !== 0 && (be.set(He.getKey(), 0, "element"), Re.set(He.getKey(), He.getChildrenSize(), "element"), Oe.formatText(se));
        }), e.$setSelection(he), this.editor.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
    clearText() {
      const se = this.editor;
      se.update(() => {
        const he = e.$getNodeByKey(this.tableNodeKey);
        if (!g(he))
          throw new Error("Expected TableNode.");
        const Oe = e.$getSelection();
        if (!e.DEPRECATED_$isGridSelection(Oe))
          throw Error("Expected grid selection");
        const be = Oe.getNodes().filter(T);
        if (be.length === this.grid.columns * this.grid.rows) {
          he.selectPrevious(), he.remove(), e.$getRoot().selectStart();
          return;
        }
        be.forEach((Re) => {
          if (e.$isElementNode(Re)) {
            const He = e.$createParagraphNode(), Ve = e.$createTextNode();
            He.append(Ve), Re.append(He), Re.getChildren().forEach((Qe) => {
              Qe !== He && Qe.remove();
            });
          }
        }), z(se, this.grid, null), e.$setSelection(null), se.dispatchCommand(e.SELECTION_CHANGE_COMMAND, void 0);
      });
    }
  }
  const v = "__lexicalTableSelection";
  function F(ve, se, he, Oe) {
    const be = he.getRootElement();
    if (be === null)
      throw new Error("No root element.");
    const Re = new N(he, ve.getKey()), He = he._window || window;
    U(se, Re), se.addEventListener("mousedown", (je) => {
      setTimeout(() => {
        if (je.button !== 0 || !He)
          return;
        const qe = K(je.target);
        qe !== null && (ne(je), Re.setAnchorCellForSelection(qe));
        const nt = () => {
          He.removeEventListener("mouseup", nt), He.removeEventListener("mousemove", gt);
        }, gt = (Ct) => {
          const xt = K(Ct.target);
          xt !== null && (Re.anchorX !== xt.x || Re.anchorY !== xt.y) && (Ct.preventDefault(), Re.setFocusCellForSelection(xt));
        };
        He.addEventListener("mouseup", nt), He.addEventListener("mousemove", gt);
      }, 0);
    });
    const Ve = (je) => {
      je.button === 0 && he.update(() => {
        const qe = e.$getSelection(), nt = je.target;
        e.DEPRECATED_$isGridSelection(qe) && qe.gridKey === Re.tableNodeKey && be.contains(nt) && Re.clearHighlight();
      });
    };
    He.addEventListener("mousedown", Ve), Re.listenersToRemove.add(() => He.removeEventListener("mousedown", Ve)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_DOWN_COMMAND, (je) => j(he, je, "down", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_UP_COMMAND, (je) => j(he, je, "up", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_LEFT_COMMAND, (je) => j(he, je, "backward", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ARROW_RIGHT_COMMAND, (je) => j(he, je, "forward", ve, Re), e.COMMAND_PRIORITY_HIGH)), Re.listenersToRemove.add(he.registerCommand(e.KEY_ESCAPE_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (e.DEPRECATED_$isGridSelection(qe)) {
        const nt = t.$findMatchingParent(qe.focus.getNode(), T);
        if (T(nt))
          return ne(je), nt.selectEnd(), true;
      }
      return false;
    }, e.COMMAND_PRIORITY_HIGH));
    const Qe = (je) => () => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return false;
      if (e.DEPRECATED_$isGridSelection(qe))
        return Re.clearText(), true;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (Dt) => T(Dt));
        if (!T(nt))
          return false;
        const gt = qe.anchor.getNode(), Ct = qe.focus.getNode(), xt = ve.isParentOf(gt), St = ve.isParentOf(Ct);
        if (xt && !St || St && !xt)
          return Re.clearText(), true;
        const Et = t.$findMatchingParent(qe.anchor.getNode(), (Dt) => e.$isElementNode(Dt)), Yt = Et && t.$findMatchingParent(Et, (Dt) => e.$isElementNode(Dt) && T(Dt.getParent()));
        if (!e.$isElementNode(Yt) || !e.$isElementNode(Et))
          return false;
        if (je === e.DELETE_LINE_COMMAND && Yt.getPreviousSibling() === null)
          return true;
        if ((je === e.DELETE_CHARACTER_COMMAND || je === e.DELETE_WORD_COMMAND) && qe.isCollapsed() && qe.anchor.offset === 0 && Et !== Yt) {
          const Dt = Et.getChildren(), Kt = e.$createParagraphNode();
          return Dt.forEach((bt) => Kt.append(bt)), Et.replace(Kt), Et.getWritable().__parent = nt.getKey(), true;
        }
      }
      return false;
    };
    [e.DELETE_WORD_COMMAND, e.DELETE_LINE_COMMAND, e.DELETE_CHARACTER_COMMAND].forEach((je) => {
      Re.listenersToRemove.add(he.registerCommand(je, Qe(je), e.COMMAND_PRIORITY_CRITICAL));
    });
    const ct = (je) => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return false;
      if (e.DEPRECATED_$isGridSelection(qe))
        return je.preventDefault(), je.stopPropagation(), Re.clearText(), true;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (gt) => T(gt));
        if (!T(nt))
          return false;
      }
      return false;
    };
    Re.listenersToRemove.add(he.registerCommand(e.KEY_BACKSPACE_COMMAND, ct, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.KEY_DELETE_COMMAND, ct, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.FORMAT_TEXT_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return false;
      if (e.DEPRECATED_$isGridSelection(qe))
        return Re.formatCells(je), true;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (gt) => T(gt));
        if (!T(nt))
          return false;
      }
      return false;
    }, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.CONTROLLED_TEXT_INSERTION_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (!q(qe, ve))
        return false;
      if (e.DEPRECATED_$isGridSelection(qe))
        return Re.clearHighlight(), false;
      if (e.$isRangeSelection(qe)) {
        const nt = t.$findMatchingParent(qe.anchor.getNode(), (gt) => T(gt));
        if (!T(nt))
          return false;
      }
      return false;
    }, e.COMMAND_PRIORITY_CRITICAL)), Oe && Re.listenersToRemove.add(he.registerCommand(e.KEY_TAB_COMMAND, (je) => {
      const qe = e.$getSelection();
      if (!e.$isRangeSelection(qe) || !qe.isCollapsed() || !q(qe, ve))
        return false;
      const nt = P(qe.anchor.getNode());
      if (nt === null)
        return false;
      ne(je);
      const gt = ve.getCordsFromCellNode(nt, Re.grid);
      return V(Re, ve, gt.x, gt.y, je.shiftKey ? "backward" : "forward"), true;
    }, e.COMMAND_PRIORITY_CRITICAL)), Re.listenersToRemove.add(he.registerCommand(e.FOCUS_COMMAND, (je) => ve.isSelected(), e.COMMAND_PRIORITY_HIGH));
    function At(je) {
      const qe = ve.getCordsFromCellNode(je, Re.grid);
      return ve.getCellFromCordsOrThrow(qe.x, qe.y, Re.grid);
    }
    return Re.listenersToRemove.add(he.registerCommand(e.SELECTION_CHANGE_COMMAND, () => {
      const je = e.$getSelection(), qe = e.$getPreviousSelection();
      if (e.$isRangeSelection(je)) {
        const {
          anchor: nt,
          focus: gt
        } = je, Ct = nt.getNode(), xt = gt.getNode(), St = P(Ct), wt = P(xt), Et = St && ve.is(w(St)), Yt = wt && ve.is(w(wt)), Dt = Et !== Yt, Kt = Et && Yt, bt = je.isBackward();
        if (Dt) {
          const nr = je.clone();
          nr.focus.set(ve.getKey(), bt ? 0 : ve.getChildrenSize(), "element"), e.$setSelection(nr), re(he, Re);
        } else
          Kt && (St.is(wt) || (Re.setAnchorCellForSelection(At(St)), Re.setFocusCellForSelection(At(wt), true)));
      }
      return je && !je.is(qe) && (e.DEPRECATED_$isGridSelection(je) || e.DEPRECATED_$isGridSelection(qe)) && Re.gridSelection && !Re.gridSelection.is(qe) ? (e.DEPRECATED_$isGridSelection(je) && je.gridKey === Re.tableNodeKey ? Re.updateTableGridSelection(je) : !e.DEPRECATED_$isGridSelection(je) && e.DEPRECATED_$isGridSelection(qe) && qe.gridKey === Re.tableNodeKey && Re.updateTableGridSelection(null), false) : (Re.hasHijackedSelectionStyles && !ve.isSelected() ? de(he, Re) : !Re.hasHijackedSelectionStyles && ve.isSelected() && re(he, Re), false);
    }, e.COMMAND_PRIORITY_CRITICAL)), Re;
  }
  function U(ve, se) {
    ve[v] = se;
  }
  function I(ve) {
    return ve[v];
  }
  function K(ve) {
    let se = ve;
    for (; se != null; ) {
      const he = se.nodeName;
      if (he === "TD" || he === "TH") {
        const Oe = se._cell;
        return Oe === void 0 ? null : Oe;
      }
      se = se.parentNode;
    }
    return null;
  }
  function B(ve) {
    const se = [], he = {
      cells: se,
      columns: 0,
      rows: 0
    };
    let Oe = ve.firstChild, be = 0, Re = 0;
    for (se.length = 0; Oe != null; ) {
      const He = Oe.nodeName;
      if (He === "TD" || He === "TH") {
        const ct = Oe, At = {
          elem: ct,
          hasBackgroundColor: ct.style.backgroundColor !== "",
          highlighted: false,
          x: be,
          y: Re
        };
        Oe._cell = At;
        let je = se[Re];
        je === void 0 && (je = se[Re] = []), je[be] = At;
      } else {
        const ct = Oe.firstChild;
        if (ct != null) {
          Oe = ct;
          continue;
        }
      }
      const Ve = Oe.nextSibling;
      if (Ve != null) {
        be++, Oe = Ve;
        continue;
      }
      const Qe = Oe.parentNode;
      if (Qe != null) {
        const ct = Qe.nextSibling;
        if (ct == null)
          break;
        Re++, be = 0, Oe = ct;
      }
    }
    return he.columns = be + 1, he.rows = Re + 1, he;
  }
  function z(ve, se, he) {
    const Oe = new Set(he ? he.getNodes() : []);
    te(se, (be, Re) => {
      const He = be.elem;
      Oe.has(Re) ? (be.highlighted = true, Z(ve, be)) : (be.highlighted = false, ee(ve, be), He.getAttribute("style") || He.removeAttribute("style"));
    });
  }
  function te(ve, se) {
    const {
      cells: he
    } = ve;
    for (let Oe = 0; Oe < he.length; Oe++) {
      const be = he[Oe];
      if (be)
        for (let Re = 0; Re < be.length; Re++) {
          const He = be[Re];
          if (!He)
            continue;
          const Ve = e.$getNearestNodeFromDOMNode(He.elem);
          Ve !== null && se(He, Ve, {
            x: Re,
            y: Oe
          });
        }
    }
  }
  function re(ve, se) {
    se.disableHighlightStyle(), te(se.grid, (he) => {
      he.highlighted = true, Z(ve, he);
    });
  }
  function de(ve, se) {
    se.enableHighlightStyle(), te(se.grid, (he) => {
      const Oe = he.elem;
      he.highlighted = false, ee(ve, he), Oe.getAttribute("style") || Oe.removeAttribute("style");
    });
  }
  const V = (ve, se, he, Oe, be) => {
    const Re = be === "forward";
    switch (be) {
      case "backward":
      case "forward":
        return he !== (Re ? ve.grid.columns - 1 : 0) ? me(se.getCellNodeFromCordsOrThrow(he + (Re ? 1 : -1), Oe, ve.grid), Re) : Oe !== (Re ? ve.grid.rows - 1 : 0) ? me(se.getCellNodeFromCordsOrThrow(Re ? 0 : ve.grid.columns - 1, Oe + (Re ? 1 : -1), ve.grid), Re) : Re ? se.selectNext() : se.selectPrevious(), true;
      case "up":
        return Oe !== 0 ? me(se.getCellNodeFromCordsOrThrow(he, Oe - 1, ve.grid), false) : se.selectPrevious(), true;
      case "down":
        return Oe !== ve.grid.rows - 1 ? me(se.getCellNodeFromCordsOrThrow(he, Oe + 1, ve.grid), true) : se.selectNext(), true;
      default:
        return false;
    }
  }, G = (ve, se, he, Oe, be) => {
    const Re = be === "forward";
    switch (be) {
      case "backward":
      case "forward":
        return he !== (Re ? ve.grid.columns - 1 : 0) && ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he + (Re ? 1 : -1), Oe, ve.grid)), true;
      case "up":
        return Oe !== 0 ? (ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he, Oe - 1, ve.grid)), true) : false;
      case "down":
        return Oe !== ve.grid.rows - 1 ? (ve.setFocusCellForSelection(se.getCellFromCordsOrThrow(he, Oe + 1, ve.grid)), true) : false;
      default:
        return false;
    }
  };
  function q(ve, se) {
    if (e.$isRangeSelection(ve) || e.DEPRECATED_$isGridSelection(ve)) {
      const he = se.isParentOf(ve.anchor.getNode()), Oe = se.isParentOf(ve.focus.getNode());
      return he && Oe;
    }
    return false;
  }
  function me(ve, se) {
    se ? ve.selectStart() : ve.selectEnd();
  }
  const pe = "172,206,247";
  function Z(ve, se) {
    const he = se.elem, Oe = e.$getNearestNodeFromDOMNode(he);
    if (!T(Oe))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Oe.getBackgroundColor() === null ? he.style.setProperty("background-color", `rgb(${pe})`) : he.style.setProperty("background-image", `linear-gradient(to right, rgba(${pe},0.85), rgba(${pe},0.85))`), he.style.setProperty("caret-color", "transparent");
  }
  function ee(ve, se) {
    const he = se.elem, Oe = e.$getNearestNodeFromDOMNode(he);
    if (!T(Oe))
      throw Error("Expected to find LexicalNode from Table Cell DOMNode");
    Oe.getBackgroundColor() === null && he.style.removeProperty("background-color"), he.style.removeProperty("background-image"), he.style.removeProperty("caret-color");
  }
  function P(ve) {
    const se = t.$findMatchingParent(ve, T);
    return T(se) ? se : null;
  }
  function w(ve) {
    const se = t.$findMatchingParent(ve, g);
    return g(se) ? se : null;
  }
  function j(ve, se, he, Oe, be) {
    const Re = e.$getSelection();
    if (!q(Re, Oe))
      return false;
    if (e.$isRangeSelection(Re) && Re.isCollapsed()) {
      if (he === "backward" || he === "forward")
        return false;
      const {
        anchor: He,
        focus: Ve
      } = Re, Qe = t.$findMatchingParent(He.getNode(), T), ct = t.$findMatchingParent(Ve.getNode(), T);
      if (!T(Qe) || !Qe.is(ct))
        return false;
      const At = w(Qe);
      if (At !== Oe && At != null) {
        const wt = ve.getElementByKey(At.getKey());
        if (wt != null)
          return be.grid = B(wt), j(ve, se, he, At, be);
      }
      const je = ve.getElementByKey(Qe.__key), qe = ve.getElementByKey(He.key);
      if (qe == null || je == null)
        return false;
      let nt;
      if (He.type === "element")
        nt = qe.getBoundingClientRect();
      else {
        const wt = window.getSelection();
        if (wt === null || wt.rangeCount === 0)
          return false;
        nt = wt.getRangeAt(0).getBoundingClientRect();
      }
      const gt = he === "up" ? Qe.getFirstChild() : Qe.getLastChild();
      if (gt == null)
        return false;
      const Ct = ve.getElementByKey(gt.__key);
      if (Ct == null)
        return false;
      const xt = Ct.getBoundingClientRect();
      if (he === "up" ? xt.top > nt.top - nt.height : nt.bottom + nt.height > xt.bottom) {
        ne(se);
        const wt = Oe.getCordsFromCellNode(Qe, be.grid);
        if (se.shiftKey) {
          const Et = Oe.getCellFromCordsOrThrow(wt.x, wt.y, be.grid);
          be.setAnchorCellForSelection(Et), be.setFocusCellForSelection(Et, true);
        } else
          return V(be, Oe, wt.x, wt.y, he);
        return true;
      }
    } else if (e.DEPRECATED_$isGridSelection(Re)) {
      const {
        anchor: He,
        focus: Ve
      } = Re, Qe = t.$findMatchingParent(He.getNode(), T), ct = t.$findMatchingParent(Ve.getNode(), T), [At] = Re.getNodes(), je = ve.getElementByKey(At.getKey());
      if (!T(Qe) || !T(ct) || !g(At) || je == null)
        return false;
      be.updateTableGridSelection(Re);
      const qe = B(je), nt = Oe.getCordsFromCellNode(Qe, qe), gt = Oe.getCellFromCordsOrThrow(nt.x, nt.y, qe);
      if (be.setAnchorCellForSelection(gt), ne(se), se.shiftKey) {
        const Ct = Oe.getCordsFromCellNode(ct, qe);
        return G(be, At, Ct.x, Ct.y, he);
      } else
        ct.selectEnd();
      return true;
    }
    return false;
  }
  function ne(ve) {
    ve.preventDefault(), ve.stopImmediatePropagation(), ve.stopPropagation();
  }
  class Y extends e.DEPRECATED_GridNode {
    /** @internal */
    static getType() {
      return "table";
    }
    static clone(se) {
      return new Y(se.__key);
    }
    static importDOM() {
      return {
        table: (se) => ({
          conversion: Q,
          priority: 1
        })
      };
    }
    static importJSON(se) {
      return b();
    }
    constructor(se) {
      super(se);
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "table",
        version: 1
      };
    }
    createDOM(se, he) {
      const Oe = document.createElement("table");
      return t.addClassNamesToElement(Oe, se.theme.table), Oe;
    }
    updateDOM() {
      return false;
    }
    exportDOM(se) {
      return {
        ...super.exportDOM(se),
        after: (he) => {
          if (he) {
            const Oe = he.cloneNode(), be = document.createElement("colgroup"), Re = document.createElement("tbody");
            t.isHTMLElement(he) && Re.append(...he.children);
            const He = this.getFirstChildOrThrow();
            if (!D(He))
              throw new Error("Expected to find row node.");
            const Ve = He.getChildrenSize();
            for (let Qe = 0; Qe < Ve; Qe++) {
              const ct = document.createElement("col");
              be.append(ct);
            }
            return Oe.replaceChildren(be, Re), Oe;
          }
        }
      };
    }
    // TODO 0.10 deprecate
    canExtractContents() {
      return false;
    }
    canBeEmpty() {
      return false;
    }
    isShadowRoot() {
      return true;
    }
    getCordsFromCellNode(se, he) {
      const {
        rows: Oe,
        cells: be
      } = he;
      for (let Re = 0; Re < Oe; Re++) {
        const He = be[Re];
        if (He == null)
          continue;
        const Ve = He.findIndex((Qe) => {
          if (!Qe)
            return;
          const {
            elem: ct
          } = Qe;
          return e.$getNearestNodeFromDOMNode(ct) === se;
        });
        if (Ve !== -1)
          return {
            x: Ve,
            y: Re
          };
      }
      throw new Error("Cell not found in table.");
    }
    getCellFromCords(se, he, Oe) {
      const {
        cells: be
      } = Oe, Re = be[he];
      if (Re == null)
        return null;
      const He = Re[se];
      return He ?? null;
    }
    getCellFromCordsOrThrow(se, he, Oe) {
      const be = this.getCellFromCords(se, he, Oe);
      if (!be)
        throw new Error("Cell not found at cords.");
      return be;
    }
    getCellNodeFromCords(se, he, Oe) {
      const be = this.getCellFromCords(se, he, Oe);
      if (be == null)
        return null;
      const Re = e.$getNearestNodeFromDOMNode(be.elem);
      return T(Re) ? Re : null;
    }
    getCellNodeFromCordsOrThrow(se, he, Oe) {
      const be = this.getCellNodeFromCords(se, he, Oe);
      if (!be)
        throw new Error("Node at cords not TableCellNode.");
      return be;
    }
    canSelectBefore() {
      return true;
    }
    canIndent() {
      return false;
    }
  }
  function W(ve, se) {
    const he = ve.getElementByKey(se.getKey());
    if (he == null)
      throw new Error("Table Element Not Found");
    return B(he);
  }
  function Q(ve) {
    return {
      node: b()
    };
  }
  function b() {
    return e.$applyNodeReplacement(new Y());
  }
  function g(ve) {
    return ve instanceof Y;
  }
  function _(ve, se, he = true) {
    const Oe = b();
    for (let be = 0; be < ve; be++) {
      const Re = x();
      for (let He = 0; He < se; He++) {
        let Ve = o.NO_STATUS;
        typeof he == "object" ? (be === 0 && he.rows && (Ve |= o.ROW), He === 0 && he.columns && (Ve |= o.COLUMN)) : he && (be === 0 && (Ve |= o.ROW), He === 0 && (Ve |= o.COLUMN));
        const Qe = C(Ve), ct = e.$createParagraphNode();
        ct.append(e.$createTextNode()), Qe.append(ct), Re.append(Qe);
      }
      Oe.append(Re);
    }
    return Oe;
  }
  function A(ve) {
    const se = t.$findMatchingParent(ve, (he) => T(he));
    return T(se) ? se : null;
  }
  function J(ve) {
    const se = t.$findMatchingParent(ve, (he) => D(he));
    if (D(se))
      return se;
    throw new Error("Expected table cell to be inside of table row.");
  }
  function ce(ve) {
    const se = t.$findMatchingParent(ve, (he) => g(he));
    if (g(se))
      return se;
    throw new Error("Expected table cell to be inside of table.");
  }
  function ge(ve) {
    const se = J(ve);
    return ce(se).getChildren().findIndex((Oe) => Oe.is(se));
  }
  function ae(ve) {
    return J(ve).getChildren().findIndex((he) => he.is(ve));
  }
  function Te(ve, se) {
    const he = ce(ve), {
      x: Oe,
      y: be
    } = he.getCordsFromCellNode(ve, se);
    return {
      above: he.getCellNodeFromCords(Oe, be - 1, se),
      below: he.getCellNodeFromCords(Oe, be + 1, se),
      left: he.getCellNodeFromCords(Oe - 1, be, se),
      right: he.getCellNodeFromCords(Oe + 1, be, se)
    };
  }
  function Me(ve, se) {
    const he = ve.getChildren();
    if (se >= he.length || se < 0)
      throw new Error("Expected table cell to be inside of table row.");
    return he[se].remove(), ve;
  }
  function ze(ve, se, he = true, Oe, be) {
    const Re = ve.getChildren();
    if (se >= Re.length || se < 0)
      throw new Error("Table row target index out of range");
    const He = Re[se];
    if (D(He))
      for (let Ve = 0; Ve < Oe; Ve++) {
        const Qe = He.getChildren(), ct = Qe.length, At = x();
        for (let je = 0; je < ct; je++) {
          const qe = Qe[je];
          if (!T(qe))
            throw Error("Expected table cell");
          const {
            above: nt,
            below: gt
          } = Te(qe, be);
          let Ct = o.NO_STATUS;
          const xt = nt && nt.getWidth() || gt && gt.getWidth() || void 0;
          (nt && nt.hasHeaderState(o.COLUMN) || gt && gt.hasHeaderState(o.COLUMN)) && (Ct |= o.COLUMN);
          const St = C(Ct, 1, xt);
          St.append(e.$createParagraphNode()), At.append(St);
        }
        he ? He.insertAfter(At) : He.insertBefore(At);
      }
    else
      throw new Error("Row before insertion index does not exist.");
    return ve;
  }
  function oe(ve = true) {
    const se = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(se))
      throw Error("Expected a INTERNAL_PointSelection");
    const he = se.focus.getNode(), [Oe, , be] = e.DEPRECATED_$getNodeTriplet(he), [Re, He] = e.DEPRECATED_$computeGridMap(be, Oe, Oe), Ve = Re[0].length, {
      startRow: Qe
    } = He;
    if (ve) {
      const ct = Qe + Oe.__rowSpan - 1, At = Re[ct], je = x();
      for (let nt = 0; nt < Ve; nt++) {
        const {
          cell: gt,
          startRow: Ct
        } = At[nt];
        Ct + gt.__rowSpan - 1 <= ct ? je.append(C(o.NO_STATUS)) : gt.setRowSpan(gt.__rowSpan + 1);
      }
      const qe = be.getChildAtIndex(ct);
      if (!e.DEPRECATED_$isGridRowNode(qe))
        throw Error("focusEndRow is not a GridRowNode");
      qe.insertAfter(je);
    } else {
      const ct = Re[Qe], At = x();
      for (let qe = 0; qe < Ve; qe++) {
        const {
          cell: nt,
          startRow: gt
        } = ct[qe];
        gt === Qe ? At.append(C(o.NO_STATUS)) : nt.setRowSpan(nt.__rowSpan + 1);
      }
      const je = be.getChildAtIndex(Qe);
      if (!e.DEPRECATED_$isGridRowNode(je))
        throw Error("focusEndRow is not a GridRowNode");
      je.insertBefore(At);
    }
  }
  function ie(ve, se, he = true, Oe, be) {
    const Re = ve.getChildren(), He = [];
    for (let Ve = 0; Ve < Re.length; Ve++) {
      const Qe = Re[Ve];
      if (D(Qe))
        for (let ct = 0; ct < Oe; ct++) {
          const At = Qe.getChildren();
          if (se >= At.length || se < 0)
            throw new Error("Table column target index out of range");
          const je = At[se];
          if (!T(je))
            throw Error("Expected table cell");
          const {
            left: qe,
            right: nt
          } = Te(je, be);
          let gt = o.NO_STATUS;
          (qe && qe.hasHeaderState(o.ROW) || nt && nt.hasHeaderState(o.ROW)) && (gt |= o.ROW);
          const Ct = C(gt);
          Ct.append(e.$createParagraphNode()), He.push({
            newTableCell: Ct,
            targetCell: je
          });
        }
    }
    return He.forEach(({
      newTableCell: Ve,
      targetCell: Qe
    }) => {
      he ? Qe.insertAfter(Ve) : Qe.insertBefore(Ve);
    }), ve;
  }
  function ue(ve = true) {
    const se = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(se))
      throw Error("Expected a PointSeleciton");
    const he = se.anchor.getNode(), Oe = se.focus.getNode(), [be] = e.DEPRECATED_$getNodeTriplet(he), [Re, , He] = e.DEPRECATED_$getNodeTriplet(Oe), [Ve, Qe, ct] = e.DEPRECATED_$computeGridMap(He, Re, be), At = Ve.length, je = ve ? Math.max(Qe.startColumn, ct.startColumn) : Math.min(Qe.startColumn, ct.startColumn), qe = ve ? je + Re.__colSpan - 1 : je - 1, nt = He.getFirstChild();
    if (!e.DEPRECATED_$isGridRowNode(nt))
      throw Error("Expected firstTable child to be a row");
    let gt = null;
    function Ct() {
      const St = C(o.NO_STATUS).append(e.$createParagraphNode());
      return gt === null && (gt = St), St;
    }
    let xt = nt;
    e:
      for (let St = 0; St < At; St++) {
        if (St !== 0) {
          const Kt = xt.getNextSibling();
          if (!e.DEPRECATED_$isGridRowNode(Kt))
            throw Error("Expected row nextSibling to be a row");
          xt = Kt;
        }
        const wt = Ve[St];
        if (qe < 0) {
          st(xt, Ct());
          continue;
        }
        const {
          cell: Et,
          startColumn: Yt,
          startRow: Dt
        } = wt[qe];
        if (Yt + Et.__colSpan - 1 <= qe) {
          let Kt = Et, bt = Dt, nr = qe;
          for (; bt !== St && Kt.__rowSpan > 1; )
            if (nr -= Et.__colSpan, nr >= 0) {
              const {
                cell: gr,
                startRow: Ci
              } = wt[nr];
              Kt = gr, bt = Ci;
            } else {
              xt.append(Ct());
              continue e;
            }
          Kt.insertAfter(Ct());
        } else
          Et.setColSpan(Et.__colSpan + 1);
      }
    gt !== null && Ye(gt);
  }
  function we(ve, se) {
    const he = ve.getChildren();
    for (let Oe = 0; Oe < he.length; Oe++) {
      const be = he[Oe];
      if (D(be)) {
        const Re = be.getChildren();
        if (se >= Re.length || se < 0)
          throw new Error("Table column target index out of range");
        Re[se].remove();
      }
    }
    return ve;
  }
  function Le() {
    const ve = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), he = ve.focus.getNode(), [Oe, , be] = e.DEPRECATED_$getNodeTriplet(se), [Re] = e.DEPRECATED_$getNodeTriplet(he), [He, Ve, Qe] = e.DEPRECATED_$computeGridMap(be, Oe, Re), {
      startRow: ct
    } = Ve, {
      startRow: At
    } = Qe, je = At + Re.__rowSpan - 1;
    if (He.length === je - ct + 1) {
      be.remove();
      return;
    }
    const qe = He[0].length, nt = He[je + 1], gt = be.getChildAtIndex(je + 1);
    for (let Ct = je; Ct >= ct; Ct--) {
      for (let St = qe - 1; St >= 0; St--) {
        const {
          cell: wt,
          startRow: Et,
          startColumn: Yt
        } = He[Ct][St];
        if (Yt === St && (Ct === ct && Et < ct && wt.setRowSpan(wt.__rowSpan - (Et - ct)), Et >= ct && Et + wt.__rowSpan - 1 > je)) {
          if (wt.setRowSpan(wt.__rowSpan - (je - Et + 1)), gt === null)
            throw Error("Expected nextRowNode not to be null");
          if (St === 0)
            st(gt, wt);
          else {
            const {
              cell: Dt
            } = nt[St - 1];
            Dt.insertAfter(wt);
          }
        }
      }
      const xt = be.getChildAtIndex(Ct);
      if (!e.DEPRECATED_$isGridRowNode(xt))
        throw Error(`Expected GridNode childAtIndex(${String(Ct)}) to be RowNode`);
      xt.remove();
    }
    if (nt !== void 0) {
      const {
        cell: Ct
      } = nt[0];
      Ye(Ct);
    } else {
      const Ct = He[ct - 1], {
        cell: xt
      } = Ct[0];
      Ye(xt);
    }
  }
  function Be() {
    const ve = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), he = ve.focus.getNode(), [Oe, , be] = e.DEPRECATED_$getNodeTriplet(se), [Re] = e.DEPRECATED_$getNodeTriplet(he), [He, Ve, Qe] = e.DEPRECATED_$computeGridMap(be, Oe, Re), {
      startColumn: ct
    } = Ve, {
      startRow: At,
      startColumn: je
    } = Qe, qe = Math.min(ct, je), nt = Math.max(ct + Oe.__colSpan - 1, je + Re.__colSpan - 1), gt = nt - qe + 1;
    if (He[0].length === nt - qe + 1) {
      be.selectPrevious(), be.remove();
      return;
    }
    const xt = He.length;
    for (let Et = 0; Et < xt; Et++)
      for (let Yt = qe; Yt <= nt; Yt++) {
        const {
          cell: Dt,
          startColumn: Kt
        } = He[Et][Yt];
        if (Kt < qe) {
          if (Yt === qe) {
            const bt = qe - Kt;
            Dt.setColSpan(Dt.__colSpan - // Possible overflow right too
            Math.min(gt, Dt.__colSpan - bt));
          }
        } else if (Kt + Dt.__colSpan - 1 > nt) {
          if (Yt === nt) {
            const bt = nt - Kt + 1;
            Dt.setColSpan(Dt.__colSpan - bt);
          }
        } else
          Dt.remove();
      }
    const St = He[At], wt = St[je + Re.__colSpan];
    if (wt !== void 0) {
      const {
        cell: Et
      } = wt;
      Ye(Et);
    } else {
      const Et = St[je - 1], {
        cell: Yt
      } = Et;
      Ye(Yt);
    }
  }
  function Ye(ve) {
    const se = ve.getFirstDescendant();
    se == null ? ve.selectStart() : se.getParentOrThrow().selectStart();
  }
  function st(ve, se) {
    const he = ve.getFirstChild();
    he !== null ? he.insertBefore(se) : ve.append(se);
  }
  function pt() {
    const ve = e.$getSelection();
    if (!e.$INTERNAL_isPointSelection(ve))
      throw Error("Expected a INTERNAL_PointSelection");
    const se = ve.anchor.getNode(), [he, Oe, be] = e.DEPRECATED_$getNodeTriplet(se), Re = he.__colSpan, He = he.__rowSpan;
    if (Re > 1) {
      for (let Ve = 1; Ve < Re; Ve++)
        he.insertAfter(C(o.NO_STATUS));
      he.setColSpan(1);
    }
    if (He > 1) {
      const [Ve, Qe] = e.DEPRECATED_$computeGridMap(be, he, he), {
        startColumn: ct,
        startRow: At
      } = Qe;
      let je;
      for (let qe = 1; qe < He; qe++) {
        const nt = At + qe, gt = Ve[nt];
        if (je = (je || Oe).getNextSibling(), !e.DEPRECATED_$isGridRowNode(je))
          throw Error("Expected row next sibling to be a row");
        let Ct = null;
        for (let xt = 0; xt < ct; xt++) {
          const St = gt[xt], wt = St.cell;
          St.startRow === nt && (Ct = wt), wt.__colSpan > 1 && (xt += wt.__colSpan - 1);
        }
        if (Ct === null)
          for (let xt = 0; xt < Re; xt++)
            st(je, C(o.NO_STATUS));
        else
          for (let xt = 0; xt < Re; xt++)
            Ct.insertAfter(C(o.NO_STATUS));
      }
      he.setRowSpan(1);
    }
  }
  const at = e.createCommand("INSERT_TABLE_COMMAND");
  return Ut.$createTableCellNode = C, Ut.$createTableNode = b, Ut.$createTableNodeWithDimensions = _, Ut.$createTableRowNode = x, Ut.$deleteTableColumn = we, Ut.$deleteTableColumn__EXPERIMENTAL = Be, Ut.$deleteTableRow__EXPERIMENTAL = Le, Ut.$getElementGridForTableNode = W, Ut.$getTableCellNodeFromLexicalNode = A, Ut.$getTableColumnIndexFromTableCellNode = ae, Ut.$getTableNodeFromLexicalNodeOrThrow = ce, Ut.$getTableRowIndexFromTableCellNode = ge, Ut.$getTableRowNodeFromTableCellNodeOrThrow = J, Ut.$insertTableColumn = ie, Ut.$insertTableColumn__EXPERIMENTAL = ue, Ut.$insertTableRow = ze, Ut.$insertTableRow__EXPERIMENTAL = oe, Ut.$isTableCellNode = T, Ut.$isTableNode = g, Ut.$isTableRowNode = D, Ut.$removeTableRowAtIndex = Me, Ut.$unmergeCell = pt, Ut.INSERT_TABLE_COMMAND = at, Ut.TableCellHeaderStates = o, Ut.TableCellNode = f, Ut.TableNode = Y, Ut.TableRowNode = O, Ut.TableSelection = N, Ut.applyTableHandlers = F, Ut.getCellFromTarget = K, Ut.getTableSelectionFromTableElement = I, Ut;
}
var uc;
var bd;
function Kc() {
  return bd || (bd = 1, uc = true ? k_() : I_()), uc;
}
var dc = {};
var Ld;
function F_() {
  if (Ld)
    return dc;
  Ld = 1;
  var e = kn(), t = Kc(), r = Jt(), o = kt(), f = import_react.default;
  function h({
    hasCellMerge: C = true,
    hasCellBackgroundColor: T = true,
    hasTabHandler: O = true
  }) {
    const [S] = e.useLexicalComposerContext();
    return f.useEffect(() => {
      if (!S.hasNodes([t.TableNode, t.TableCellNode, t.TableRowNode]))
        throw Error("TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor");
      return S.registerCommand(t.INSERT_TABLE_COMMAND, ({
        columns: x,
        rows: D,
        includeHeaders: k
      }) => {
        const H = t.$createTableNodeWithDimensions(Number(D), Number(x), k);
        r.$insertNodeToNearestRoot(H);
        const N = H.getFirstDescendant();
        return o.$isTextNode(N) && N.select(), true;
      }, o.COMMAND_PRIORITY_EDITOR);
    }, [S]), f.useEffect(() => {
      const x = /* @__PURE__ */ new Map(), D = (H) => {
        const N = H.getKey(), v = S.getElementByKey(N);
        if (v && !x.has(N)) {
          const F = t.applyTableHandlers(H, v, S, O);
          x.set(N, F);
        }
      };
      S.getEditorState().read(() => {
        const H = o.$nodesOfType(t.TableNode);
        for (const N of H)
          t.$isTableNode(N) && D(N);
      });
      const k = S.registerMutationListener(t.TableNode, (H) => {
        for (const [N, v] of H)
          if (v === "created")
            S.getEditorState().read(() => {
              const F = o.$getNodeByKey(N);
              t.$isTableNode(F) && D(F);
            });
          else if (v === "destroyed") {
            const F = x.get(N);
            F !== void 0 && (F.removeListeners(), x.delete(N));
          }
      });
      return () => {
        k();
        for (const [, H] of x)
          H.removeListeners();
      };
    }, [S, O]), f.useEffect(() => {
      if (!C)
        return S.registerNodeTransform(t.TableCellNode, (x) => {
          if (x.getColSpan() > 1 || x.getRowSpan() > 1) {
            const [, , D] = o.DEPRECATED_$getNodeTriplet(x), [k] = o.DEPRECATED_$computeGridMap(D, x, x), H = k.length, N = k[0].length;
            let v = D.getFirstChild();
            if (!o.DEPRECATED_$isGridRowNode(v))
              throw Error("Expected TableNode first child to be a RowNode");
            const F = [];
            for (let U = 0; U < H; U++) {
              if (U !== 0 && (v = v.getNextSibling(), !o.DEPRECATED_$isGridRowNode(v)))
                throw Error("Expected TableNode first child to be a RowNode");
              let I = null;
              for (let K = 0; K < N; K++) {
                const B = k[U][K], z = B.cell;
                if (B.startRow === U && B.startColumn === K)
                  I = z, F.push(z);
                else if (z.getColSpan() > 1 || z.getRowSpan() > 1) {
                  const te = t.$createTableCellNode(z.__headerState);
                  I !== null ? I.insertAfter(te) : r.$insertFirst(v, te);
                }
              }
            }
            for (const U of F)
              U.setColSpan(1), U.setRowSpan(1);
          }
        });
    }, [S, C]), f.useEffect(() => {
      if (!T)
        return S.registerNodeTransform(t.TableCellNode, (x) => {
          x.getBackgroundColor() !== null && x.setBackgroundColor(null);
        });
    }, [S, T, C]), null;
  }
  return dc.TablePlugin = h, dc;
}
var B_ = true ? F_() : $_();
var K_ = B_;
var fc = { exports: {} };
var Pd;
function uh() {
  return Pd || (Pd = 1, function(e) {
    var t = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
    var r = function(o) {
      var f = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, h = 0, C = {}, T = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: o.Prism && o.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: o.Prism && o.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function I(K) {
            return K instanceof O ? new O(K.type, I(K.content), K.alias) : Array.isArray(K) ? K.map(I) : K.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(I) {
            return Object.prototype.toString.call(I).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(I) {
            return I.__id || Object.defineProperty(I, "__id", { value: ++h }), I.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function I(K, B) {
            B = B || {};
            var z, te;
            switch (T.util.type(K)) {
              case "Object":
                if (te = T.util.objId(K), B[te])
                  return B[te];
                z = /** @type {Record<string, any>} */
                {}, B[te] = z;
                for (var re in K)
                  K.hasOwnProperty(re) && (z[re] = I(K[re], B));
                return (
                  /** @type {any} */
                  z
                );
              case "Array":
                return te = T.util.objId(K), B[te] ? B[te] : (z = [], B[te] = z, /** @type {Array} */
                /** @type {any} */
                K.forEach(function(de, V) {
                  z[V] = I(de, B);
                }), /** @type {any} */
                z);
              default:
                return K;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(I) {
            for (; I; ) {
              var K = f.exec(I.className);
              if (K)
                return K[1].toLowerCase();
              I = I.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(I, K) {
            I.className = I.className.replace(RegExp(f, "gi"), ""), I.classList.add("language-" + K);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document > "u")
              return null;
            if ("currentScript" in document && 1 < 2)
              return (
                /** @type {any} */
                document.currentScript
              );
            try {
              throw new Error();
            } catch (z) {
              var I = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(z.stack) || [])[1];
              if (I) {
                var K = document.getElementsByTagName("script");
                for (var B in K)
                  if (K[B].src == I)
                    return K[B];
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(I, K, B) {
            for (var z = "no-" + K; I; ) {
              var te = I.classList;
              if (te.contains(K))
                return true;
              if (te.contains(z))
                return false;
              I = I.parentElement;
            }
            return !!B;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: C,
          plaintext: C,
          text: C,
          txt: C,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(I, K) {
            var B = T.util.clone(T.languages[I]);
            for (var z in K)
              B[z] = K[z];
            return B;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(I, K, B, z) {
            z = z || /** @type {any} */
            T.languages;
            var te = z[I], re = {};
            for (var de in te)
              if (te.hasOwnProperty(de)) {
                if (de == K)
                  for (var V in B)
                    B.hasOwnProperty(V) && (re[V] = B[V]);
                B.hasOwnProperty(de) || (re[de] = te[de]);
              }
            var G = z[I];
            return z[I] = re, T.languages.DFS(T.languages, function(q, me) {
              me === G && q != I && (this[q] = re);
            }), re;
          },
          // Traverse a language definition with Depth First Search
          DFS: function I(K, B, z, te) {
            te = te || {};
            var re = T.util.objId;
            for (var de in K)
              if (K.hasOwnProperty(de)) {
                B.call(K, de, K[de], z || de);
                var V = K[de], G = T.util.type(V);
                G === "Object" && !te[re(V)] ? (te[re(V)] = true, I(V, B, null, te)) : G === "Array" && !te[re(V)] && (te[re(V)] = true, I(V, B, de, te));
              }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(I, K) {
          T.highlightAllUnder(document, I, K);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(I, K, B) {
          var z = {
            callback: B,
            container: I,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          T.hooks.run("before-highlightall", z), z.elements = Array.prototype.slice.apply(z.container.querySelectorAll(z.selector)), T.hooks.run("before-all-elements-highlight", z);
          for (var te = 0, re; re = z.elements[te++]; )
            T.highlightElement(re, K === true, z.callback);
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(I, K, B) {
          var z = T.util.getLanguage(I), te = T.languages[z];
          T.util.setLanguage(I, z);
          var re = I.parentElement;
          re && re.nodeName.toLowerCase() === "pre" && T.util.setLanguage(re, z);
          var de = I.textContent, V = {
            element: I,
            language: z,
            grammar: te,
            code: de
          };
          function G(me) {
            V.highlightedCode = me, T.hooks.run("before-insert", V), V.element.innerHTML = V.highlightedCode, T.hooks.run("after-highlight", V), T.hooks.run("complete", V), B && B.call(V.element);
          }
          if (T.hooks.run("before-sanity-check", V), re = V.element.parentElement, re && re.nodeName.toLowerCase() === "pre" && !re.hasAttribute("tabindex") && re.setAttribute("tabindex", "0"), !V.code) {
            T.hooks.run("complete", V), B && B.call(V.element);
            return;
          }
          if (T.hooks.run("before-highlight", V), !V.grammar) {
            G(T.util.encode(V.code));
            return;
          }
          if (K && o.Worker) {
            var q = new Worker(T.filename);
            q.onmessage = function(me) {
              G(me.data);
            }, q.postMessage(JSON.stringify({
              language: V.language,
              code: V.code,
              immediateClose: true
            }));
          } else
            G(T.highlight(V.code, V.grammar, V.language));
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(I, K, B) {
          var z = {
            code: I,
            grammar: K,
            language: B
          };
          if (T.hooks.run("before-tokenize", z), !z.grammar)
            throw new Error('The language "' + z.language + '" has no grammar.');
          return z.tokens = T.tokenize(z.code, z.grammar), T.hooks.run("after-tokenize", z), O.stringify(T.util.encode(z.tokens), z.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(I, K) {
          var B = K.rest;
          if (B) {
            for (var z in B)
              K[z] = B[z];
            delete K.rest;
          }
          var te = new D();
          return k(te, te.head, I), x(I, te, K, te.head, 0), N(te);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(I, K) {
            var B = T.hooks.all;
            B[I] = B[I] || [], B[I].push(K);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(I, K) {
            var B = T.hooks.all[I];
            if (!(!B || !B.length))
              for (var z = 0, te; te = B[z++]; )
                te(K);
          }
        },
        Token: O
      };
      o.Prism = T;
      function O(I, K, B, z) {
        this.type = I, this.content = K, this.alias = B, this.length = (z || "").length | 0;
      }
      O.stringify = function I(K, B) {
        if (typeof K == "string")
          return K;
        if (Array.isArray(K)) {
          var z = "";
          return K.forEach(function(G) {
            z += I(G, B);
          }), z;
        }
        var te = {
          type: K.type,
          content: I(K.content, B),
          tag: "span",
          classes: ["token", K.type],
          attributes: {},
          language: B
        }, re = K.alias;
        re && (Array.isArray(re) ? Array.prototype.push.apply(te.classes, re) : te.classes.push(re)), T.hooks.run("wrap", te);
        var de = "";
        for (var V in te.attributes)
          de += " " + V + '="' + (te.attributes[V] || "").replace(/"/g, "&quot;") + '"';
        return "<" + te.tag + ' class="' + te.classes.join(" ") + '"' + de + ">" + te.content + "</" + te.tag + ">";
      };
      function S(I, K, B, z) {
        I.lastIndex = K;
        var te = I.exec(B);
        if (te && z && te[1]) {
          var re = te[1].length;
          te.index += re, te[0] = te[0].slice(re);
        }
        return te;
      }
      function x(I, K, B, z, te, re) {
        for (var de in B)
          if (!(!B.hasOwnProperty(de) || !B[de])) {
            var V = B[de];
            V = Array.isArray(V) ? V : [V];
            for (var G = 0; G < V.length; ++G) {
              if (re && re.cause == de + "," + G)
                return;
              var q = V[G], me = q.inside, pe = !!q.lookbehind, Z = !!q.greedy, ee = q.alias;
              if (Z && !q.pattern.global) {
                var P = q.pattern.toString().match(/[imsuy]*$/)[0];
                q.pattern = RegExp(q.pattern.source, P + "g");
              }
              for (var w = q.pattern || q, j = z.next, ne = te; j !== K.tail && !(re && ne >= re.reach); ne += j.value.length, j = j.next) {
                var Y = j.value;
                if (K.length > I.length)
                  return;
                if (!(Y instanceof O)) {
                  var W = 1, Q;
                  if (Z) {
                    if (Q = S(w, ne, I, pe), !Q || Q.index >= I.length)
                      break;
                    var A = Q.index, b = Q.index + Q[0].length, g = ne;
                    for (g += j.value.length; A >= g; )
                      j = j.next, g += j.value.length;
                    if (g -= j.value.length, ne = g, j.value instanceof O)
                      continue;
                    for (var _ = j; _ !== K.tail && (g < b || typeof _.value == "string"); _ = _.next)
                      W++, g += _.value.length;
                    W--, Y = I.slice(ne, g), Q.index -= ne;
                  } else if (Q = S(w, 0, Y, pe), !Q)
                    continue;
                  var A = Q.index, J = Q[0], ce = Y.slice(0, A), ge = Y.slice(A + J.length), ae = ne + Y.length;
                  re && ae > re.reach && (re.reach = ae);
                  var Te = j.prev;
                  ce && (Te = k(K, Te, ce), ne += ce.length), H(K, Te, W);
                  var Me = new O(de, me ? T.tokenize(J, me) : J, ee, J);
                  if (j = k(K, Te, Me), ge && k(K, j, ge), W > 1) {
                    var ze = {
                      cause: de + "," + G,
                      reach: ae
                    };
                    x(I, K, B, j.prev, ne, ze), re && ze.reach > re.reach && (re.reach = ze.reach);
                  }
                }
              }
            }
          }
      }
      function D() {
        var I = { value: null, prev: null, next: null }, K = { value: null, prev: I, next: null };
        I.next = K, this.head = I, this.tail = K, this.length = 0;
      }
      function k(I, K, B) {
        var z = K.next, te = { value: B, prev: K, next: z };
        return K.next = te, z.prev = te, I.length++, te;
      }
      function H(I, K, B) {
        for (var z = K.next, te = 0; te < B && z !== I.tail; te++)
          z = z.next;
        K.next = z, z.prev = K, I.length -= te;
      }
      function N(I) {
        for (var K = [], B = I.head.next; B !== I.tail; )
          K.push(B.value), B = B.next;
        return K;
      }
      if (!o.document)
        return o.addEventListener && (T.disableWorkerMessageHandler || o.addEventListener("message", function(I) {
          var K = JSON.parse(I.data), B = K.language, z = K.code, te = K.immediateClose;
          o.postMessage(T.highlight(z, T.languages[B], B)), te && o.close();
        }, false)), T;
      var v = T.util.currentScript();
      v && (T.filename = v.src, v.hasAttribute("data-manual") && (T.manual = true));
      function F() {
        T.manual || T.highlightAll();
      }
      if (!T.manual) {
        var U = document.readyState;
        U === "loading" || U === "interactive" && v && v.defer ? document.addEventListener("DOMContentLoaded", F) : window.requestAnimationFrame ? window.requestAnimationFrame(F) : window.setTimeout(F, 16);
      }
      return T;
    }(t);
    e.exports && (e.exports = r), typeof Cc < "u" && (Cc.Prism = r), r.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(o) {
      o.type === "entity" && (o.attributes.title = o.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function(f, h) {
        var C = {};
        C["language-" + h] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: r.languages[h]
        }, C.cdata = /^<!\[CDATA\[|\]\]>$/i;
        var T = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: C
          }
        };
        T["language-" + h] = {
          pattern: /[\s\S]+/,
          inside: r.languages[h]
        };
        var O = {};
        O[f] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return f;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside: T
        }, r.languages.insertBefore("markup", "cdata", O);
      }
    }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(o, f) {
        r.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + o + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [f, "language-" + f],
                  inside: r.languages[f]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(o) {
      var f = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      o.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + f.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + f.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + f.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + f.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        string: {
          pattern: f,
          greedy: true
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        punctuation: /[(){};:,]/
      }, o.languages.css.atrule.inside.rest = o.languages.css;
      var h = o.languages.markup;
      h && (h.tag.addInlined("style", "css"), h.tag.addAttribute("style", "css"));
    }(r), r.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    }, r.languages.javascript = r.languages.extend("clike", {
      "class-name": [
        r.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: r.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: r.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: r.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: r.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: r.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    }), r.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: r.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    }), r.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
      /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
      "javascript"
    )), r.languages.js = r.languages.javascript, function() {
      if (typeof r > "u" || typeof document > "u")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var o = "Loading…", f = function(v, F) {
        return "✖ Error " + v + " while fetching file: " + F;
      }, h = "✖ Error: File does not exist or is empty", C = {
        js: "javascript",
        py: "python",
        rb: "ruby",
        ps1: "powershell",
        psm1: "powershell",
        sh: "bash",
        bat: "batch",
        h: "c",
        tex: "latex"
      }, T = "data-src-status", O = "loading", S = "loaded", x = "failed", D = "pre[data-src]:not([" + T + '="' + S + '"]):not([' + T + '="' + O + '"])';
      function k(v, F, U) {
        var I = new XMLHttpRequest();
        I.open("GET", v, true), I.onreadystatechange = function() {
          I.readyState == 4 && (I.status < 400 && I.responseText ? F(I.responseText) : I.status >= 400 ? U(f(I.status, I.statusText)) : U(h));
        }, I.send(null);
      }
      function H(v) {
        var F = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(v || "");
        if (F) {
          var U = Number(F[1]), I = F[2], K = F[3];
          return I ? K ? [U, Number(K)] : [U, void 0] : [U, U];
        }
      }
      r.hooks.add("before-highlightall", function(v) {
        v.selector += ", " + D;
      }), r.hooks.add("before-sanity-check", function(v) {
        var F = (
          /** @type {HTMLPreElement} */
          v.element
        );
        if (F.matches(D)) {
          v.code = "", F.setAttribute(T, O);
          var U = F.appendChild(document.createElement("CODE"));
          U.textContent = o;
          var I = F.getAttribute("data-src"), K = v.language;
          if (K === "none") {
            var B = (/\.(\w+)$/.exec(I) || [, "none"])[1];
            K = C[B] || B;
          }
          r.util.setLanguage(U, K), r.util.setLanguage(F, K);
          var z = r.plugins.autoloader;
          z && z.loadLanguages(K), k(
            I,
            function(te) {
              F.setAttribute(T, S);
              var re = H(F.getAttribute("data-range"));
              if (re) {
                var de = te.split(/\r\n?|\n/g), V = re[0], G = re[1] == null ? de.length : re[1];
                V < 0 && (V += de.length), V = Math.max(0, Math.min(V - 1, de.length)), G < 0 && (G += de.length), G = Math.max(0, Math.min(G, de.length)), te = de.slice(V, G).join(`
`), F.hasAttribute("data-start") || F.setAttribute("data-start", String(V + 1));
              }
              U.textContent = te, r.highlightElement(U);
            },
            function(te) {
              F.setAttribute(T, x), U.textContent = te;
            }
          );
        }
      }), r.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function(F) {
          for (var U = (F || document).querySelectorAll(D), I = 0, K; K = U[I++]; )
            r.highlightElement(K);
        }
      };
      var N = false;
      r.fileHighlight = function() {
        N || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), N = true), r.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }();
  }(fc)), fc.exports;
}
var Id = {};
var kd;
function dh() {
  return kd || (kd = 1, Prism.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }), Id;
}
var $d = {};
var Fd;
function fh() {
  return Fd || (Fd = 1, Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
      Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: true
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  }), Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism.languages.js = Prism.languages.javascript), $d;
}
var Bd = {};
var Kd;
function hh() {
  return Kd || (Kd = 1, Prism.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
    e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(t, r) {
      var o = {};
      o["language-" + r] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism.languages[r]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var f = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      f["language-" + r] = {
        pattern: /[\s\S]+/,
        inside: Prism.languages[r]
      };
      var h = {};
      h[t] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return t;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside: f
      }, Prism.languages.insertBefore("markup", "cdata", h);
    }
  }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(e, t) {
      Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [t, "language-" + t],
                inside: Prism.languages[t]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml), Bd;
}
var Hd = {};
var Ud;
function gh() {
  return Ud || (Ud = 1, function(e) {
    var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    function r(x) {
      return x = x.replace(/<inner>/g, function() {
        return t;
      }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + x + ")");
    }
    var o = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, f = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
      return o;
    }), h = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    e.languages.markdown = e.languages.extend("markup", {}), e.languages.insertBefore("markdown", "prolog", {
      "front-matter-block": {
        pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
        lookbehind: true,
        greedy: true,
        inside: {
          punctuation: /^---|---$/,
          "front-matter": {
            pattern: /\S+(?:\s+\S+)*/,
            alias: ["yaml", "language-yaml"],
            inside: e.languages.yaml
          }
        }
      },
      blockquote: {
        // > ...
        pattern: /^>(?:[\t ]*>)*/m,
        alias: "punctuation"
      },
      table: {
        pattern: RegExp("^" + f + h + "(?:" + f + ")*", "m"),
        inside: {
          "table-data-rows": {
            pattern: RegExp("^(" + f + h + ")(?:" + f + ")*$"),
            lookbehind: true,
            inside: {
              "table-data": {
                pattern: RegExp(o),
                inside: e.languages.markdown
              },
              punctuation: /\|/
            }
          },
          "table-line": {
            pattern: RegExp("^(" + f + ")" + h + "$"),
            lookbehind: true,
            inside: {
              punctuation: /\||:?-{3,}:?/
            }
          },
          "table-header-row": {
            pattern: RegExp("^" + f + "$"),
            inside: {
              "table-header": {
                pattern: RegExp(o),
                alias: "important",
                inside: e.languages.markdown
              },
              punctuation: /\|/
            }
          }
        }
      },
      code: [
        {
          // Prefixed by 4 spaces or 1 tab and preceded by an empty line
          pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
          lookbehind: true,
          alias: "keyword"
        },
        {
          // ```optional language
          // code block
          // ```
          pattern: /^```[\s\S]*?^```$/m,
          greedy: true,
          inside: {
            "code-block": {
              pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
              lookbehind: true
            },
            "code-language": {
              pattern: /^(```).+/,
              lookbehind: true
            },
            punctuation: /```/
          }
        }
      ],
      title: [
        {
          // title 1
          // =======
          // title 2
          // -------
          pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
          alias: "important",
          inside: {
            punctuation: /==+$|--+$/
          }
        },
        {
          // # title 1
          // ###### title 6
          pattern: /(^\s*)#.+/m,
          lookbehind: true,
          alias: "important",
          inside: {
            punctuation: /^#+|#+$/
          }
        }
      ],
      hr: {
        // ***
        // ---
        // * * *
        // -----------
        pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
        lookbehind: true,
        alias: "punctuation"
      },
      list: {
        // * item
        // + item
        // - item
        // 1. item
        pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
        lookbehind: true,
        alias: "punctuation"
      },
      "url-reference": {
        // [id]: http://example.com "Optional title"
        // [id]: http://example.com 'Optional title'
        // [id]: http://example.com (Optional title)
        // [id]: <http://example.com> "Optional title"
        pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
        inside: {
          variable: {
            pattern: /^(!?\[)[^\]]+/,
            lookbehind: true
          },
          string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
          punctuation: /^[\[\]!:]|[<>]/
        },
        alias: "url"
      },
      bold: {
        // **strong**
        // __strong__
        // allow one nested instance of italic text using the same delimiter
        pattern: r(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          content: {
            pattern: /(^..)[\s\S]+(?=..$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          punctuation: /\*\*|__/
        }
      },
      italic: {
        // *em*
        // _em_
        // allow one nested instance of bold text using the same delimiter
        pattern: r(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          content: {
            pattern: /(^.)[\s\S]+(?=.$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          punctuation: /[*_]/
        }
      },
      strike: {
        // ~~strike through~~
        // ~strike~
        // eslint-disable-next-line regexp/strict
        pattern: r(/(~~?)(?:(?!~)<inner>)+\2/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          content: {
            pattern: /(^~~?)[\s\S]+(?=\1$)/,
            lookbehind: true,
            inside: {}
            // see below
          },
          punctuation: /~~?/
        }
      },
      "code-snippet": {
        // `code`
        // ``code``
        pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
        lookbehind: true,
        greedy: true,
        alias: ["code", "keyword"]
      },
      url: {
        // [example](http://example.com "Optional title")
        // [example][id]
        // [example] [id]
        pattern: r(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
        lookbehind: true,
        greedy: true,
        inside: {
          operator: /^!/,
          content: {
            pattern: /(^\[)[^\]]+(?=\])/,
            lookbehind: true,
            inside: {}
            // see below
          },
          variable: {
            pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
            lookbehind: true
          },
          url: {
            pattern: /(^\]\()[^\s)]+/,
            lookbehind: true
          },
          string: {
            pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
            lookbehind: true
          }
        }
      }
    }), ["url", "bold", "italic", "strike"].forEach(function(x) {
      ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(D) {
        x !== D && (e.languages.markdown[x].inside.content.inside[D] = e.languages.markdown[D]);
      });
    }), e.hooks.add("after-tokenize", function(x) {
      if (x.language !== "markdown" && x.language !== "md")
        return;
      function D(k) {
        if (!(!k || typeof k == "string"))
          for (var H = 0, N = k.length; H < N; H++) {
            var v = k[H];
            if (v.type !== "code") {
              D(v.content);
              continue;
            }
            var F = v.content[1], U = v.content[3];
            if (F && U && F.type === "code-language" && U.type === "code-block" && typeof F.content == "string") {
              var I = F.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              I = (/[a-z][\w-]*/i.exec(I) || [""])[0].toLowerCase();
              var K = "language-" + I;
              U.alias ? typeof U.alias == "string" ? U.alias = [U.alias, K] : U.alias.push(K) : U.alias = [K];
            }
          }
      }
      D(x.tokens);
    }), e.hooks.add("wrap", function(x) {
      if (x.type === "code-block") {
        for (var D = "", k = 0, H = x.classes.length; k < H; k++) {
          var N = x.classes[k], v = /language-(.+)/.exec(N);
          if (v) {
            D = v[1];
            break;
          }
        }
        var F = e.languages[D];
        if (F)
          x.content = e.highlight(S(x.content), F, D);
        else if (D && D !== "none" && e.plugins.autoloader) {
          var U = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
          x.attributes.id = U, e.plugins.autoloader.loadLanguages(D, function() {
            var I = document.getElementById(U);
            I && (I.innerHTML = e.highlight(I.textContent, e.languages[D], D));
          });
        }
      }
    });
    var C = RegExp(e.languages.markup.tag.pattern.source, "gi"), T = {
      amp: "&",
      lt: "<",
      gt: ">",
      quot: '"'
    }, O = String.fromCodePoint || String.fromCharCode;
    function S(x) {
      var D = x.replace(C, "");
      return D = D.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(k, H) {
        if (H = H.toLowerCase(), H[0] === "#") {
          var N;
          return H[1] === "x" ? N = parseInt(H.slice(2), 16) : N = Number(H.slice(1)), O(N);
        } else {
          var v = T[H];
          return v || k;
        }
      }), D;
    }
    e.languages.md = e.languages.markdown;
  }(Prism)), Hd;
}
var Wd = {};
var zd;
function ph() {
  return zd || (zd = 1, Prism.languages.c = Prism.languages.extend("clike", {
    comment: {
      pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    string: {
      // https://en.cppreference.com/w/c/language/string_literal
      pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
      lookbehind: true
    },
    keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
  }), Prism.languages.insertBefore("c", "string", {
    char: {
      // https://en.cppreference.com/w/c/language/character_constant
      pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
      greedy: true
    }
  }), Prism.languages.insertBefore("c", "string", {
    macro: {
      // allow for multiline macro definitions
      // spaces after the # character compile fine with gcc
      pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
      lookbehind: true,
      greedy: true,
      alias: "property",
      inside: {
        string: [
          {
            // highlight the path of the include statement as a string
            pattern: /^(#\s*include\s*)<[^>]+>/,
            lookbehind: true
          },
          Prism.languages.c.string
        ],
        char: Prism.languages.c.char,
        comment: Prism.languages.c.comment,
        "macro-name": [
          {
            pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
            lookbehind: true
          },
          {
            pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
            lookbehind: true,
            alias: "function"
          }
        ],
        // highlight macro directives as keywords
        directive: {
          pattern: /^(#\s*)[a-z]+/,
          lookbehind: true,
          alias: "keyword"
        },
        "directive-hash": /^#/,
        punctuation: /##|\\(?=[\r\n])/,
        expression: {
          pattern: /\S[\s\S]*/,
          inside: Prism.languages.c
        }
      }
    }
  }), Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
  }), delete Prism.languages.c.boolean), Wd;
}
var Gd = {};
var Yd;
function _h() {
  return Yd || (Yd = 1, function(e) {
    var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    e.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + t.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      string: {
        pattern: t,
        greedy: true
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      punctuation: /[(){};:,]/
    }, e.languages.css.atrule.inside.rest = e.languages.css;
    var r = e.languages.markup;
    r && (r.tag.addInlined("style", "css"), r.tag.addAttribute("style", "css"));
  }(Prism)), Gd;
}
var jd = {};
var qd;
function mh() {
  return qd || (qd = 1, Prism.languages.objectivec = Prism.languages.extend("c", {
    string: {
      pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
      greedy: true
    },
    keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
  }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec), jd;
}
var Vd = {};
var Jd;
function yh() {
  return Jd || (Jd = 1, Prism.languages.sql = {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
      lookbehind: true
    },
    variable: [
      {
        pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
        greedy: true
      },
      /@[\w.$]+/
    ],
    string: {
      pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
      greedy: true,
      lookbehind: true
    },
    identifier: {
      pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
      greedy: true,
      lookbehind: true,
      inside: {
        punctuation: /^`|`$/
      }
    },
    function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
    number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    punctuation: /[;[\]()`,.]/
  }), Vd;
}
var Zd = {};
var Xd;
function Ch() {
  return Xd || (Xd = 1, Prism.languages.python = {
    comment: {
      pattern: /(^|[^\\])#.*/,
      lookbehind: true,
      greedy: true
    },
    "string-interpolation": {
      pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
      greedy: true,
      inside: {
        interpolation: {
          // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
          pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
          lookbehind: true,
          inside: {
            "format-spec": {
              pattern: /(:)[^:(){}]+(?=\}$)/,
              lookbehind: true
            },
            "conversion-option": {
              pattern: /![sra](?=[:}]$)/,
              alias: "punctuation"
            },
            rest: null
          }
        },
        string: /[\s\S]+/
      }
    },
    "triple-quoted-string": {
      pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
      greedy: true,
      alias: "string"
    },
    string: {
      pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
      greedy: true
    },
    function: {
      pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
      lookbehind: true
    },
    "class-name": {
      pattern: /(\bclass\s+)\w+/i,
      lookbehind: true
    },
    decorator: {
      pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
      lookbehind: true,
      alias: ["annotation", "punctuation"],
      inside: {
        punctuation: /\./
      }
    },
    keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    boolean: /\b(?:False|None|True)\b/,
    number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    punctuation: /[{}[\];(),.:]/
  }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python), Zd;
}
var Qd = {};
var ef;
function Nh() {
  return ef || (ef = 1, function(e) {
    for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, r = 0; r < 2; r++)
      t = t.replace(/<self>/g, function() {
        return t;
      });
    t = t.replace(/<self>/g, function() {
      return /[^\s\S]/.source;
    }), e.languages.rust = {
      comment: [
        {
          pattern: RegExp(/(^|[^\\])/.source + t),
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
        greedy: true
      },
      char: {
        pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
        greedy: true
      },
      attribute: {
        pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
        greedy: true,
        alias: "attr-name",
        inside: {
          string: null
          // see below
        }
      },
      // Closure params should not be confused with bitwise OR |
      "closure-params": {
        pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "closure-punctuation": {
            pattern: /^\||\|$/,
            alias: "punctuation"
          },
          rest: null
          // see below
        }
      },
      "lifetime-annotation": {
        pattern: /'\w+/,
        alias: "symbol"
      },
      "fragment-specifier": {
        pattern: /(\$\w+:)[a-z]+/,
        lookbehind: true,
        alias: "punctuation"
      },
      variable: /\$\w+/,
      "function-definition": {
        pattern: /(\bfn\s+)\w+/,
        lookbehind: true,
        alias: "function"
      },
      "type-definition": {
        pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
        lookbehind: true,
        alias: "class-name"
      },
      "module-declaration": [
        {
          pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
          lookbehind: true,
          alias: "namespace"
        },
        {
          pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
          lookbehind: true,
          alias: "namespace",
          inside: {
            punctuation: /::/
          }
        }
      ],
      keyword: [
        // https://github.com/rust-lang/reference/blob/master/src/keywords.md
        /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
        // primitives and str
        // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
        /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
      ],
      // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
      // and Rust's naming conventions recommend snake_case anyway.
      // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
      function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
      macro: {
        pattern: /\b\w+!/,
        alias: "property"
      },
      constant: /\b[A-Z_][A-Z_\d]+\b/,
      "class-name": /\b[A-Z]\w*\b/,
      namespace: {
        pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
        inside: {
          punctuation: /::/
        }
      },
      // Hex, oct, bin, dec numbers with visual separators and type suffix
      number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
      boolean: /\b(?:false|true)\b/,
      punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
      operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
  }(Prism)), Qd;
}
var tf = {};
var nf;
function Eh() {
  return nf || (nf = 1, Prism.languages.swift = {
    comment: {
      // Nested comments are supported up to 2 levels
      pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
      lookbehind: true,
      greedy: true
    },
    "string-literal": [
      // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
      {
        pattern: RegExp(
          /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\\($/,
            alias: "punctuation"
          },
          punctuation: /\\(?=[\r\n])/,
          string: /[\s\S]+/
        }
      },
      {
        pattern: RegExp(
          /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
            lookbehind: true,
            inside: null
            // see below
          },
          "interpolation-punctuation": {
            pattern: /^\)|\\#+\($/,
            alias: "punctuation"
          },
          string: /[\s\S]+/
        }
      }
    ],
    directive: {
      // directives with conditions
      pattern: RegExp(
        /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
      ),
      alias: "property",
      inside: {
        "directive-name": /^#\w+/,
        boolean: /\b(?:false|true)\b/,
        number: /\b\d+(?:\.\d+)*\b/,
        operator: /!|&&|\|\||[<>]=?/,
        punctuation: /[(),]/
      }
    },
    literal: {
      pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
      alias: "constant"
    },
    "other-directive": {
      pattern: /#\w+\b/,
      alias: "property"
    },
    attribute: {
      pattern: /@\w+/,
      alias: "atrule"
    },
    "function-definition": {
      pattern: /(\bfunc\s+)\w+/,
      lookbehind: true,
      alias: "function"
    },
    label: {
      // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
      pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
      lookbehind: true,
      alias: "important"
    },
    keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    boolean: /\b(?:false|true)\b/,
    nil: {
      pattern: /\bnil\b/,
      alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    omit: {
      pattern: /\b_\b/,
      alias: "keyword"
    },
    number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    function: /\b[a-z_]\w*(?=\s*\()/i,
    constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    punctuation: /[{}[\]();,.:\\]/
  }, Prism.languages.swift["string-literal"].forEach(function(e) {
    e.inside.interpolation.inside = Prism.languages.swift;
  })), tf;
}
var rf = {};
var of;
function Th() {
  return of || (of = 1, function(e) {
    e.languages.typescript = e.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    }), e.languages.typescript.keyword.push(
      /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
      // keywords that have to be followed by an identifier
      /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
      // This is for `import type *, {}`
      /\btype\b(?=\s*(?:[\{*]|$))/
    ), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
    var t = e.languages.extend("typescript", {});
    delete t["class-name"], e.languages.typescript["class-name"].inside = t, e.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        // e.g. foo<T extends "bar" | "baz">( ...
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: true,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            // everything after the first <
            alias: "class-name",
            inside: t
          }
        }
      }
    }), e.languages.ts = e.languages.typescript;
  }(Prism)), rf;
}
var sf = {};
var lf;
function xh() {
  return lf || (lf = 1, function(e) {
    var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, r = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, o = {
      pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
      lookbehind: true,
      inside: {
        namespace: {
          pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /\./
      }
    };
    e.languages.java = e.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
        lookbehind: true,
        greedy: true
      },
      "class-name": [
        o,
        {
          // variables, parameters, and constructor references
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(^|[^\w.])/.source + r + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
          lookbehind: true,
          inside: o.inside
        },
        {
          // class names based on keyword
          // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
          pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + r + /[A-Z]\w*\b/.source),
          lookbehind: true,
          inside: o.inside
        }
      ],
      keyword: t,
      function: [
        e.languages.clike.function,
        {
          pattern: /(::\s*)[a-z_]\w*/,
          lookbehind: true
        }
      ],
      number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
      operator: {
        pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
        lookbehind: true
      },
      constant: /\b[A-Z][A-Z_\d]+\b/
    }), e.languages.insertBefore("java", "string", {
      "triple-quoted-string": {
        // http://openjdk.java.net/jeps/355#Description
        pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
        greedy: true,
        alias: "string"
      },
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
        greedy: true
      }
    }), e.languages.insertBefore("java", "class-name", {
      annotation: {
        pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
        lookbehind: true,
        alias: "punctuation"
      },
      generics: {
        pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
        inside: {
          "class-name": o,
          keyword: t,
          punctuation: /[<>(),.:]/,
          operator: /[?&|]/
        }
      },
      import: [
        {
          pattern: RegExp(/(\bimport\s+)/.source + r + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
          lookbehind: true,
          inside: {
            namespace: o.inside.namespace,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        },
        {
          pattern: RegExp(/(\bimport\s+static\s+)/.source + r + /(?:\w+|\*)(?=\s*;)/.source),
          lookbehind: true,
          alias: "static",
          inside: {
            namespace: o.inside.namespace,
            static: /\b\w+$/,
            punctuation: /\./,
            operator: /\*/,
            "class-name": /\w+/
          }
        }
      ],
      namespace: {
        pattern: RegExp(
          /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
            return t.source;
          })
        ),
        lookbehind: true,
        inside: {
          punctuation: /\./
        }
      }
    });
  }(Prism)), sf;
}
var af = {};
var cf;
function vh() {
  return cf || (cf = 1, function(e) {
    var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, r = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
      return t.source;
    });
    e.languages.cpp = e.languages.extend("c", {
      "class-name": [
        {
          pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
            return t.source;
          })),
          lookbehind: true
        },
        // This is intended to capture the class name of method implementations like:
        //   void foo::bar() const {}
        // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
        // it starts with an uppercase letter. This approximation should give decent results.
        /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
        // This will capture the class name before destructors like:
        //   Foo::~Foo() {}
        /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
        // This also intends to capture the class name of method implementations but here the class has template
        // parameters, so it can't be a namespace (until C++ adds generic namespaces).
        /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
      ],
      keyword: t,
      number: {
        pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
        greedy: true
      },
      operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
      boolean: /\b(?:false|true)\b/
    }), e.languages.insertBefore("cpp", "string", {
      module: {
        // https://en.cppreference.com/w/cpp/language/modules
        pattern: RegExp(
          /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
          /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
          /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
            return r;
          }) + ")"
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          string: /^[<"][\s\S]+/,
          operator: /:/,
          punctuation: /\./
        }
      },
      "raw-string": {
        pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
        alias: "string",
        greedy: true
      }
    }), e.languages.insertBefore("cpp", "keyword", {
      "generic-function": {
        pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
        inside: {
          function: /^\w+/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: e.languages.cpp
          }
        }
      }
    }), e.languages.insertBefore("cpp", "operator", {
      "double-colon": {
        pattern: /::/,
        alias: "punctuation"
      }
    }), e.languages.insertBefore("cpp", "class-name", {
      // the base clause is an optional list of parent classes
      // https://en.cppreference.com/w/cpp/language/class
      "base-clause": {
        pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
        lookbehind: true,
        greedy: true,
        inside: e.languages.extend("cpp", {})
      }
    }), e.languages.insertBefore("inside", "double-colon", {
      // All untokenized words that are not namespaces should be class names
      "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, e.languages.cpp["base-clause"]);
  }(Prism)), af;
}
var Tn = {};
var df;
function U_() {
  if (df)
    return Tn;
  df = 1;
  var e = uh();
  dh(), fh(), hh(), gh(), ph(), _h(), mh(), yh(), Ch(), Nh(), Eh(), Th(), xh(), vh();
  var t = Jt(), r = kt();
  const o = (oe) => oe != null && e.languages.hasOwnProperty(oe) ? oe : void 0;
  function f(oe, ie) {
    for (const ue of oe.childNodes) {
      if (t.isHTMLElement(ue) && ue.tagName === ie)
        return true;
      f(ue, ie);
    }
    return false;
  }
  const h = "data-highlight-language";
  class C extends r.ElementNode {
    /** @internal */
    static getType() {
      return "code";
    }
    static clone(ie) {
      return new C(ie.__language, ie.__key);
    }
    constructor(ie, ue) {
      super(ue), this.__language = o(ie);
    }
    // View
    createDOM(ie) {
      const ue = document.createElement("code");
      t.addClassNamesToElement(ue, ie.theme.code), ue.setAttribute("spellcheck", "false");
      const we = this.getLanguage();
      return we && ue.setAttribute(h, we), ue;
    }
    updateDOM(ie, ue, we) {
      const Le = this.__language, Be = ie.__language;
      return Le ? Le !== Be && ue.setAttribute(h, Le) : Be && ue.removeAttribute(h), false;
    }
    exportDOM() {
      const ie = document.createElement("pre");
      ie.setAttribute("spellcheck", "false");
      const ue = this.getLanguage();
      return ue && ie.setAttribute(h, ue), {
        element: ie
      };
    }
    static importDOM() {
      return {
        // Typically <pre> is used for code blocks, and <code> for inline code styles
        // but if it's a multi line <code> we'll create a block. Pass through to
        // inline format handled by TextNode otherwise.
        code: (ie) => ie.textContent != null && (/\r?\n/.test(ie.textContent) || f(ie, "BR")) ? {
          conversion: S,
          priority: 1
        } : null,
        div: (ie) => ({
          conversion: x,
          priority: 1
        }),
        pre: (ie) => ({
          conversion: S,
          priority: 0
        }),
        table: (ie) => U(ie) ? {
          conversion: D,
          priority: 3
        } : null,
        td: (ie) => {
          const ue = ie, we = ue.closest("table");
          return F(ue) ? {
            conversion: H,
            priority: 3
          } : we && U(we) ? {
            conversion: k,
            priority: 3
          } : null;
        },
        tr: (ie) => {
          const we = ie.closest("table");
          return we && U(we) ? {
            conversion: k,
            priority: 3
          } : null;
        }
      };
    }
    static importJSON(ie) {
      const ue = T(ie.language);
      return ue.setFormat(ie.format), ue.setIndent(ie.indent), ue.setDirection(ie.direction), ue;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        language: this.getLanguage(),
        type: "code",
        version: 1
      };
    }
    // Mutation
    insertNewAfter(ie, ue = true) {
      const we = this.getChildren(), Le = we.length;
      if (Le >= 2 && we[Le - 1].getTextContent() === `
` && we[Le - 2].getTextContent() === `
` && ie.isCollapsed() && ie.anchor.key === this.__key && ie.anchor.offset === Le) {
        we[Le - 1].remove(), we[Le - 2].remove();
        const at = r.$createParagraphNode();
        return this.insertAfter(at, ue), at;
      }
      const {
        anchor: Be,
        focus: Ye
      } = ie, pt = (Be.isBefore(Ye) ? Be : Ye).getNode();
      if (r.$isTextNode(pt)) {
        let at = pe(pt);
        const ve = [];
        for (; ; )
          if (r.$isTabNode(at))
            ve.push(r.$createTabNode()), at = at.getNextSibling();
          else if (me(at)) {
            let Ve = 0;
            const Qe = at.getTextContent(), ct = at.getTextContentSize();
            for (; Ve < ct && Qe[Ve] === " "; Ve++)
              ;
            if (Ve !== 0 && ve.push(q(" ".repeat(Ve))), Ve !== ct)
              break;
            at = at.getNextSibling();
          } else
            break;
        const se = pt.splitText(Be.offset)[0], he = Be.offset === 0 ? 0 : 1, Oe = se.getIndexWithinParent() + he, be = pt.getParentOrThrow(), Re = [r.$createLineBreakNode(), ...ve];
        be.splice(Oe, 0, Re);
        const He = ve[ve.length - 1];
        He ? He.select() : Be.offset === 0 ? se.selectPrevious() : se.getNextSibling().selectNext(0, 0);
      }
      if (O(pt)) {
        const {
          offset: at
        } = ie.anchor;
        pt.splice(at, 0, [r.$createLineBreakNode()]), pt.select(at + 1, at + 1);
      }
      return null;
    }
    canIndent() {
      return false;
    }
    collapseAtStart() {
      const ie = r.$createParagraphNode();
      return this.getChildren().forEach((we) => ie.append(we)), this.replace(ie), true;
    }
    setLanguage(ie) {
      const ue = this.getWritable();
      ue.__language = o(ie);
    }
    getLanguage() {
      return this.getLatest().__language;
    }
  }
  function T(oe) {
    return r.$applyNodeReplacement(new C(oe));
  }
  function O(oe) {
    return oe instanceof C;
  }
  function S(oe) {
    let ie;
    return t.isHTMLElement(oe) && (ie = oe.getAttribute(h)), {
      node: T(ie)
    };
  }
  function x(oe) {
    const ie = oe, ue = N(ie);
    return !ue && !v(ie) ? {
      node: null
    } : {
      after: (we) => {
        const Le = oe.parentNode;
        return Le != null && oe !== Le.lastChild && we.push(r.$createLineBreakNode()), we;
      },
      node: ue ? T() : null
    };
  }
  function D() {
    return {
      node: T()
    };
  }
  function k() {
    return {
      node: null
    };
  }
  function H(oe) {
    const ie = oe;
    return {
      after: (ue) => (ie.parentNode && ie.parentNode.nextSibling && ue.push(r.$createLineBreakNode()), ue),
      node: null
    };
  }
  function N(oe) {
    return oe.style.fontFamily.match("monospace") !== null;
  }
  function v(oe) {
    let ie = oe.parentElement;
    for (; ie !== null; ) {
      if (N(ie))
        return true;
      ie = ie.parentElement;
    }
    return false;
  }
  function F(oe) {
    return oe.classList.contains("js-file-line");
  }
  function U(oe) {
    return oe.classList.contains("js-file-line-container");
  }
  const I = "javascript", K = {
    c: "C",
    clike: "C-like",
    cpp: "C++",
    css: "CSS",
    html: "HTML",
    java: "Java",
    js: "JavaScript",
    markdown: "Markdown",
    objc: "Objective-C",
    plain: "Plain Text",
    py: "Python",
    rust: "Rust",
    sql: "SQL",
    swift: "Swift",
    typescript: "TypeScript",
    xml: "XML"
  }, B = {
    cpp: "cpp",
    java: "java",
    javascript: "js",
    md: "markdown",
    plaintext: "plain",
    python: "py",
    text: "plain",
    ts: "typescript"
  };
  function z(oe) {
    return B[oe] || oe;
  }
  function te(oe) {
    const ie = z(oe);
    return K[ie] || ie;
  }
  const re = () => I, de = () => Object.keys(e.languages).filter(
    // Prism has several language helpers mixed into languages object
    // so filtering them out here to get langs list
    (oe) => typeof e.languages[oe] != "function"
  ).sort();
  class V extends r.TextNode {
    /** @internal */
    constructor(ie, ue, we) {
      super(ie, we), this.__highlightType = ue;
    }
    static getType() {
      return "code-highlight";
    }
    static clone(ie) {
      return new V(ie.__text, ie.__highlightType || void 0, ie.__key);
    }
    getHighlightType() {
      return this.getLatest().__highlightType;
    }
    createDOM(ie) {
      const ue = super.createDOM(ie), we = G(ie.theme, this.__highlightType);
      return t.addClassNamesToElement(ue, we), ue;
    }
    updateDOM(ie, ue, we) {
      const Le = super.updateDOM(ie, ue, we), Be = G(we.theme, ie.__highlightType), Ye = G(we.theme, this.__highlightType);
      return Be !== Ye && (Be && t.removeClassNamesFromElement(ue, Be), Ye && t.addClassNamesToElement(ue, Ye)), Le;
    }
    static importJSON(ie) {
      const ue = q(ie.text, ie.highlightType);
      return ue.setFormat(ie.format), ue.setDetail(ie.detail), ue.setMode(ie.mode), ue.setStyle(ie.style), ue;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        highlightType: this.getHighlightType(),
        type: "code-highlight",
        version: 1
      };
    }
    // Prevent formatting (bold, underline, etc)
    setFormat(ie) {
      return this;
    }
    isParentRequired() {
      return true;
    }
    createParentElementNode() {
      return T();
    }
  }
  function G(oe, ie) {
    return ie && oe && oe.codeHighlight && oe.codeHighlight[ie];
  }
  function q(oe, ie) {
    return r.$applyNodeReplacement(new V(oe, ie));
  }
  function me(oe) {
    return oe instanceof V;
  }
  function pe(oe) {
    let ie = oe, ue = oe;
    for (; me(ue) || r.$isTabNode(ue); )
      ie = ue, ue = ue.getPreviousSibling();
    return ie;
  }
  function Z(oe) {
    let ie = oe, ue = oe;
    for (; me(ue) || r.$isTabNode(ue); )
      ie = ue, ue = ue.getNextSibling();
    return ie;
  }
  const ee = {
    defaultLanguage: I,
    tokenize(oe, ie) {
      return e.tokenize(oe, e.languages[ie || ""] || e.languages[this.defaultLanguage]);
    }
  };
  function P(oe, ie) {
    let ue = null, we = null, Le = oe, Be = ie, Ye = oe.getTextContent();
    for (; ; ) {
      if (Be === 0) {
        if (Le = Le.getPreviousSibling(), Le === null)
          break;
        if (!(me(Le) || r.$isTabNode(Le) || r.$isLineBreakNode(Le)))
          throw Error("Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode");
        if (r.$isLineBreakNode(Le)) {
          ue = {
            node: Le,
            offset: 1
          };
          break;
        }
        Be = Math.max(0, Le.getTextContentSize() - 1), Ye = Le.getTextContent();
      } else
        Be--;
      const pt = Ye[Be];
      me(Le) && pt !== " " && (we = {
        node: Le,
        offset: Be
      });
    }
    if (we !== null)
      return we;
    let st = null;
    if (ie < oe.getTextContentSize())
      me(oe) && (st = oe.getTextContent()[ie]);
    else {
      const pt = oe.getNextSibling();
      me(pt) && (st = pt.getTextContent()[0]);
    }
    if (st !== null && st !== " ")
      return ue;
    {
      const pt = w(oe, ie);
      return pt !== null ? pt : ue;
    }
  }
  function w(oe, ie) {
    let ue = oe, we = ie, Le = oe.getTextContent(), Be = oe.getTextContentSize();
    for (; ; ) {
      if (!me(ue) || we === Be) {
        if (ue = ue.getNextSibling(), ue === null || r.$isLineBreakNode(ue))
          return null;
        me(ue) && (we = 0, Le = ue.getTextContent(), Be = ue.getTextContentSize());
      }
      if (me(ue)) {
        if (Le[we] !== " ")
          return {
            node: ue,
            offset: we
          };
        we++;
      }
    }
  }
  function j(oe) {
    const ie = Z(oe);
    if (r.$isLineBreakNode(ie))
      throw Error("Unexpected lineBreakNode in getEndOfCodeInLine");
    return ie;
  }
  function ne(oe, ie, ue) {
    const we = oe.getParent();
    O(we) ? Q(we, ie, ue) : me(oe) && oe.replace(r.$createTextNode(oe.__text));
  }
  function Y(oe, ie) {
    const ue = ie.getElementByKey(oe.getKey());
    if (ue === null)
      return;
    const we = oe.getChildren(), Le = we.length;
    if (Le === ue.__cachedChildrenLength)
      return;
    ue.__cachedChildrenLength = Le;
    let Be = "1", Ye = 1;
    for (let st = 0; st < Le; st++)
      r.$isLineBreakNode(we[st]) && (Be += `
` + ++Ye);
    ue.setAttribute("data-gutter", Be);
  }
  const W = /* @__PURE__ */ new Set();
  function Q(oe, ie, ue) {
    const we = oe.getKey();
    W.has(we) || (W.add(we), oe.getLanguage() === void 0 && oe.setLanguage(ue.defaultLanguage), ie.update(() => {
      g(we, () => {
        const Le = r.$getNodeByKey(we);
        if (!O(Le) || !Le.isAttached())
          return false;
        const Be = Le.getTextContent(), Ye = ue.tokenize(Be, Le.getLanguage() || ue.defaultLanguage), st = b(Ye), pt = _(Le.getChildren(), st), {
          from: at,
          to: ve,
          nodesForReplacement: se
        } = pt;
        return at !== ve || se.length ? (oe.splice(at, ve - at, se), true) : false;
      });
    }, {
      onUpdate: () => {
        W.delete(we);
      },
      skipTransforms: true
    }));
  }
  function b(oe, ie) {
    const ue = [];
    for (const we of oe)
      if (typeof we == "string") {
        const Le = we.split(/(\n|\t)/), Be = Le.length;
        for (let Ye = 0; Ye < Be; Ye++) {
          const st = Le[Ye];
          st === `
` || st === `\r
` ? ue.push(r.$createLineBreakNode()) : st === "	" ? ue.push(r.$createTabNode()) : st.length > 0 && ue.push(q(st, ie));
        }
      } else {
        const {
          content: Le
        } = we;
        typeof Le == "string" ? ue.push(...b([Le], we.type)) : Array.isArray(Le) && ue.push(...b(Le, we.type));
      }
    return ue;
  }
  function g(oe, ie) {
    const ue = r.$getNodeByKey(oe);
    if (!O(ue) || !ue.isAttached())
      return;
    const we = r.$getSelection();
    if (!r.$isRangeSelection(we)) {
      ie();
      return;
    }
    const Le = we.anchor, Be = Le.offset, Ye = Le.type === "element" && r.$isLineBreakNode(ue.getChildAtIndex(Le.offset - 1));
    let st = 0;
    if (!Ye) {
      const at = Le.getNode();
      st = Be + at.getPreviousSiblings().reduce((ve, se) => ve + se.getTextContentSize(), 0);
    }
    if (ie()) {
      if (Ye) {
        Le.getNode().select(Be, Be);
        return;
      }
      ue.getChildren().some((at) => {
        const ve = r.$isTextNode(at);
        if (ve || r.$isLineBreakNode(at)) {
          const se = at.getTextContentSize();
          if (ve && se >= st)
            return at.select(st, st), true;
          st -= se;
        }
        return false;
      });
    }
  }
  function _(oe, ie) {
    let ue = 0;
    for (; ue < oe.length && A(oe[ue], ie[ue]); )
      ue++;
    const we = oe.length, Le = ie.length, Be = Math.min(we, Le) - ue;
    let Ye = 0;
    for (; Ye < Be; )
      if (Ye++, !A(oe[we - Ye], ie[Le - Ye])) {
        Ye--;
        break;
      }
    const st = ue, pt = we - Ye, at = ie.slice(ue, Le - Ye);
    return {
      from: st,
      nodesForReplacement: at,
      to: pt
    };
  }
  function A(oe, ie) {
    return me(oe) && me(ie) && oe.__text === ie.__text && oe.__highlightType === ie.__highlightType || r.$isTabNode(oe) && r.$isTabNode(ie) || r.$isLineBreakNode(oe) && r.$isLineBreakNode(ie);
  }
  function J(oe) {
    if (!r.$isRangeSelection(oe))
      return false;
    const ie = oe.anchor.getNode(), ue = oe.focus.getNode();
    if (ie.is(ue) && O(ie))
      return true;
    const we = ie.getParent();
    return O(we) && we.is(ue.getParent());
  }
  function ce(oe) {
    const ie = oe.getNodes(), ue = [[]];
    if (ie.length === 1 && O(ie[0]))
      return ue;
    let we = ue[0];
    for (let Le = 0; Le < ie.length; Le++) {
      const Be = ie[Le];
      if (!(me(Be) || r.$isTabNode(Be) || r.$isLineBreakNode(Be)))
        throw Error("Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode");
      r.$isLineBreakNode(Be) ? Le !== 0 && we.length > 0 && (we = [], ue.push(we)) : we.push(Be);
    }
    return ue;
  }
  function ge(oe) {
    const ie = r.$getSelection();
    if (!r.$isRangeSelection(ie) || !J(ie))
      return null;
    const ue = oe ? r.OUTDENT_CONTENT_COMMAND : r.INDENT_CONTENT_COMMAND, we = oe ? r.OUTDENT_CONTENT_COMMAND : r.INSERT_TAB_COMMAND;
    if (ce(ie).length > 1)
      return ue;
    const Ye = ie.getNodes()[0];
    if (!(O(Ye) || me(Ye) || r.$isTabNode(Ye) || r.$isLineBreakNode(Ye)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or TabNode");
    if (O(Ye))
      return ue;
    const st = pe(Ye), pt = Z(Ye), at = ie.anchor, ve = ie.focus;
    let se, he;
    return ve.isBefore(at) ? (se = ve, he = at) : (se = at, he = ve), st !== null && pt !== null && se.key === st.getKey() && se.offset === 0 && he.key === pt.getKey() && he.offset === pt.getTextContentSize() ? ue : we;
  }
  function ae(oe) {
    const ie = r.$getSelection();
    if (!r.$isRangeSelection(ie) || !J(ie))
      return false;
    const ue = ce(ie), we = ue.length;
    if (ue.length > 1) {
      for (let st = 0; st < we; st++) {
        const pt = ue[st];
        if (pt.length > 0) {
          let at = pt[0];
          st === 0 && (at = pe(at)), at !== null && (oe === r.INDENT_CONTENT_COMMAND ? at.insertBefore(r.$createTabNode()) : r.$isTabNode(at) && at.remove());
        }
      }
      return true;
    }
    const Be = ie.getNodes()[0];
    if (!(O(Be) || me(Be) || r.$isTabNode(Be) || r.$isLineBreakNode(Be)))
      throw Error("Expected selection firstNode to be CodeHighlightNode or CodeTabNode");
    if (O(Be))
      return oe === r.INDENT_CONTENT_COMMAND && ie.insertNodes([r.$createTabNode()]), true;
    const Ye = pe(Be);
    if (Ye === null)
      throw Error("Expected getFirstCodeNodeOfLine to return a valid Code Node");
    return oe === r.INDENT_CONTENT_COMMAND ? r.$isLineBreakNode(Ye) ? Ye.insertAfter(r.$createTabNode()) : Ye.insertBefore(r.$createTabNode()) : r.$isTabNode(Ye) && Ye.remove(), true;
  }
  function Te(oe, ie) {
    const ue = r.$getSelection();
    if (!r.$isRangeSelection(ue))
      return false;
    const {
      anchor: we,
      focus: Le
    } = ue, Be = we.offset, Ye = Le.offset, st = we.getNode(), pt = Le.getNode(), at = oe === r.KEY_ARROW_UP_COMMAND;
    if (!J(ue) || !(me(st) || r.$isTabNode(st)) || !(me(pt) || r.$isTabNode(pt)))
      return false;
    if (!ie.altKey) {
      if (ue.isCollapsed()) {
        const Ve = st.getParentOrThrow();
        if (at && Be === 0 && st.getPreviousSibling() === null) {
          if (Ve.getPreviousSibling() === null)
            return Ve.selectPrevious(), ie.preventDefault(), true;
        } else if (!at && Be === st.getTextContentSize() && st.getNextSibling() === null && Ve.getNextSibling() === null)
          return Ve.selectNext(), ie.preventDefault(), true;
      }
      return false;
    }
    let ve, se;
    if (st.isBefore(pt) ? (ve = pe(st), se = Z(pt)) : (ve = pe(pt), se = Z(st)), ve == null || se == null)
      return false;
    const he = ve.getNodesBetween(se);
    for (let Ve = 0; Ve < he.length; Ve++) {
      const Qe = he[Ve];
      if (!me(Qe) && !r.$isTabNode(Qe) && !r.$isLineBreakNode(Qe))
        return false;
    }
    ie.preventDefault(), ie.stopPropagation();
    const Oe = at ? ve.getPreviousSibling() : se.getNextSibling();
    if (!r.$isLineBreakNode(Oe))
      return true;
    const be = at ? Oe.getPreviousSibling() : Oe.getNextSibling();
    if (be == null)
      return true;
    const Re = me(be) || r.$isTabNode(be) || r.$isLineBreakNode(be) ? at ? pe(be) : Z(be) : null;
    let He = Re ?? be;
    return Oe.remove(), he.forEach((Ve) => Ve.remove()), oe === r.KEY_ARROW_UP_COMMAND ? (he.forEach((Ve) => He.insertBefore(Ve)), He.insertBefore(Oe)) : (He.insertAfter(Oe), He = Oe, he.forEach((Ve) => {
      He.insertAfter(Ve), He = Ve;
    })), ue.setTextNodeRange(st, Be, pt, Ye), true;
  }
  function Me(oe, ie) {
    const ue = r.$getSelection();
    if (!r.$isRangeSelection(ue))
      return false;
    const {
      anchor: we,
      focus: Le
    } = ue, Be = we.getNode(), Ye = Le.getNode(), st = oe === r.MOVE_TO_START;
    if (!(me(Be) || r.$isTabNode(Be)) || !(me(Ye) || r.$isTabNode(Ye)))
      return false;
    if (st) {
      const pt = P(Ye, Le.offset);
      if (pt !== null) {
        const {
          node: at,
          offset: ve
        } = pt;
        r.$isLineBreakNode(at) ? at.selectNext(0, 0) : ue.setTextNodeRange(at, ve, at, ve);
      } else
        Ye.getParentOrThrow().selectStart();
    } else
      j(Ye).select();
    return ie.preventDefault(), ie.stopPropagation(), true;
  }
  function ze(oe, ie) {
    if (!oe.hasNodes([C, V]))
      throw new Error("CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor");
    return ie == null && (ie = ee), t.mergeRegister(oe.registerMutationListener(C, (ue) => {
      oe.update(() => {
        for (const [we, Le] of ue)
          if (Le !== "destroyed") {
            const Be = r.$getNodeByKey(we);
            Be !== null && Y(Be, oe);
          }
      });
    }), oe.registerNodeTransform(C, (ue) => Q(ue, oe, ie)), oe.registerNodeTransform(r.TextNode, (ue) => ne(ue, oe, ie)), oe.registerNodeTransform(V, (ue) => ne(ue, oe, ie)), oe.registerCommand(r.KEY_TAB_COMMAND, (ue) => {
      const we = ge(ue.shiftKey);
      return we === null ? false : (ue.preventDefault(), oe.dispatchCommand(we, void 0), true);
    }, r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.INSERT_TAB_COMMAND, () => {
      const ue = r.$getSelection();
      return J(ue) ? (r.$insertNodes([r.$createTabNode()]), true) : false;
    }, r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.INDENT_CONTENT_COMMAND, (ue) => ae(r.INDENT_CONTENT_COMMAND), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.OUTDENT_CONTENT_COMMAND, (ue) => ae(r.OUTDENT_CONTENT_COMMAND), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.KEY_ARROW_UP_COMMAND, (ue) => Te(r.KEY_ARROW_UP_COMMAND, ue), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.KEY_ARROW_DOWN_COMMAND, (ue) => Te(r.KEY_ARROW_DOWN_COMMAND, ue), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.MOVE_TO_END, (ue) => Me(r.MOVE_TO_END, ue), r.COMMAND_PRIORITY_LOW), oe.registerCommand(r.MOVE_TO_START, (ue) => Me(r.MOVE_TO_START, ue), r.COMMAND_PRIORITY_LOW));
  }
  return Tn.$createCodeHighlightNode = q, Tn.$createCodeNode = T, Tn.$isCodeHighlightNode = me, Tn.$isCodeNode = O, Tn.CODE_LANGUAGE_FRIENDLY_NAME_MAP = K, Tn.CODE_LANGUAGE_MAP = B, Tn.CodeHighlightNode = V, Tn.CodeNode = C, Tn.DEFAULT_CODE_LANGUAGE = I, Tn.PrismTokenizer = ee, Tn.getCodeLanguages = de, Tn.getDefaultCodeLanguage = re, Tn.getEndOfCodeInLine = j, Tn.getFirstCodeNodeOfLine = pe, Tn.getLanguageFriendlyName = te, Tn.getLastCodeNodeOfLine = Z, Tn.getStartOfCodeInLine = P, Tn.normalizeCodeLang = z, Tn.registerCodeHighlighting = ze, Tn;
}
var W_ = true ? U_() : H_();
var vc = W_;
var Hc = kn();
function z_() {
  const [e] = Hc.useLexicalComposerContext();
  return (0, import_react.useEffect)(() => vc.registerCodeHighlighting(e), [e]), null;
}
var ff = Jt();
var vn = kt();
function G_({
  src: e,
  altText: t,
  width: r,
  height: o,
  maxWidth: f
}) {
  const h = (0, import_react.useMemo)(() => ({ height: o, width: r, maxWidth: f }), [o, r, f]);
  return yt.jsx("img", { src: e, alt: t, style: h });
}
function Sh({
  altText: e,
  height: t,
  maxWidth: r = 500,
  src: o,
  width: f,
  key: h
}) {
  return vn.$applyNodeReplacement(
    new Ts(o, e, r, f, t, h)
  );
}
function Y_(e) {
  return e instanceof Ts;
}
var Ts = class _Ts extends vn.DecoratorNode {
  constructor(r, o, f, h, C, T) {
    super(T);
    Ln(this, "__src");
    Ln(this, "__altText");
    Ln(this, "__width");
    Ln(this, "__height");
    Ln(this, "__maxWidth");
    this.__src = r, this.__altText = o, this.__maxWidth = f, this.__width = h || "inherit", this.__height = C || "inherit";
  }
  static getType() {
    return "image";
  }
  static clone(r) {
    return new _Ts(
      r.__src,
      r.__altText,
      r.__maxWidth,
      r.__width,
      r.__height,
      r.__key
    );
  }
  getSrc() {
    return this.getLatest().__src;
  }
  getAltText() {
    return this.getLatest().__altText;
  }
  /**
   * Defines the JSON Serialization strategy for an {@link ImageNode}.
   */
  exportJSON() {
    return {
      altText: this.getAltText(),
      height: this.__height === "inherit" ? 0 : this.__height,
      maxWidth: this.__maxWidth,
      src: this.getSrc(),
      type: "image",
      version: 1,
      width: this.__width === "inherit" ? 0 : this.__width
    };
  }
  /**
   * Static constructor for creating an {@link ImageNode} from a JSON serialized Node.
   */
  static importJSON(r) {
    return Sh(r);
  }
  /**
   * Inserts the {@link ImageNode}'s placeholder {@link HTMLElement} into the Lexical Dev's DOM.
   */
  createDOM(r) {
    const o = document.createElement("span"), f = r.theme.image;
    return f && (o.className = f), o;
  }
  /**
   * Since this Node will only be used in a read-only context, we don't need to worry about
   * updating the DOM when its attributes change.
   */
  updateDOM() {
    return false;
  }
  decorate() {
    return yt.jsx(
      G_,
      {
        src: this.__src,
        altText: this.__altText,
        width: this.__width,
        height: this.__height,
        maxWidth: this.__maxWidth
      }
    );
  }
};
var j_ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
var q_ = (e) => j_ ? (e || window).getSelection() : null;
var wh = vn.createCommand(
  "INSERT_IMAGE_COMMAND"
);
function V_() {
  const [e] = Hc.useLexicalComposerContext();
  return (0, import_react.useEffect)(() => {
    if (!e.hasNodes([Ts]))
      throw new Error("ImagePlugin: ImageNode not registered on editor");
    return ff.mergeRegister(
      e.registerCommand(
        wh,
        (t) => {
          const r = Sh(t);
          return vn.$insertNodes([r]), vn.$isRootOrShadowRoot(r.getParentOrThrow()) && ff.$wrapNodeInElement(r, vn.$createParagraphNode).selectEnd(), true;
        },
        vn.COMMAND_PRIORITY_EDITOR
      ),
      e.registerCommand(
        vn.DRAGSTART_COMMAND,
        (t) => J_(t),
        vn.COMMAND_PRIORITY_HIGH
      ),
      e.registerCommand(
        vn.DRAGOVER_COMMAND,
        (t) => Z_(t),
        vn.COMMAND_PRIORITY_LOW
      ),
      e.registerCommand(
        vn.DROP_COMMAND,
        (t) => X_(t, e),
        vn.COMMAND_PRIORITY_HIGH
      )
    );
  }, [e]), null;
}
function J_(e) {
  const t = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7", r = document.createElement("img");
  r.src = t;
  const o = Uc();
  if (!o)
    return false;
  const f = e.dataTransfer;
  return f ? (f.setData("text/plain", "_"), f.setDragImage(r, 0, 0), f.setData(
    "application/x-lexical-drag",
    JSON.stringify({
      data: {
        altText: o.__altText,
        height: o.__height,
        key: o.getKey(),
        maxWidth: o.__maxWidth,
        src: o.__src,
        width: o.__width
      },
      type: "image"
    })
  ), true) : false;
}
function Z_(e) {
  return Uc() ? (Oh(e) || e.preventDefault(), true) : false;
}
function X_(e, t) {
  const r = Uc();
  if (!r)
    return false;
  const o = Q_(e);
  if (!o)
    return false;
  if (e.preventDefault(), Oh(e)) {
    const f = em(e);
    r.remove();
    const h = vn.$createRangeSelection();
    f != null && h.applyDOMRange(f), vn.$setSelection(h), t.dispatchCommand(wh, o);
  }
  return true;
}
function Uc() {
  const e = vn.$getSelection();
  if (!vn.$isNodeSelection(e))
    return null;
  const r = e.getNodes()[0];
  return Y_(r) ? r : null;
}
function Q_(e) {
  var f;
  const t = (f = e.dataTransfer) == null ? void 0 : f.getData("application/x-lexical-drag");
  if (!t)
    return null;
  const { type: r, data: o } = JSON.parse(t);
  return r !== "image" ? null : o;
}
function Oh(e) {
  const t = e.target;
  return !!(t && t instanceof HTMLElement && !t.closest("code, span.yext-default-richtextv2-theme__image") && t.parentElement);
}
function em(e) {
  let t;
  const r = e.target, o = r === null || !(r instanceof Node) ? null : r.nodeType === 9 ? r.defaultView : r.ownerDocument.defaultView, f = q_(o);
  if (document.caretRangeFromPoint)
    t = document.caretRangeFromPoint(e.clientX, e.clientY);
  else if (e.rangeParent && f !== null)
    f.collapse(e.rangeParent, e.rangeOffset || 0), t = f.getRangeAt(0);
  else
    throw Error("Cannot get the selection when dragging");
  return t;
}
var Io = Fc();
function tm(e) {
  const t = e.getNodes();
  return t.length === 0 ? /* @__PURE__ */ new Set([
    e.anchor.getNode().getParentOrThrow(),
    e.focus.getNode().getParentOrThrow()
  ]) : new Set(
    t.map((r) => vn.$isElementNode(r) ? r : r.getParentOrThrow())
  );
}
var nm = 3;
function rm(e) {
  const t = vn.$getSelection();
  if (!vn.$isRangeSelection(t))
    return false;
  const r = tm(t);
  let o = 0;
  for (const f of r)
    if (Io.$isListNode(f))
      o = Math.max(Io.$getListDepth(f) + 1, o);
    else if (Io.$isListItemNode(f)) {
      const h = f.getParent();
      if (!Io.$isListNode(h))
        throw new Error(
          "ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent."
        );
      o = Math.max(Io.$getListDepth(h) + 1, o);
    }
  return o <= e;
}
function im({ maxDepth: e }) {
  const [t] = Hc.useLexicalComposerContext();
  return (0, import_react.useEffect)(() => t.registerCommand(
    vn.INDENT_CONTENT_COMMAND,
    () => !rm(e || 7),
    nm
  ), [t, e]), null;
}
var hc = Kc();
var hf = Bc();
var gf = $c();
var nl = {};
var _f;
function sm() {
  if (_f)
    return nl;
  _f = 1;
  var e = Jt(), t = kt();
  class r extends t.TextNode {
    static getType() {
      return "hashtag";
    }
    static clone(C) {
      return new r(C.__text, C.__key);
    }
    constructor(C, T) {
      super(C, T);
    }
    createDOM(C) {
      const T = super.createDOM(C);
      return e.addClassNamesToElement(T, C.theme.hashtag), T;
    }
    static importJSON(C) {
      const T = o(C.text);
      return T.setFormat(C.format), T.setDetail(C.detail), T.setMode(C.mode), T.setStyle(C.style), T;
    }
    exportJSON() {
      return {
        ...super.exportJSON(),
        type: "hashtag"
      };
    }
    canInsertTextBefore() {
      return false;
    }
    isTextEntity() {
      return true;
    }
  }
  function o(h = "") {
    return t.$applyNodeReplacement(new r(h));
  }
  function f(h) {
    return h instanceof r;
  }
  return nl.$createHashtagNode = o, nl.$isHashtagNode = f, nl.HashtagNode = r, nl;
}
var lm = true ? sm() : om();
var am = lm;
var cm = "_rtl_13v3w_295";
var um = "_selected_13v3w_370";
var ot = {
  "yext-default-richtextv2-theme__ul1": "_yext-default-richtextv2-theme__ul1_13v3w_17",
  "yext-default-richtextv2-theme__ul2": "_yext-default-richtextv2-theme__ul2_13v3w_25",
  "yext-default-richtextv2-theme__ul3": "_yext-default-richtextv2-theme__ul3_13v3w_33",
  "yext-default-richtextv2-theme__ltr": "_yext-default-richtextv2-theme__ltr_13v3w_55",
  "yext-default-richtextv2-theme__rtl": "_yext-default-richtextv2-theme__rtl_13v3w_58",
  "yext-default-richtextv2-theme__paragraph": "_yext-default-richtextv2-theme__paragraph_13v3w_61",
  "yext-default-richtextv2-theme__quote": "_yext-default-richtextv2-theme__quote_13v3w_70",
  "yext-default-richtextv2-theme__h1": "_yext-default-richtextv2-theme__h1_13v3w_81",
  "yext-default-richtextv2-theme__h2": "_yext-default-richtextv2-theme__h2_13v3w_89",
  "yext-default-richtextv2-theme__h3": "_yext-default-richtextv2-theme__h3_13v3w_97",
  "yext-default-richtextv2-theme__h4": "_yext-default-richtextv2-theme__h4_13v3w_105",
  "yext-default-richtextv2-theme__h5": "_yext-default-richtextv2-theme__h5_13v3w_113",
  "yext-default-richtextv2-theme__h6": "_yext-default-richtextv2-theme__h6_13v3w_121",
  "yext-default-richtextv2-theme__textBold": "_yext-default-richtextv2-theme__textBold_13v3w_130",
  "yext-default-richtextv2-theme__textItalic": "_yext-default-richtextv2-theme__textItalic_13v3w_133",
  "yext-default-richtextv2-theme__textUnderline": "_yext-default-richtextv2-theme__textUnderline_13v3w_136",
  "yext-default-richtextv2-theme__textStrikethrough": "_yext-default-richtextv2-theme__textStrikethrough_13v3w_139",
  "yext-default-richtextv2-theme__textUnderlineStrikethrough": "_yext-default-richtextv2-theme__textUnderlineStrikethrough_13v3w_142",
  "yext-default-richtextv2-theme__textSubscript": "_yext-default-richtextv2-theme__textSubscript_13v3w_145",
  "yext-default-richtextv2-theme__textSuperscript": "_yext-default-richtextv2-theme__textSuperscript_13v3w_149",
  "yext-default-richtextv2-theme__textCode": "_yext-default-richtextv2-theme__textCode_13v3w_153",
  "yext-default-richtextv2-theme__hashtag": "_yext-default-richtextv2-theme__hashtag_13v3w_159",
  "yext-default-richtextv2-theme__link": "_yext-default-richtextv2-theme__link_13v3w_163",
  "yext-default-richtextv2-theme__code": "_yext-default-richtextv2-theme__code_13v3w_171",
  "yext-default-richtextv2-theme__table": "_yext-default-richtextv2-theme__table_13v3w_199",
  "yext-default-richtextv2-theme__tableCell": "_yext-default-richtextv2-theme__tableCell_13v3w_208",
  "yext-default-richtextv2-theme__tableCellHeader": "_yext-default-richtextv2-theme__tableCellHeader_13v3w_218",
  "yext-default-richtextv2-theme__characterLimit": "_yext-default-richtextv2-theme__characterLimit_13v3w_222",
  "yext-default-richtextv2-theme__ol1": "_yext-default-richtextv2-theme__ol1_13v3w_226",
  "yext-default-richtextv2-theme__ol2": "_yext-default-richtextv2-theme__ol2_13v3w_233",
  "yext-default-richtextv2-theme__ol3": "_yext-default-richtextv2-theme__ol3_13v3w_240",
  "yext-default-richtextv2-theme__ol4": "_yext-default-richtextv2-theme__ol4_13v3w_247",
  "yext-default-richtextv2-theme__ol5": "_yext-default-richtextv2-theme__ol5_13v3w_254",
  "yext-default-richtextv2-theme__ul": "_yext-default-richtextv2-theme__ul_13v3w_17",
  "yext-default-richtextv2-theme__listItem": "_yext-default-richtextv2-theme__listItem_13v3w_267",
  "yext-default-richtextv2-theme__listItemChecked": "_yext-default-richtextv2-theme__listItemChecked_13v3w_270",
  "yext-default-richtextv2-theme__listItemUnchecked": "_yext-default-richtextv2-theme__listItemUnchecked_13v3w_271",
  rtl: cm,
  "yext-default-richtextv2-theme__nestedListItem": "_yext-default-richtextv2-theme__nestedListItem_13v3w_330",
  "yext-default-richtextv2-theme__tokenComment": "_yext-default-richtextv2-theme__tokenComment_13v3w_337",
  "yext-default-richtextv2-theme__tokenPunctuation": "_yext-default-richtextv2-theme__tokenPunctuation_13v3w_340",
  "yext-default-richtextv2-theme__tokenProperty": "_yext-default-richtextv2-theme__tokenProperty_13v3w_343",
  "yext-default-richtextv2-theme__tokenSelector": "_yext-default-richtextv2-theme__tokenSelector_13v3w_346",
  "yext-default-richtextv2-theme__tokenOperator": "_yext-default-richtextv2-theme__tokenOperator_13v3w_349",
  "yext-default-richtextv2-theme__tokenAttr": "_yext-default-richtextv2-theme__tokenAttr_13v3w_352",
  "yext-default-richtextv2-theme__tokenVariable": "_yext-default-richtextv2-theme__tokenVariable_13v3w_355",
  "yext-default-richtextv2-theme__tokenFunction": "_yext-default-richtextv2-theme__tokenFunction_13v3w_358",
  "yext-default-richtextv2-theme__mark": "_yext-default-richtextv2-theme__mark_13v3w_361",
  "yext-default-richtextv2-theme__markOverlap": "_yext-default-richtextv2-theme__markOverlap_13v3w_366",
  selected: um,
  "yext-default-richtextv2-theme__embedBlock": "_yext-default-richtextv2-theme__embedBlock_13v3w_378",
  "yext-default-richtextv2-theme__embedBlockFocus": "_yext-default-richtextv2-theme__embedBlockFocus_13v3w_381",
  "yext-default-richtextv2-theme__image": "_yext-default-richtextv2-theme__image_13v3w_385"
};
var dm = {
  characterLimit: ot["yext-default-richtextv2-theme__characterLimit"],
  code: ot["yext-default-richtextv2-theme__code"],
  codeHighlight: {
    atrule: ot["yext-default-richtextv2-theme__tokenAttr"],
    attr: ot["yext-default-richtextv2-theme__tokenAttr"],
    boolean: ot["yext-default-richtextv2-theme__tokenProperty"],
    builtin: ot["yext-default-richtextv2-theme__tokenSelector"],
    cdata: ot["yext-default-richtextv2-theme__tokenComment"],
    char: ot["yext-default-richtextv2-theme__tokenSelector"],
    class: ot["yext-default-richtextv2-theme__tokenFunction"],
    "class-name": ot["yext-default-richtextv2-theme__tokenFunction"],
    comment: ot["yext-default-richtextv2-theme__tokenComment"],
    constant: ot["yext-default-richtextv2-theme__tokenProperty"],
    deleted: ot["yext-default-richtextv2-theme__tokenProperty"],
    doctype: ot["yext-default-richtextv2-theme__tokenComment"],
    entity: ot["yext-default-richtextv2-theme__tokenOperator"],
    function: ot["yext-default-richtextv2-theme__tokenFunction"],
    important: ot["yext-default-richtextv2-theme__tokenVariable"],
    inserted: ot["yext-default-richtextv2-theme__tokenSelector"],
    keyword: ot["yext-default-richtextv2-theme__tokenAttr"],
    namespace: ot["yext-default-richtextv2-theme__tokenVariable"],
    number: ot["yext-default-richtextv2-theme__tokenProperty"],
    operator: ot["yext-default-richtextv2-theme__tokenOperator"],
    prolog: ot["yext-default-richtextv2-theme__tokenComment"],
    property: ot["yext-default-richtextv2-theme__tokenProperty"],
    punctuation: ot["yext-default-richtextv2-theme__tokenPunctuation"],
    regex: ot["yext-default-richtextv2-theme__tokenVariable"],
    selector: ot["yext-default-richtextv2-theme__tokenSelector"],
    string: ot["yext-default-richtextv2-theme__tokenSelector"],
    symbol: ot["yext-default-richtextv2-theme__tokenProperty"],
    tag: ot["yext-default-richtextv2-theme__tokenProperty"],
    url: ot["yext-default-richtextv2-theme__tokenOperator"],
    variable: ot["yext-default-richtextv2-theme__tokenVariable"]
  },
  embedBlock: {
    base: ot["yext-default-richtextv2-theme__embedBlock"],
    focus: ot["yext-default-richtextv2-theme__embedBlockFocus"]
  },
  hashtag: ot["yext-default-richtextv2-theme__hashtag"],
  heading: {
    h1: ot["yext-default-richtextv2-theme__h1"],
    h2: ot["yext-default-richtextv2-theme__h2"],
    h3: ot["yext-default-richtextv2-theme__h3"],
    h4: ot["yext-default-richtextv2-theme__h4"],
    h5: ot["yext-default-richtextv2-theme__h5"],
    h6: ot["yext-default-richtextv2-theme__h6"]
  },
  image: ot["yext-default-richtextv2-theme__image"],
  link: ot["yext-default-richtextv2-theme__link"],
  list: {
    listitem: ot["yext-default-richtextv2-theme__listItem"],
    listitemChecked: ot["yext-default-richtextv2-theme__listItemChecked"],
    listitemUnchecked: ot["yext-default-richtextv2-theme__listItemUnchecked"],
    nested: {
      listitem: ot["yext-default-richtextv2-theme__nestedListItem"]
    },
    olDepth: [
      ot["yext-default-richtextv2-theme__ol1"],
      ot["yext-default-richtextv2-theme__ol2"],
      ot["yext-default-richtextv2-theme__ol3"],
      ot["yext-default-richtextv2-theme__ol4"],
      ot["yext-default-richtextv2-theme__ol5"]
    ],
    ulDepth: [
      ot["yext-default-richtextv2-theme__ul1"],
      ot["yext-default-richtextv2-theme__ul2"],
      ot["yext-default-richtextv2-theme__ul3"]
    ]
  },
  ltr: ot["yext-default-richtextv2-theme__ltr"],
  mark: ot["yext-default-richtextv2-theme__mark"],
  markOverlap: ot["yext-default-richtextv2-theme__markOverlap"],
  paragraph: ot["yext-default-richtextv2-theme__paragraph"],
  quote: ot["yext-default-richtextv2-theme__quote"],
  rtl: ot["yext-default-richtextv2-theme__rtl"],
  table: ot["yext-default-richtextv2-theme__table"],
  tableCell: ot["yext-default-richtextv2-theme__tableCell"],
  tableCellHeader: ot["yext-default-richtextv2-theme__tableCellHeader"],
  text: {
    bold: ot["yext-default-richtextv2-theme__textBold"],
    code: ot["yext-default-richtextv2-theme__textCode"],
    italic: ot["yext-default-richtextv2-theme__textItalic"],
    strikethrough: ot["yext-default-richtextv2-theme__textStrikethrough"],
    subscript: ot["yext-default-richtextv2-theme__textSubscript"],
    superscript: ot["yext-default-richtextv2-theme__textSuperscript"],
    underline: ot["yext-default-richtextv2-theme__textUnderline"],
    underlineStrikethrough: ot["yext-default-richtextv2-theme__textUnderlineStrikethrough"]
  }
};
var fm = dm;
var pc = {};
var yf;
function gm() {
  if (yf)
    return pc;
  yf = 1;
  var e = kn(), t = kt(), r = import_react.default;
  function o(h, C) {
    return h.getEditorState().read(() => {
      const T = t.$getNodeByKey(C);
      return T === null ? false : T.isSelected();
    });
  }
  function f(h) {
    const [C] = e.useLexicalComposerContext(), [T, O] = r.useState(() => o(C, h));
    r.useEffect(() => {
      let D = true;
      const k = C.registerUpdateListener(() => {
        D && O(o(C, h));
      });
      return () => {
        D = false, k();
      };
    }, [C, h]);
    const S = r.useCallback((D) => {
      C.update(() => {
        let k = t.$getSelection();
        t.$isNodeSelection(k) || (k = t.$createNodeSelection(), t.$setSelection(k)), t.$isNodeSelection(k) && (D ? k.add(h) : k.delete(h));
      });
    }, [C, h]), x = r.useCallback(() => {
      C.update(() => {
        const D = t.$getSelection();
        t.$isNodeSelection(D) && D.clear();
      });
    }, [C]);
    return [T, S, x];
  }
  return pc.useLexicalNodeSelection = f, pc;
}
var _c;
var Cf;
function Rh() {
  return Cf || (Cf = 1, _c = true ? gm() : hm()), _c;
}
var ms = {};
var Ef;
function _m() {
  if (Ef)
    return ms;
  Ef = 1;
  var e = kn(), t = Rh(), r = Jt(), o = kt(), f = import_react.default;
  const h = o.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
  function C({
    nodeKey: D
  }) {
    const [k] = e.useLexicalComposerContext(), [H, N, v] = t.useLexicalNodeSelection(D), F = f.useCallback((U) => {
      if (H && o.$isNodeSelection(o.$getSelection())) {
        U.preventDefault();
        const I = o.$getNodeByKey(D);
        x(I) && I.remove();
      }
      return false;
    }, [H, D]);
    return f.useEffect(() => r.mergeRegister(k.registerCommand(o.CLICK_COMMAND, (U) => {
      const I = k.getElementByKey(D);
      return U.target === I ? (U.shiftKey || v(), N(!H), true) : false;
    }, o.COMMAND_PRIORITY_LOW), k.registerCommand(o.KEY_DELETE_COMMAND, F, o.COMMAND_PRIORITY_LOW), k.registerCommand(o.KEY_BACKSPACE_COMMAND, F, o.COMMAND_PRIORITY_LOW)), [v, k, H, D, F, N]), f.useEffect(() => {
      const U = k.getElementByKey(D);
      U !== null && (U.className = H ? "selected" : "");
    }, [k, H, D]), null;
  }
  class T extends o.DecoratorNode {
    static getType() {
      return "horizontalrule";
    }
    static clone(k) {
      return new T(k.__key);
    }
    static importJSON(k) {
      return S();
    }
    static importDOM() {
      return {
        hr: () => ({
          conversion: O,
          priority: 0
        })
      };
    }
    exportJSON() {
      return {
        type: "horizontalrule",
        version: 1
      };
    }
    exportDOM() {
      return {
        element: document.createElement("hr")
      };
    }
    createDOM() {
      return document.createElement("hr");
    }
    getTextContent() {
      return `
`;
    }
    isInline() {
      return false;
    }
    updateDOM() {
      return false;
    }
    decorate() {
      return f.createElement(C, {
        nodeKey: this.__key
      });
    }
  }
  function O() {
    return {
      node: S()
    };
  }
  function S() {
    return o.$applyNodeReplacement(new T());
  }
  function x(D) {
    return D instanceof T;
  }
  return ms.$createHorizontalRuleNode = S, ms.$isHorizontalRuleNode = x, ms.HorizontalRuleNode = T, ms.INSERT_HORIZONTAL_RULE_COMMAND = h, ms;
}
var mm = true ? _m() : pm();
var ym = mm;
function Cm(e, t) {
  return {
    namespace: "",
    editable: false,
    onError: (r) => {
      throw r;
    },
    editorState: e,
    theme: t ?? fm,
    nodes: [
      gf.HeadingNode,
      am.HashtagNode,
      Ts,
      Io.ListNode,
      Io.ListItemNode,
      gf.QuoteNode,
      vc.CodeNode,
      vc.CodeHighlightNode,
      hc.TableNode,
      hc.TableCellNode,
      hc.TableRowNode,
      hf.AutoLinkNode,
      hf.LinkNode,
      ym.HorizontalRuleNode
    ]
  };
}
var mc = {
  "editor-inner": "_editor-inner_1mmqo_6",
  "no-border": "_no-border_1mmqo_10"
};
function JC({
  serializedAST: e,
  nodeClassNames: t
}) {
  return yt.jsx(
    jp.LexicalComposer,
    {
      initialConfig: Cm(e, t),
      children: yt.jsx("div", { className: `${mc["editor-inner"]} ${mc["no-border"]}`, children: yt.jsxs("div", { className: mc["editor-inner"], children: [
        yt.jsx(
          h_.RichTextPlugin,
          {
            contentEditable: yt.jsx(
              m_.ContentEditable,
              {
                className: "editor-input",
                ariaLabel: "Lexical Rich Text"
              }
            ),
            ErrorBoundary: T_,
            placeholder: yt.jsx("div", {})
          }
        ),
        yt.jsx(z_, {}),
        yt.jsx(R_.ListPlugin, {}),
        yt.jsx(P_.LinkPlugin, {}),
        yt.jsx(K_.TablePlugin, {}),
        yt.jsx(V_, {}),
        yt.jsx(im, { maxDepth: 7 })
      ] }) })
    }
  );
}
function Wc(e, t, r, o) {
  const f = e.length;
  let h = 0, C;
  if (t < 0 ? t = -t > f ? 0 : f + t : t = t > f ? f : t, r = r > 0 ? r : 0, o.length < 1e4)
    C = Array.from(o), C.unshift(t, r), [].splice.apply(e, C);
  else
    for (r && [].splice.apply(e, [t, r]); h < o.length; )
      C = o.slice(h, h + 1e4), C.unshift(t, 0), [].splice.apply(e, C), h += 1e4, t += 1e4;
}
function rl(e, t) {
  return e.length > 0 ? (Wc(e, e.length, 0, t), e) : t;
}
var Tf = {}.hasOwnProperty;
function Nm(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    Em(t, e[r]);
  return t;
}
function Em(e, t) {
  let r;
  for (r in t) {
    const f = (Tf.call(e, r) ? e[r] : void 0) || (e[r] = {}), h = t[r];
    let C;
    for (C in h) {
      Tf.call(f, C) || (f[C] = []);
      const T = h[C];
      Tm(
        // @ts-expect-error Looks like a list.
        f[C],
        Array.isArray(T) ? T : T ? [T] : []
      );
    }
  }
}
function Tm(e, t) {
  let r = -1;
  const o = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : o).push(t[r]);
  Wc(e, 0, 0, o);
}
var ki = {
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9,
  // `\t`
  lf: 10,
  // `\n`
  vt: 11,
  // `\v`
  ff: 12,
  // `\f`
  cr: 13,
  // `\r`
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33,
  // `!`
  quotationMark: 34,
  // `"`
  numberSign: 35,
  // `#`
  dollarSign: 36,
  // `$`
  percentSign: 37,
  // `%`
  ampersand: 38,
  // `&`
  apostrophe: 39,
  // `'`
  leftParenthesis: 40,
  // `(`
  rightParenthesis: 41,
  // `)`
  asterisk: 42,
  // `*`
  plusSign: 43,
  // `+`
  comma: 44,
  // `,`
  dash: 45,
  // `-`
  dot: 46,
  // `.`
  slash: 47,
  // `/`
  digit0: 48,
  // `0`
  digit1: 49,
  // `1`
  digit2: 50,
  // `2`
  digit3: 51,
  // `3`
  digit4: 52,
  // `4`
  digit5: 53,
  // `5`
  digit6: 54,
  // `6`
  digit7: 55,
  // `7`
  digit8: 56,
  // `8`
  digit9: 57,
  // `9`
  colon: 58,
  // `:`
  semicolon: 59,
  // `;`
  lessThan: 60,
  // `<`
  equalsTo: 61,
  // `=`
  greaterThan: 62,
  // `>`
  questionMark: 63,
  // `?`
  atSign: 64,
  // `@`
  uppercaseA: 65,
  // `A`
  uppercaseB: 66,
  // `B`
  uppercaseC: 67,
  // `C`
  uppercaseD: 68,
  // `D`
  uppercaseE: 69,
  // `E`
  uppercaseF: 70,
  // `F`
  uppercaseG: 71,
  // `G`
  uppercaseH: 72,
  // `H`
  uppercaseI: 73,
  // `I`
  uppercaseJ: 74,
  // `J`
  uppercaseK: 75,
  // `K`
  uppercaseL: 76,
  // `L`
  uppercaseM: 77,
  // `M`
  uppercaseN: 78,
  // `N`
  uppercaseO: 79,
  // `O`
  uppercaseP: 80,
  // `P`
  uppercaseQ: 81,
  // `Q`
  uppercaseR: 82,
  // `R`
  uppercaseS: 83,
  // `S`
  uppercaseT: 84,
  // `T`
  uppercaseU: 85,
  // `U`
  uppercaseV: 86,
  // `V`
  uppercaseW: 87,
  // `W`
  uppercaseX: 88,
  // `X`
  uppercaseY: 89,
  // `Y`
  uppercaseZ: 90,
  // `Z`
  leftSquareBracket: 91,
  // `[`
  backslash: 92,
  // `\`
  rightSquareBracket: 93,
  // `]`
  caret: 94,
  // `^`
  underscore: 95,
  // `_`
  graveAccent: 96,
  // `` ` ``
  lowercaseA: 97,
  // `a`
  lowercaseB: 98,
  // `b`
  lowercaseC: 99,
  // `c`
  lowercaseD: 100,
  // `d`
  lowercaseE: 101,
  // `e`
  lowercaseF: 102,
  // `f`
  lowercaseG: 103,
  // `g`
  lowercaseH: 104,
  // `h`
  lowercaseI: 105,
  // `i`
  lowercaseJ: 106,
  // `j`
  lowercaseK: 107,
  // `k`
  lowercaseL: 108,
  // `l`
  lowercaseM: 109,
  // `m`
  lowercaseN: 110,
  // `n`
  lowercaseO: 111,
  // `o`
  lowercaseP: 112,
  // `p`
  lowercaseQ: 113,
  // `q`
  lowercaseR: 114,
  // `r`
  lowercaseS: 115,
  // `s`
  lowercaseT: 116,
  // `t`
  lowercaseU: 117,
  // `u`
  lowercaseV: 118,
  // `v`
  lowercaseW: 119,
  // `w`
  lowercaseX: 120,
  // `x`
  lowercaseY: 121,
  // `y`
  lowercaseZ: 122,
  // `z`
  leftCurlyBrace: 123,
  // `{`
  verticalBar: 124,
  // `|`
  rightCurlyBrace: 125,
  // `}`
  tilde: 126,
  // `~`
  del: 127,
  // Unicode Specials block.
  byteOrderMarker: 65279,
  // Unicode Specials block.
  replacementCharacter: 65533
  // `�`
};
var xf = Object.prototype.hasOwnProperty;
function vf(e, t, r) {
  for (r of e.keys())
    if (sl(r, t))
      return r;
}
function sl(e, t) {
  var r, o, f;
  if (e === t)
    return true;
  if (e && t && (r = e.constructor) === t.constructor) {
    if (r === Date)
      return e.getTime() === t.getTime();
    if (r === RegExp)
      return e.toString() === t.toString();
    if (r === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && sl(e[o], t[o]); )
          ;
      return o === -1;
    }
    if (r === Set) {
      if (e.size !== t.size)
        return false;
      for (o of e)
        if (f = o, f && typeof f == "object" && (f = vf(t, f), !f) || !t.has(f))
          return false;
      return true;
    }
    if (r === Map) {
      if (e.size !== t.size)
        return false;
      for (o of e)
        if (f = o[0], f && typeof f == "object" && (f = vf(t, f), !f) || !sl(o[1], t.get(f)))
          return false;
      return true;
    }
    if (r === ArrayBuffer)
      e = new Uint8Array(e), t = new Uint8Array(t);
    else if (r === DataView) {
      if ((o = e.byteLength) === t.byteLength)
        for (; o-- && e.getInt8(o) === t.getInt8(o); )
          ;
      return o === -1;
    }
    if (ArrayBuffer.isView(e)) {
      if ((o = e.byteLength) === t.byteLength)
        for (; o-- && e[o] === t[o]; )
          ;
      return o === -1;
    }
    if (!r || typeof e == "object") {
      o = 0;
      for (r in e)
        if (xf.call(e, r) && ++o && !xf.call(t, r) || !(r in t) || !sl(e[r], t[r]))
          return false;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
var Sc;
var Dh;
var Ah;
var bh;
var Mh = true;
typeof process < "u" && ({ FORCE_COLOR: Sc, NODE_DISABLE_COLORS: Dh, NO_COLOR: Ah, TERM: bh } = process.env || {}, Mh = process.stdout && process.stdout.isTTY);
var Bt = {
  enabled: !Dh && Ah == null && bh !== "dumb" && (Sc != null && Sc !== "0" || Mh),
  // modifiers
  reset: tn(0, 0),
  bold: tn(1, 22),
  dim: tn(2, 22),
  italic: tn(3, 23),
  underline: tn(4, 24),
  inverse: tn(7, 27),
  hidden: tn(8, 28),
  strikethrough: tn(9, 29),
  // colors
  black: tn(30, 39),
  red: tn(31, 39),
  green: tn(32, 39),
  yellow: tn(33, 39),
  blue: tn(34, 39),
  magenta: tn(35, 39),
  cyan: tn(36, 39),
  white: tn(37, 39),
  gray: tn(90, 39),
  grey: tn(90, 39),
  // background colors
  bgBlack: tn(40, 49),
  bgRed: tn(41, 49),
  bgGreen: tn(42, 49),
  bgYellow: tn(43, 49),
  bgBlue: tn(44, 49),
  bgMagenta: tn(45, 49),
  bgCyan: tn(46, 49),
  bgWhite: tn(47, 49)
};
function Sf(e, t) {
  let r = 0, o, f = "", h = "";
  for (; r < e.length; r++)
    o = e[r], f += o.open, h += o.close, ~t.indexOf(o.close) && (t = t.replace(o.rgx, o.close + o.open));
  return f + t + h;
}
function xm(e, t) {
  let r = { has: e, keys: t };
  return r.reset = Bt.reset.bind(r), r.bold = Bt.bold.bind(r), r.dim = Bt.dim.bind(r), r.italic = Bt.italic.bind(r), r.underline = Bt.underline.bind(r), r.inverse = Bt.inverse.bind(r), r.hidden = Bt.hidden.bind(r), r.strikethrough = Bt.strikethrough.bind(r), r.black = Bt.black.bind(r), r.red = Bt.red.bind(r), r.green = Bt.green.bind(r), r.yellow = Bt.yellow.bind(r), r.blue = Bt.blue.bind(r), r.magenta = Bt.magenta.bind(r), r.cyan = Bt.cyan.bind(r), r.white = Bt.white.bind(r), r.gray = Bt.gray.bind(r), r.grey = Bt.grey.bind(r), r.bgBlack = Bt.bgBlack.bind(r), r.bgRed = Bt.bgRed.bind(r), r.bgGreen = Bt.bgGreen.bind(r), r.bgYellow = Bt.bgYellow.bind(r), r.bgBlue = Bt.bgBlue.bind(r), r.bgMagenta = Bt.bgMagenta.bind(r), r.bgCyan = Bt.bgCyan.bind(r), r.bgWhite = Bt.bgWhite.bind(r), r;
}
function tn(e, t) {
  let r = {
    open: `\x1B[${e}m`,
    close: `\x1B[${t}m`,
    rgx: new RegExp(`\\x1b\\[${t}m`, "g")
  };
  return function(o) {
    return this !== void 0 && this.has !== void 0 ? (~this.has.indexOf(e) || (this.has.push(e), this.keys.push(r)), o === void 0 ? this : Bt.enabled ? Sf(this.keys, o + "") : o + "") : o === void 0 ? xm([e], [r]) : Bt.enabled ? Sf([r], o + "") : o + "";
  };
}
function so() {
}
so.prototype = {
  diff: function(t, r) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, f = o.callback;
    typeof o == "function" && (f = o, o = {}), this.options = o;
    var h = this;
    function C(v) {
      return f ? (setTimeout(function() {
        f(void 0, v);
      }, 0), true) : v;
    }
    t = this.castInput(t), r = this.castInput(r), t = this.removeEmpty(this.tokenize(t)), r = this.removeEmpty(this.tokenize(r));
    var T = r.length, O = t.length, S = 1, x = T + O;
    o.maxEditLength && (x = Math.min(x, o.maxEditLength));
    var D = [{
      newPos: -1,
      components: []
    }], k = this.extractCommon(D[0], r, t, 0);
    if (D[0].newPos + 1 >= T && k + 1 >= O)
      return C([{
        value: this.join(r),
        count: r.length
      }]);
    function H() {
      for (var v = -1 * S; v <= S; v += 2) {
        var F = void 0, U = D[v - 1], I = D[v + 1], K = (I ? I.newPos : 0) - v;
        U && (D[v - 1] = void 0);
        var B = U && U.newPos + 1 < T, z = I && 0 <= K && K < O;
        if (!B && !z) {
          D[v] = void 0;
          continue;
        }
        if (!B || z && U.newPos < I.newPos ? (F = Sm(I), h.pushComponent(F.components, void 0, true)) : (F = U, F.newPos++, h.pushComponent(F.components, true, void 0)), K = h.extractCommon(F, r, t, v), F.newPos + 1 >= T && K + 1 >= O)
          return C(vm(h, F.components, r, t, h.useLongestToken));
        D[v] = F;
      }
      S++;
    }
    if (f)
      (function v() {
        setTimeout(function() {
          if (S > x)
            return f();
          H() || v();
        }, 0);
      })();
    else
      for (; S <= x; ) {
        var N = H();
        if (N)
          return N;
      }
  },
  pushComponent: function(t, r, o) {
    var f = t[t.length - 1];
    f && f.added === r && f.removed === o ? t[t.length - 1] = {
      count: f.count + 1,
      added: r,
      removed: o
    } : t.push({
      count: 1,
      added: r,
      removed: o
    });
  },
  extractCommon: function(t, r, o, f) {
    for (var h = r.length, C = o.length, T = t.newPos, O = T - f, S = 0; T + 1 < h && O + 1 < C && this.equals(r[T + 1], o[O + 1]); )
      T++, O++, S++;
    return S && t.components.push({
      count: S
    }), t.newPos = T, O;
  },
  equals: function(t, r) {
    return this.options.comparator ? this.options.comparator(t, r) : t === r || this.options.ignoreCase && t.toLowerCase() === r.toLowerCase();
  },
  removeEmpty: function(t) {
    for (var r = [], o = 0; o < t.length; o++)
      t[o] && r.push(t[o]);
    return r;
  },
  castInput: function(t) {
    return t;
  },
  tokenize: function(t) {
    return t.split("");
  },
  join: function(t) {
    return t.join("");
  }
};
function vm(e, t, r, o, f) {
  for (var h = 0, C = t.length, T = 0, O = 0; h < C; h++) {
    var S = t[h];
    if (S.removed) {
      if (S.value = e.join(o.slice(O, O + S.count)), O += S.count, h && t[h - 1].added) {
        var D = t[h - 1];
        t[h - 1] = t[h], t[h] = D;
      }
    } else {
      if (!S.added && f) {
        var x = r.slice(T, T + S.count);
        x = x.map(function(H, N) {
          var v = o[O + N];
          return v.length > H.length ? v : H;
        }), S.value = e.join(x);
      } else
        S.value = e.join(r.slice(T, T + S.count));
      T += S.count, S.added || (O += S.count);
    }
  }
  var k = t[C - 1];
  return C > 1 && typeof k.value == "string" && (k.added || k.removed) && e.equals("", k.value) && (t[C - 2].value += k.value, t.pop()), t;
}
function Sm(e) {
  return {
    newPos: e.newPos,
    components: e.components.slice(0)
  };
}
var wf = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var Of = /\S/;
var Lh = new so();
Lh.equals = function(e, t) {
  return this.options.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e === t || this.options.ignoreWhitespace && !Of.test(e) && !Of.test(t);
};
Lh.tokenize = function(e) {
  for (var t = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), r = 0; r < t.length - 1; r++)
    !t[r + 1] && t[r + 2] && wf.test(t[r]) && wf.test(t[r + 2]) && (t[r] += t[r + 2], t.splice(r + 1, 2), r--);
  return t;
};
var Ph = new so();
Ph.tokenize = function(e) {
  var t = [], r = e.split(/(\n|\r\n)/);
  r[r.length - 1] || r.pop();
  for (var o = 0; o < r.length; o++) {
    var f = r[o];
    o % 2 && !this.options.newlineIsToken ? t[t.length - 1] += f : (this.options.ignoreWhitespace && (f = f.trim()), t.push(f));
  }
  return t;
};
var wm = new so();
wm.tokenize = function(e) {
  return e.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Om = new so();
Om.tokenize = function(e) {
  return e.split(/([{}:;,]|\s+)/);
};
function Xl(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Xl = function(t) {
    return typeof t;
  } : Xl = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xl(e);
}
var Rm = Object.prototype.toString;
var ll = new so();
ll.useLongestToken = true;
ll.tokenize = Ph.tokenize;
ll.castInput = function(e) {
  var t = this.options, r = t.undefinedReplacement, o = t.stringifyReplacer, f = o === void 0 ? function(h, C) {
    return typeof C > "u" ? r : C;
  } : o;
  return typeof e == "string" ? e : JSON.stringify(wc(e, null, null, f), f, "  ");
};
ll.equals = function(e, t) {
  return so.prototype.equals.call(ll, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"));
};
function wc(e, t, r, o, f) {
  t = t || [], r = r || [], o && (e = o(f, e));
  var h;
  for (h = 0; h < t.length; h += 1)
    if (t[h] === e)
      return r[h];
  var C;
  if (Rm.call(e) === "[object Array]") {
    for (t.push(e), C = new Array(e.length), r.push(C), h = 0; h < e.length; h += 1)
      C[h] = wc(e[h], t, r, o, f);
    return t.pop(), r.pop(), C;
  }
  if (e && e.toJSON && (e = e.toJSON()), Xl(e) === "object" && e !== null) {
    t.push(e), C = {}, r.push(C);
    var T = [], O;
    for (O in e)
      e.hasOwnProperty(O) && T.push(O);
    for (T.sort(), h = 0; h < T.length; h += 1)
      O = T[h], C[O] = wc(e[O], t, r, o, O);
    t.pop(), r.pop();
  } else
    C = e;
  return C;
}
var Oc = new so();
Oc.tokenize = function(e) {
  return e.slice();
};
Oc.join = Oc.removeEmpty = function(e) {
  return e;
};
Bt.red, Bt.grey, Bt.green;
Bt.dim().italic;
Bt.dim("→");
Bt.dim("·");
Bt.dim("↵");
function ea(e) {
  e = e.replace(/\r?\n/g, `
`);
  let t = e.match(/^[ \t]*(?=\S)/gm), r = 0, o = 1 / 0, f = (t || []).length;
  for (; r < f; r++)
    o = Math.min(o, t[r].length);
  return f && o ? e.replace(new RegExp(`^[ \\t]{${o}}`, "gm"), "") : e;
}
var Dm = class extends Error {
  constructor(t = {}) {
    super(t.message), this.name = "Assertion", this.code = "ERR_ASSERTION", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.details = t.details || false, this.generated = !!t.generated, this.operator = t.operator, this.expects = t.expects, this.actual = t.actual;
  }
};
function kr(e, t, r, o, f, h, C) {
  if (e)
    return;
  let T = C || h;
  if (C instanceof Error)
    throw C;
  let O = f && f(t, r);
  throw new Dm({ actual: t, expects: r, operator: o, message: T, details: O, generated: !C });
}
function aa(e, t) {
  kr(!!e, false, true, "ok", false, "Expected value to be truthy", t);
}
function $i(e, t) {
  kr(!e, true, false, "not", false, "Expected value to be falsey", t);
}
$i.ok = $i;
$i.equal = function(e, t, r) {
  kr(!sl(e, t), e, t, "not.equal", false, "Expected values not to be deeply equal", r);
};
$i.type = function(e, t, r) {
  let o = typeof e;
  kr(o !== t, o, t, "not.type", false, `Expected "${o}" not to be "${t}"`, r);
};
$i.instance = function(e, t, r) {
  let o = "`" + (t.name || t.constructor.name) + "`";
  kr(!(e instanceof t), e, t, "not.instance", false, `Expected value not to be an instance of ${o}`, r);
};
$i.snapshot = function(e, t, r) {
  e = ea(e), t = ea(t), kr(e !== t, e, t, "not.snapshot", false, "Expected value not to match snapshot", r);
};
$i.fixture = function(e, t, r) {
  e = ea(e), t = ea(t), kr(e !== t, e, t, "not.fixture", false, "Expected value not to match fixture", r);
};
$i.match = function(e, t, r) {
  typeof t == "string" ? kr(!e.includes(t), e, t, "not.match", false, `Expected value not to include "${t}" substring`, r) : kr(!t.test(e), e, t, "not.match", false, `Expected value not to match \`${String(t)}\` pattern`, r);
};
$i.throws = function(e, t, r) {
  !r && typeof t == "string" && (r = t, t = null);
  try {
    e();
  } catch (o) {
    typeof t == "function" ? kr(!t(o), true, false, "not.throws", false, "Expected function not to throw matching exception", r) : t instanceof RegExp ? kr(!t.test(o.message), true, false, "not.throws", false, `Expected function not to throw exception matching \`${String(t)}\` pattern`, r) : t || kr(false, true, false, "not.throws", false, "Expected function not to throw", r);
  }
};
var Am = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var ZC = lo(/[A-Za-z]/);
var Rf = lo(/[\dA-Za-z]/);
var XC = lo(/[#-'*+\--9=?A-Z^-~]/);
function QC(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
var eN = lo(/\d/);
var tN = lo(/[\dA-Fa-f]/);
var nN = lo(/[!-/:-@[-`{-~]/);
function rN(e) {
  return e !== null && e < -2;
}
function bm(e) {
  return e !== null && (e < 0 || e === 32);
}
function iN(e) {
  return e === -2 || e === -1 || e === 32;
}
var Mm = lo(Am);
var Lm = lo(/\s/);
function lo(e) {
  return t;
  function t(r) {
    return r !== null && e.test(String.fromCharCode(r));
  }
}
function ta(e) {
  if (e === null || bm(e) || Lm(e))
    return 1;
  if (Mm(e))
    return 2;
}
var na = {
  attentionSideBefore: 1,
  // Symbol to mark an attention sequence as before content: `*a`
  attentionSideAfter: 2,
  // Symbol to mark an attention sequence as after content: `a*`
  atxHeadingOpeningFenceSizeMax: 6,
  // 6 number signs is fine, 7 isn’t.
  autolinkDomainSizeMax: 63,
  // 63 characters is fine, 64 is too many.
  autolinkSchemeSizeMax: 32,
  // 32 characters is fine, 33 is too many.
  cdataOpeningString: "CDATA[",
  // And preceded by `<![`.
  characterGroupWhitespace: 1,
  // Symbol used to indicate a character is whitespace
  characterGroupPunctuation: 2,
  // Symbol used to indicate a character is punctuation
  characterReferenceDecimalSizeMax: 7,
  // `&#9999999;`.
  characterReferenceHexadecimalSizeMax: 6,
  // `&#xff9999;`.
  characterReferenceNamedSizeMax: 31,
  // `&CounterClockwiseContourIntegral;`.
  codeFencedSequenceSizeMin: 3,
  // At least 3 ticks or tildes are needed.
  contentTypeDocument: "document",
  contentTypeFlow: "flow",
  contentTypeContent: "content",
  contentTypeString: "string",
  contentTypeText: "text",
  hardBreakPrefixSizeMin: 2,
  // At least 2 trailing spaces are needed.
  htmlRaw: 1,
  // Symbol for `<script>`
  htmlComment: 2,
  // Symbol for `<!---->`
  htmlInstruction: 3,
  // Symbol for `<?php?>`
  htmlDeclaration: 4,
  // Symbol for `<!doctype>`
  htmlCdata: 5,
  // Symbol for `<![CDATA[]]>`
  htmlBasic: 6,
  // Symbol for `<div`
  htmlComplete: 7,
  // Symbol for `<x>`
  htmlRawSizeMax: 8,
  // Length of `textarea`.
  linkResourceDestinationBalanceMax: 32,
  // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
  linkReferenceSizeMax: 999,
  // See: <https://spec.commonmark.org/0.30/#link-label>
  listItemValueSizeMax: 10,
  // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 16,
  tabSize: 4,
  // Tabs have a hard-coded size of 4, per CommonMark.
  thematicBreakMarkerCountMin: 3,
  // At least 3 asterisks, dashes, or underscores are needed.
  v8MaxSafeChunkSize: 1e4
  // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
};
function Pm(e, t) {
  const r = this.previous, o = ta(r);
  return f;
  function f(C) {
    return aa(C === ki.tilde, "expected `~`"), e.enter("tildeSequenceTemporary"), h(C);
  }
  function h(C) {
    if (C === ki.tilde)
      return e.consume(C), h;
    const T = e.exit("tildeSequenceTemporary"), O = ta(C);
    return T._open = !O || O === na.characterGroupPunctuation && !!o, T._close = !o || o === na.characterGroupPunctuation && !!O, t(C);
  }
}
function Im(e, t, r) {
  const o = [];
  let f = -1;
  for (; ++f < e.length; ) {
    const h = e[f].resolveAll;
    h && !o.includes(h) && (t = h(t, r), o.push(h));
  }
  return t;
}
var km = {
  // Generic type for data, such as in a title, a destination, etc.
  data: "data",
  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
  // Such as, between a fenced code fence and an info string.
  whitespace: "whitespace",
  // Generic type for line endings (line feed, carriage return, carriage return +
  // line feed).
  lineEnding: "lineEnding",
  // A line ending, but ending a blank line.
  lineEndingBlank: "lineEndingBlank",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
  // line.
  linePrefix: "linePrefix",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
  // line.
  lineSuffix: "lineSuffix",
  // Whole ATX heading:
  //
  // ```markdown
  // #
  // ## Alpha
  // ### Bravo ###
  // ```
  //
  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
  atxHeading: "atxHeading",
  // Sequence of number signs in an ATX heading (`###`).
  atxHeadingSequence: "atxHeadingSequence",
  // Content in an ATX heading (`alpha`).
  // Includes text.
  atxHeadingText: "atxHeadingText",
  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
  autolink: "autolink",
  // Email autolink w/o markers (`admin@example.com`)
  autolinkEmail: "autolinkEmail",
  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
  autolinkMarker: "autolinkMarker",
  // Protocol autolink w/o markers (`https://example.com`)
  autolinkProtocol: "autolinkProtocol",
  // A whole character escape (`\-`).
  // Includes `escapeMarker` and `characterEscapeValue`.
  characterEscape: "characterEscape",
  // The escaped character (`-`).
  characterEscapeValue: "characterEscapeValue",
  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
  // Includes `characterReferenceMarker`, an optional
  // `characterReferenceMarkerNumeric`, in which case an optional
  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
  characterReference: "characterReference",
  // The start or end marker (`&` or `;`).
  characterReferenceMarker: "characterReferenceMarker",
  // Mark reference as numeric (`#`).
  characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
  // Mark reference as numeric (`x` or `X`).
  characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
  characterReferenceValue: "characterReferenceValue",
  // Whole fenced code:
  //
  // ````markdown
  // ```js
  // alert(1)
  // ```
  // ````
  codeFenced: "codeFenced",
  // A fenced code fence, including whitespace, sequence, info, and meta
  // (` ```js `).
  codeFencedFence: "codeFencedFence",
  // Sequence of grave accent or tilde characters (` ``` `) in a fence.
  codeFencedFenceSequence: "codeFencedFenceSequence",
  // Info word (`js`) in a fence.
  // Includes string.
  codeFencedFenceInfo: "codeFencedFenceInfo",
  // Meta words (`highlight="1"`) in a fence.
  // Includes string.
  codeFencedFenceMeta: "codeFencedFenceMeta",
  // A line of code.
  codeFlowValue: "codeFlowValue",
  // Whole indented code:
  //
  // ```markdown
  //     alert(1)
  // ```
  //
  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
  codeIndented: "codeIndented",
  // A text code (``` `alpha` ```).
  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
  // `codeTextPadding`.
  codeText: "codeText",
  codeTextData: "codeTextData",
  // A space or line ending right after or before a tick.
  codeTextPadding: "codeTextPadding",
  // A text code fence (` `` `).
  codeTextSequence: "codeTextSequence",
  // Whole content:
  //
  // ```markdown
  // [a]: b
  // c
  // =
  // d
  // ```
  //
  // Includes `paragraph` and `definition`.
  content: "content",
  // Whole definition:
  //
  // ```markdown
  // [micromark]: https://github.com/micromark/micromark
  // ```
  //
  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
  definition: "definition",
  // Destination of a definition (`https://github.com/micromark/micromark` or
  // `<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
  definitionDestination: "definitionDestination",
  // Enclosed destination of a definition
  // (`<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteralMarker` and optionally
  // `definitionDestinationString`.
  definitionDestinationLiteral: "definitionDestinationLiteral",
  // Markers of an enclosed definition destination (`<` or `>`).
  definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
  // Unenclosed destination of a definition
  // (`https://github.com/micromark/micromark`).
  // Includes `definitionDestinationString`.
  definitionDestinationRaw: "definitionDestinationRaw",
  // Text in an destination (`https://github.com/micromark/micromark`).
  // Includes string.
  definitionDestinationString: "definitionDestinationString",
  // Label of a definition (`[micromark]`).
  // Includes `definitionLabelMarker` and `definitionLabelString`.
  definitionLabel: "definitionLabel",
  // Markers of a definition label (`[` or `]`).
  definitionLabelMarker: "definitionLabelMarker",
  // Value of a definition label (`micromark`).
  // Includes string.
  definitionLabelString: "definitionLabelString",
  // Marker between a label and a destination (`:`).
  definitionMarker: "definitionMarker",
  // Title of a definition (`"x"`, `'y'`, or `(z)`).
  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
  definitionTitle: "definitionTitle",
  // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
  definitionTitleMarker: "definitionTitleMarker",
  // Data without markers in a title (`z`).
  // Includes string.
  definitionTitleString: "definitionTitleString",
  // Emphasis (`*alpha*`).
  // Includes `emphasisSequence` and `emphasisText`.
  emphasis: "emphasis",
  // Sequence of emphasis markers (`*` or `_`).
  emphasisSequence: "emphasisSequence",
  // Emphasis text (`alpha`).
  // Includes text.
  emphasisText: "emphasisText",
  // The character escape marker (`\`).
  escapeMarker: "escapeMarker",
  // A hard break created with a backslash (`\\n`).
  // Includes `escapeMarker` (does not include the line ending)
  hardBreakEscape: "hardBreakEscape",
  // A hard break created with trailing spaces (`  \n`).
  // Does not include the line ending.
  hardBreakTrailing: "hardBreakTrailing",
  // Flow HTML:
  //
  // ```markdown
  // <div
  // ```
  //
  // Inlcudes `lineEnding`, `htmlFlowData`.
  htmlFlow: "htmlFlow",
  htmlFlowData: "htmlFlowData",
  // HTML in text (the tag in `a <i> b`).
  // Includes `lineEnding`, `htmlTextData`.
  htmlText: "htmlText",
  htmlTextData: "htmlTextData",
  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
  // `![alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  image: "image",
  // Whole link label (`[*alpha*]`).
  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
  label: "label",
  // Text in an label (`*alpha*`).
  // Includes text.
  labelText: "labelText",
  // Start a link label (`[`).
  // Includes a `labelMarker`.
  labelLink: "labelLink",
  // Start an image label (`![`).
  // Includes `labelImageMarker` and `labelMarker`.
  labelImage: "labelImage",
  // Marker of a label (`[` or `]`).
  labelMarker: "labelMarker",
  // Marker to start an image (`!`).
  labelImageMarker: "labelImageMarker",
  // End a label (`]`).
  // Includes `labelMarker`.
  labelEnd: "labelEnd",
  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  link: "link",
  // Whole paragraph:
  //
  // ```markdown
  // alpha
  // bravo.
  // ```
  //
  // Includes text.
  paragraph: "paragraph",
  // A reference (`[alpha]` or `[]`).
  // Includes `referenceMarker` and an optional `referenceString`.
  reference: "reference",
  // A reference marker (`[` or `]`).
  referenceMarker: "referenceMarker",
  // Reference text (`alpha`).
  // Includes string.
  referenceString: "referenceString",
  // A resource (`(https://example.com "alpha")`).
  // Includes `resourceMarker`, an optional `resourceDestination` with an optional
  // `whitespace` and `resourceTitle`.
  resource: "resource",
  // A resource destination (`https://example.com`).
  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
  resourceDestination: "resourceDestination",
  // A literal resource destination (`<https://example.com>`).
  // Includes `resourceDestinationLiteralMarker` and optionally
  // `resourceDestinationString`.
  resourceDestinationLiteral: "resourceDestinationLiteral",
  // A resource destination marker (`<` or `>`).
  resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
  // A raw resource destination (`https://example.com`).
  // Includes `resourceDestinationString`.
  resourceDestinationRaw: "resourceDestinationRaw",
  // Resource destination text (`https://example.com`).
  // Includes string.
  resourceDestinationString: "resourceDestinationString",
  // A resource marker (`(` or `)`).
  resourceMarker: "resourceMarker",
  // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
  resourceTitle: "resourceTitle",
  // A resource title marker (`"`, `'`, `(`, or `)`).
  resourceTitleMarker: "resourceTitleMarker",
  // Resource destination title (`alpha`).
  // Includes string.
  resourceTitleString: "resourceTitleString",
  // Whole setext heading:
  //
  // ```markdown
  // alpha
  // bravo
  // =====
  // ```
  //
  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
  // `setextHeadingLine`.
  setextHeading: "setextHeading",
  // Content in a setext heading (`alpha\nbravo`).
  // Includes text.
  setextHeadingText: "setextHeadingText",
  // Underline in a setext heading, including whitespace suffix (`==`).
  // Includes `setextHeadingLineSequence`.
  setextHeadingLine: "setextHeadingLine",
  // Sequence of equals or dash characters in underline in a setext heading (`-`).
  setextHeadingLineSequence: "setextHeadingLineSequence",
  // Strong (`**alpha**`).
  // Includes `strongSequence` and `strongText`.
  strong: "strong",
  // Sequence of strong markers (`**` or `__`).
  strongSequence: "strongSequence",
  // Strong text (`alpha`).
  // Includes text.
  strongText: "strongText",
  // Whole thematic break:
  //
  // ```markdown
  // * * *
  // ```
  //
  // Includes `thematicBreakSequence` and `whitespace`.
  thematicBreak: "thematicBreak",
  // A sequence of one or more thematic break markers (`***`).
  thematicBreakSequence: "thematicBreakSequence",
  // Whole block quote:
  //
  // ```markdown
  // > a
  // >
  // > b
  // ```
  //
  // Includes `blockQuotePrefix` and flow.
  blockQuote: "blockQuote",
  // The `>` or `> ` of a block quote.
  blockQuotePrefix: "blockQuotePrefix",
  // The `>` of a block quote prefix.
  blockQuoteMarker: "blockQuoteMarker",
  // The optional ` ` of a block quote prefix.
  blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
  // Whole unordered list:
  //
  // ```markdown
  // - a
  //   b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listOrdered: "listOrdered",
  // Whole ordered list:
  //
  // ```markdown
  // 1. a
  //    b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listUnordered: "listUnordered",
  // The indent of further list item lines.
  listItemIndent: "listItemIndent",
  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
  listItemMarker: "listItemMarker",
  // The thing that starts a list item, such as `1. `.
  // Includes `listItemValue` if ordered, `listItemMarker`, and
  // `listItemPrefixWhitespace` (unless followed by a line ending).
  listItemPrefix: "listItemPrefix",
  // The whitespace after a marker.
  listItemPrefixWhitespace: "listItemPrefixWhitespace",
  // The numerical value of an ordered item.
  listItemValue: "listItemValue",
  // Internal types used for subtokenizers, compiled away
  chunkDocument: "chunkDocument",
  chunkContent: "chunkContent",
  chunkFlow: "chunkFlow",
  chunkText: "chunkText",
  chunkString: "chunkString"
};
function zc(e, t) {
  return !!(e[0] === "enter" && e[1].type === `${t}SequenceTemporary` && e[1]._close);
}
function Gc(e, t) {
  return !!(e[0] === "exit" && e[1].type === `${t}SequenceTemporary` && e[1]._open);
}
function Yc(e, t, r, o, f, h) {
  const [C, T, O, S] = $m(
    e[t],
    e[r],
    f,
    h
  );
  e[t][1].end = Object.assign({}, C.start), e[r][1].start = Object.assign({}, T.end);
  let x = [];
  e[t][1].end.offset - e[t][1].start.offset && (x = rl(x, [
    ["enter", e[t][1], o],
    ["exit", e[t][1], o]
  ])), x = rl(x, [
    ["enter", S, o],
    ["enter", C, o],
    ["exit", C, o],
    ["enter", O, o]
  ]), x = rl(
    x,
    Im(
      o.parser.constructs.insideSpan.null,
      e.slice(t + 1, r),
      o
    )
  ), x = rl(x, [
    ["exit", O, o],
    ["enter", T, o],
    ["exit", T, o],
    ["exit", S, o]
  ]);
  let D = 0;
  return e[r][1].end.offset - e[r][1].start.offset && (D = 2, x = rl(x, [
    ["enter", e[r][1], o],
    ["exit", e[r][1], o]
  ])), Wc(e, t - 1, r - t + 3, x), t + x.length - D - 2;
}
function $m(e, t, r, o) {
  const f = Object.assign({}, e[1].end), h = Object.assign({}, t[1].start);
  Df(f, -o), Df(h, o);
  const C = {
    type: `${r}Sequence`,
    start: f,
    end: Object.assign({}, e[1].end)
  }, T = {
    type: `${r}Sequence`,
    start: Object.assign({}, t[1].start),
    end: h
  }, O = {
    type: `${r}Text`,
    start: Object.assign({}, e[1].end),
    end: Object.assign({}, t[1].start)
  }, S = {
    type: `${r}`,
    start: Object.assign({}, C.start),
    end: Object.assign({}, T.end)
  };
  return [C, T, O, S];
}
function Df(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
function jc(e, t) {
  e.forEach((r) => {
    r[1].type === `${t}SequenceTemporary` && (r[1].type = km.data);
  });
}
function Fm(e, t) {
  let r = -1;
  for (; ++r < e.length; )
    if (zc(e[r], "tilde")) {
      let o = r;
      for (; o--; )
        if (Gc(e[o], "tilde")) {
          const f = Bm(e[o], e[r]);
          r = Yc(
            e,
            o,
            r,
            t,
            f === 1 ? "subscript" : "strikethrough",
            f
          );
          break;
        }
    }
  return jc(e, "tilde"), e;
}
function Bm(e, t) {
  const r = e[1].end.offset - e[1].start.offset, o = t[1].end.offset - t[1].start.offset;
  return r < 3 || o < 3 ? o < r ? o : r : o % 2 === 0 ? 2 : 1;
}
function Km() {
  const e = {
    tokenize: Pm,
    resolveAll: Fm
  };
  return {
    text: { [ki.tilde]: e },
    insideSpan: { null: [e] }
  };
}
function Hm(e, t) {
  let r = -1;
  for (; ++r < e.length; )
    if (zc(e[r], "superscript")) {
      let o = r;
      for (; o--; )
        if (Gc(e[o], "superscript")) {
          r = Yc(
            e,
            o,
            r,
            t,
            "superscript",
            1
          );
          break;
        }
    }
  return jc(e, "superscript"), e;
}
function Um(e, t) {
  return r;
  function r(f) {
    return aa(f === ki.caret, "expected `^`"), e.enter("superscriptSequenceTemporary"), o(f);
  }
  function o(f) {
    if (f === ki.caret)
      return e.consume(f), o;
    const h = e.exit("superscriptSequenceTemporary");
    return h._open = true, h._close = true, t(f);
  }
}
function Wm() {
  const e = {
    tokenize: Um,
    resolveAll: Hm
  };
  return {
    text: { [ki.caret]: e },
    insideSpan: { null: [e] }
  };
}
function zm(e, t, r) {
  const o = this.previous, f = ta(o);
  let h = 0;
  return C;
  function C(O) {
    return aa(O === ki.plusSign, "expected `+`"), e.enter("underlineSequenceTemporary"), T(O);
  }
  function T(O) {
    if (O === ki.plusSign)
      return e.consume(O), h++, T;
    if (h < 2)
      return r(O);
    const S = e.exit("underlineSequenceTemporary"), x = ta(O);
    return S._open = !x || x === na.characterGroupPunctuation && !!f, S._close = !f || f === na.characterGroupPunctuation && !!x, t(O);
  }
}
function Gm(e, t) {
  let r = -1;
  for (; ++r < e.length; )
    if (zc(e[r], "underline") && e[r][1].end.offset - e[r][1].start.offset > 1) {
      let o = r;
      for (; o--; )
        if (Gc(e[o], "underline") && e[o][1].end.offset - e[o][1].start.offset > 1) {
          r = Yc(
            e,
            o,
            r,
            t,
            "underline",
            2
          );
          break;
        }
    }
  return jc(e, "underline"), e;
}
function Ym() {
  const e = {
    tokenize: zm,
    resolveAll: Gm
  };
  return {
    text: { [ki.plusSign]: e },
    insideSpan: { null: [e] }
  };
}
function jm() {
  return Nm([
    Ym(),
    Wm(),
    Km()
  ]);
}
var qm = {
  canContainEols: ["strikethrough"],
  enter: { strikethrough: Vm },
  exit: { strikethrough: Jm }
};
function Vm(e) {
  this.enter({ type: "strikethrough", children: [] }, e);
}
function Jm(e) {
  this.exit(e);
}
var Zm = {
  canContainEols: ["subscript"],
  enter: { subscript: Xm },
  exit: { subscript: Qm }
};
function Xm(e) {
  this.enter({ type: "subscript", children: [] }, e);
}
function Qm(e) {
  this.exit(e);
}
var ey = {
  canContainEols: ["superscript"],
  enter: { superscript: ty },
  exit: { superscript: ny }
};
function ty(e) {
  this.enter({ type: "superscript", children: [] }, e);
}
function ny(e) {
  this.exit(e);
}
var ry = {
  canContainEols: ["underline"],
  enter: { underline: iy },
  exit: { underline: oy }
};
function iy(e) {
  this.enter({ type: "underline", children: [] }, e);
}
function oy(e) {
  this.exit(e);
}
function sy() {
  return [
    ry,
    qm,
    Zm,
    ey
  ];
}
function ly() {
  const e = this.data();
  t("micromarkExtensions", jm()), t("fromMarkdownExtensions", sy());
  function t(r, o) {
    const f = e[r];
    f ? (aa(Array.isArray(f)), f.push(o)) : e[r] = [o];
  }
}
function ay(e, t) {
  const r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), true)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function cy(e, t) {
  const r = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, r), [e.applyData(t, r), { type: "text", value: `
` }];
}
function uy(e, t) {
  const r = t.value ? t.value + `
` : "", o = t.lang ? t.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, f = {};
  o && (f.className = ["language-" + o]);
  let h = {
    type: "element",
    tagName: "code",
    properties: f,
    children: [{ type: "text", value: r }]
  };
  return t.meta && (h.data = { meta: t.meta }), e.patch(t, h), h = e.applyData(t, h), h = { type: "element", tagName: "pre", properties: {}, children: [h] }, e.patch(t, h), h;
}
function dy(e, t) {
  const r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function fy(e, t) {
  const r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function al(e) {
  const t = [];
  let r = -1, o = 0, f = 0;
  for (; ++r < e.length; ) {
    const h = e.charCodeAt(r);
    let C = "";
    if (h === 37 && Rf(e.charCodeAt(r + 1)) && Rf(e.charCodeAt(r + 2)))
      f = 2;
    else if (h < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(h)) || (C = String.fromCharCode(h));
    else if (h > 55295 && h < 57344) {
      const T = e.charCodeAt(r + 1);
      h < 56320 && T > 56319 && T < 57344 ? (C = String.fromCharCode(h, T), f = 1) : C = "�";
    } else
      C = String.fromCharCode(h);
    C && (t.push(e.slice(o, r), encodeURIComponent(C)), o = r + f + 1, C = ""), f && (r += f, f = 0);
  }
  return t.join("") + e.slice(o);
}
function Ih(e, t) {
  const r = String(t.identifier).toUpperCase(), o = al(r.toLowerCase()), f = e.footnoteOrder.indexOf(r);
  let h;
  f === -1 ? (e.footnoteOrder.push(r), e.footnoteCounts[r] = 1, h = e.footnoteOrder.length) : (e.footnoteCounts[r]++, h = f + 1);
  const C = e.footnoteCounts[r], T = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + e.clobberPrefix + "fn-" + o,
      id: e.clobberPrefix + "fnref-" + o + (C > 1 ? "-" + C : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(h) }]
  };
  e.patch(t, T);
  const O = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [T]
  };
  return e.patch(t, O), e.applyData(t, O);
}
function hy(e, t) {
  const r = e.footnoteById;
  let o = 1;
  for (; o in r; )
    o++;
  const f = String(o);
  return r[f] = {
    type: "footnoteDefinition",
    identifier: f,
    children: [{ type: "paragraph", children: t.children }],
    position: t.position
  }, Ih(e, {
    type: "footnoteReference",
    identifier: f,
    position: t.position
  });
}
function gy(e, t) {
  const r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function py(e, t) {
  if (e.dangerous) {
    const r = { type: "raw", value: t.value };
    return e.patch(t, r), e.applyData(t, r);
  }
  return null;
}
function kh(e, t) {
  const r = t.referenceType;
  let o = "]";
  if (r === "collapsed" ? o += "[]" : r === "full" && (o += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return { type: "text", value: "![" + t.alt + o };
  const f = e.all(t), h = f[0];
  h && h.type === "text" ? h.value = "[" + h.value : f.unshift({ type: "text", value: "[" });
  const C = f[f.length - 1];
  return C && C.type === "text" ? C.value += o : f.push({ type: "text", value: o }), f;
}
function _y(e, t) {
  const r = e.definition(t.identifier);
  if (!r)
    return kh(e, t);
  const o = { src: al(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const f = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, f), e.applyData(t, f);
}
function my(e, t) {
  const r = { src: al(t.url) };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  const o = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function yy(e, t) {
  const r = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, r);
  const o = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Cy(e, t) {
  const r = e.definition(t.identifier);
  if (!r)
    return kh(e, t);
  const o = { href: al(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const f = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function Ny(e, t) {
  const r = { href: al(t.url) };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Ey(e, t, r) {
  const o = e.all(t), f = r ? Ty(r) : $h(t), h = {}, C = [];
  if (typeof t.checked == "boolean") {
    const x = o[0];
    let D;
    x && x.type === "element" && x.tagName === "p" ? D = x : (D = { type: "element", tagName: "p", properties: {}, children: [] }, o.unshift(D)), D.children.length > 0 && D.children.unshift({ type: "text", value: " " }), D.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: true },
      children: []
    }), h.className = ["task-list-item"];
  }
  let T = -1;
  for (; ++T < o.length; ) {
    const x = o[T];
    (f || T !== 0 || x.type !== "element" || x.tagName !== "p") && C.push({ type: "text", value: `
` }), x.type === "element" && x.tagName === "p" && !f ? C.push(...x.children) : C.push(x);
  }
  const O = o[o.length - 1];
  O && (f || O.type !== "element" || O.tagName !== "p") && C.push({ type: "text", value: `
` });
  const S = { type: "element", tagName: "li", properties: h, children: C };
  return e.patch(t, S), e.applyData(t, S);
}
function Ty(e) {
  let t = false;
  if (e.type === "list") {
    t = e.spread || false;
    const r = e.children;
    let o = -1;
    for (; !t && ++o < r.length; )
      t = $h(r[o]);
  }
  return t;
}
function $h(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function xy(e, t) {
  const r = {}, o = e.all(t);
  let f = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++f < o.length; ) {
    const C = o[f];
    if (C.type === "element" && C.tagName === "li" && C.properties && Array.isArray(C.properties.className) && C.properties.className.includes("task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  const h = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(o, true)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function vy(e, t) {
  const r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Sy(e, t) {
  const r = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, r), e.applyData(t, r);
}
function wy(e, t) {
  const r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
var qc = Fh("start");
var Vc = Fh("end");
function Oy(e) {
  return { start: qc(e), end: Vc(e) };
}
function Fh(e) {
  return t;
  function t(r) {
    const o = r && r.position && r.position[e] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: o.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: o.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: o.offset > -1 ? o.offset : null
    };
  }
}
function Ry(e, t) {
  const r = e.all(t), o = r.shift(), f = [];
  if (o) {
    const C = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([o], true)
    };
    e.patch(t.children[0], C), f.push(C);
  }
  if (r.length > 0) {
    const C = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, true)
    }, T = qc(t.children[1]), O = Vc(t.children[t.children.length - 1]);
    T.line && O.line && (C.position = { start: T, end: O }), f.push(C);
  }
  const h = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(f, true)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function Dy(e, t, r) {
  const o = r ? r.children : void 0, h = (o ? o.indexOf(t) : 1) === 0 ? "th" : "td", C = r && r.type === "table" ? r.align : void 0, T = C ? C.length : t.children.length;
  let O = -1;
  const S = [];
  for (; ++O < T; ) {
    const D = t.children[O], k = {}, H = C ? C[O] : void 0;
    H && (k.align = H);
    let N = { type: "element", tagName: h, properties: k, children: [] };
    D && (N.children = e.all(D), e.patch(D, N), N = e.applyData(t, N)), S.push(N);
  }
  const x = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(S, true)
  };
  return e.patch(t, x), e.applyData(t, x);
}
function Ay(e, t) {
  const r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
var Af = 9;
var bf = 32;
function by(e) {
  const t = String(e), r = /\r?\n|\r/g;
  let o = r.exec(t), f = 0;
  const h = [];
  for (; o; )
    h.push(
      Mf(t.slice(f, o.index), f > 0, true),
      o[0]
    ), f = o.index + o[0].length, o = r.exec(t);
  return h.push(Mf(t.slice(f), f > 0, false)), h.join("");
}
function Mf(e, t, r) {
  let o = 0, f = e.length;
  if (t) {
    let h = e.codePointAt(o);
    for (; h === Af || h === bf; )
      o++, h = e.codePointAt(o);
  }
  if (r) {
    let h = e.codePointAt(f - 1);
    for (; h === Af || h === bf; )
      f--, h = e.codePointAt(f - 1);
  }
  return f > o ? e.slice(o, f) : "";
}
function My(e, t) {
  const r = { type: "text", value: by(String(t.value)) };
  return e.patch(t, r), e.applyData(t, r);
}
function Ly(e, t) {
  const r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
var Py = {
  blockquote: ay,
  break: cy,
  code: uy,
  delete: dy,
  emphasis: fy,
  footnoteReference: Ih,
  footnote: hy,
  heading: gy,
  html: py,
  imageReference: _y,
  image: my,
  inlineCode: yy,
  linkReference: Cy,
  link: Ny,
  listItem: Ey,
  list: xy,
  paragraph: vy,
  root: Sy,
  strong: wy,
  table: Ry,
  tableCell: Ay,
  tableRow: Dy,
  text: My,
  thematicBreak: Ly,
  toml: Zl,
  yaml: Zl,
  definition: Zl,
  footnoteDefinition: Zl
};
function Zl() {
  return null;
}
var Bh = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(e) {
    if (e == null)
      return Fy;
    if (typeof e == "string")
      return $y(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Iy(e) : ky(e);
    if (typeof e == "function")
      return ca(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Iy(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = Bh(e[r]);
  return ca(o);
  function o(...f) {
    let h = -1;
    for (; ++h < t.length; )
      if (t[h].call(this, ...f))
        return true;
    return false;
  }
}
function ky(e) {
  return ca(t);
  function t(r) {
    let o;
    for (o in e)
      if (r[o] !== e[o])
        return false;
    return true;
  }
}
function $y(e) {
  return ca(t);
  function t(r) {
    return r && r.type === e;
  }
}
function ca(e) {
  return t;
  function t(r, ...o) {
    return !!(r && typeof r == "object" && "type" in r && e.call(this, r, ...o));
  }
}
function Fy() {
  return true;
}
var By = true;
var Lf = false;
var Ky = "skip";
var Hy = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, t, r, o) {
    typeof t == "function" && typeof r != "function" && (o = r, r = t, t = null);
    const f = Bh(t), h = o ? -1 : 1;
    C(e, void 0, [])();
    function C(T, O, S) {
      const x = T && typeof T == "object" ? T : {};
      if (typeof x.type == "string") {
        const k = (
          // `hast`
          typeof x.tagName == "string" ? x.tagName : (
            // `xast`
            typeof x.name == "string" ? x.name : void 0
          )
        );
        Object.defineProperty(D, "name", {
          value: "node (" + (T.type + (k ? "<" + k + ">" : "")) + ")"
        });
      }
      return D;
      function D() {
        let k = [], H, N, v;
        if ((!t || f(T, O, S[S.length - 1] || null)) && (k = Uy(r(T, S)), k[0] === Lf))
          return k;
        if (T.children && k[0] !== Ky)
          for (N = (o ? T.children.length : -1) + h, v = S.concat(T); N > -1 && N < T.children.length; ) {
            if (H = C(T.children[N], N, v)(), H[0] === Lf)
              return H;
            N = typeof H[1] == "number" ? H[1] : N + h;
          }
        return k;
      }
    }
  }
);
function Uy(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [By, e] : [e];
}
var Kh = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(e, t, r, o) {
    typeof t == "function" && typeof r != "function" && (o = r, r = t, t = null), Hy(e, t, f, o);
    function f(h, C) {
      const T = C[C.length - 1];
      return r(
        h,
        T ? T.children.indexOf(h) : null,
        T
      );
    }
  }
);
function Wy(e) {
  return !e || !e.position || !e.position.start || !e.position.start.line || !e.position.start.column || !e.position.end || !e.position.end.line || !e.position.end.column;
}
var Pf = {}.hasOwnProperty;
function zy(e) {
  const t = /* @__PURE__ */ Object.create(null);
  if (!e || !e.type)
    throw new Error("mdast-util-definitions expected node");
  return Kh(e, "definition", (o) => {
    const f = If(o.identifier);
    f && !Pf.call(t, f) && (t[f] = o);
  }), r;
  function r(o) {
    const f = If(o);
    return f && Pf.call(t, f) ? t[f] : null;
  }
}
function If(e) {
  return String(e || "").toUpperCase();
}
var ra = {}.hasOwnProperty;
function oN(e, t) {
  const r = t || {}, o = r.allowDangerousHtml || false, f = {};
  return C.dangerous = o, C.clobberPrefix = r.clobberPrefix === void 0 || r.clobberPrefix === null ? "user-content-" : r.clobberPrefix, C.footnoteLabel = r.footnoteLabel || "Footnotes", C.footnoteLabelTagName = r.footnoteLabelTagName || "h2", C.footnoteLabelProperties = r.footnoteLabelProperties || {
    className: ["sr-only"]
  }, C.footnoteBackLabel = r.footnoteBackLabel || "Back to content", C.unknownHandler = r.unknownHandler, C.passThrough = r.passThrough, C.handlers = { ...Py, ...r.handlers }, C.definition = zy(e), C.footnoteById = f, C.footnoteOrder = [], C.footnoteCounts = {}, C.patch = Gy, C.applyData = Yy, C.one = T, C.all = O, C.wrap = qy, C.augment = h, Kh(e, "footnoteDefinition", (S) => {
    const x = String(S.identifier).toUpperCase();
    ra.call(f, x) || (f[x] = S);
  }), C;
  function h(S, x) {
    if (S && "data" in S && S.data) {
      const D = S.data;
      D.hName && (x.type !== "element" && (x = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), x.tagName = D.hName), x.type === "element" && D.hProperties && (x.properties = { ...x.properties, ...D.hProperties }), "children" in x && x.children && D.hChildren && (x.children = D.hChildren);
    }
    if (S) {
      const D = "type" in S ? S : { position: S };
      Wy(D) || (x.position = { start: qc(D), end: Vc(D) });
    }
    return x;
  }
  function C(S, x, D, k) {
    return Array.isArray(D) && (k = D, D = {}), h(S, {
      type: "element",
      tagName: x,
      properties: D || {},
      children: k || []
    });
  }
  function T(S, x) {
    return Hh(C, S, x);
  }
  function O(S) {
    return Fi(C, S);
  }
}
function Gy(e, t) {
  e.position && (t.position = Oy(e));
}
function Yy(e, t) {
  let r = t;
  if (e && e.data) {
    const o = e.data.hName, f = e.data.hChildren, h = e.data.hProperties;
    typeof o == "string" && (r.type === "element" ? r.tagName = o : r = {
      type: "element",
      tagName: o,
      properties: {},
      children: []
    }), r.type === "element" && h && (r.properties = { ...r.properties, ...h }), "children" in r && r.children && f !== null && f !== void 0 && (r.children = f);
  }
  return r;
}
function Hh(e, t, r) {
  const o = t && t.type;
  if (!o)
    throw new Error("Expected node, got `" + t + "`");
  return ra.call(e.handlers, o) ? e.handlers[o](e, t, r) : e.passThrough && e.passThrough.includes(o) ? "children" in t ? { ...t, children: Fi(e, t) } : t : e.unknownHandler ? e.unknownHandler(e, t, r) : jy(e, t);
}
function Fi(e, t) {
  const r = [];
  if ("children" in t) {
    const o = t.children;
    let f = -1;
    for (; ++f < o.length; ) {
      const h = Hh(e, o[f], t);
      if (h) {
        if (f && o[f - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = h.value.replace(/^\s+/, "")), !Array.isArray(h) && h.type === "element")) {
          const C = h.children[0];
          C && C.type === "text" && (C.value = C.value.replace(/^\s+/, ""));
        }
        Array.isArray(h) ? r.push(...h) : r.push(h);
      }
    }
  }
  return r;
}
function jy(e, t) {
  const r = t.data || {}, o = "value" in t && !(ra.call(r, "hProperties") || ra.call(r, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: Fi(e, t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function qy(e, t) {
  const r = [];
  let o = -1;
  for (t && r.push({ type: "text", value: `
` }); ++o < e.length; )
    o && r.push({ type: "text", value: `
` }), r.push(e[o]);
  return t && e.length > 0 && r.push({ type: "text", value: `
` }), r;
}
var Vy = (e, t) => e(t, "i", Fi(e, t));
var Jy = (e, t) => e(t, "b", Fi(e, t));
var Zy = (e, t) => e(t, "u", Fi(e, t));
var Xy = (e, t) => e(t, "s", Fi(e, t));
var Qy = (e, t) => e(t, "sub", Fi(e, t));
var eC = (e, t) => e(t, "sup", Fi(e, t));
var tC = {
  emphasis: Vy,
  strong: Jy,
  underline: Zy,
  strikethrough: Xy,
  subscript: Qy,
  superscript: eC
};
var sN = (e) => {
  const [t, r] = (0, import_react.useState)();
  let o;
  return (0, import_react.useEffect)(() => {
    (async () => {
      if (!o)
        try {
          o = (await import("./index--cy1NwMF-WBJN3FPP.js")).default;
        } catch {
          throw new Error(
            "Failed to import React Markdown, cannot properly render LegacyRichText."
          );
        }
      const h = o({
        children: e.markdown,
        remarkPlugins: [ly],
        remarkRehypeOptions: {
          handlers: tC
        }
      });
      r(h);
    })();
  }, [e.markdown]), t || null;
};
var nC = [
  "sunday",
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday"
];
var kf = class {
  /**
   * @param date - the Date for the day on which the interval starts
   * @param interval - the Yext Streams interval data
   */
  constructor(t, r) {
    Ln(this, "end");
    Ln(this, "start");
    this.end = new Date(t), this.start = new Date(t), [r.start, r.end].forEach((T) => {
      if (T.split(":").length !== 2)
        throw new Error(
          'expected interval start and end data to be in the format "HH:MM"'
        );
    });
    const [o, f] = r.start.split(":"), [h, C] = r.end.split(":");
    this.end.setHours(Number(h), Number(C)), this.start.setHours(Number(o), Number(f)), this.end < this.start && this.end.setDate(this.end.getDate() + 1), this.end.getMinutes() === 59 && this.end.setMinutes(60);
  }
  /**
   * @param date - A moment in time
   * @returns True if the given moment is within the interval
   */
  contains(t) {
    return this.start <= t && t < this.end;
  }
  /**
   * @param opts - intl.DateTimeFormatOptions
   * @param locale - defaults to 'en-US'
   * @returns representation of this interval's start time
   */
  getStartTime(t, r) {
    const o = {
      hour: "numeric",
      minute: "numeric",
      ...r
    };
    return this.start.toLocaleString(t || "en-US", o);
  }
  /**
   * @param opts - intl.DateTimeFormatOptions
   * @param locale - defaults to 'en-US'
   * @returns representation of this interval's end time
   */
  getEndTime(t, r) {
    const o = {
      hour: "numeric",
      minute: "numeric",
      ...r
    };
    return this.end.toLocaleString(t || "en-US", o);
  }
  /**
   * @param other - HoursIntervalManipulator
   * @returns if this interval and 'other' have the same start/end
   */
  timeIsEqualTo(t) {
    const r = this.getStartTime() === t.getStartTime(), o = this.getEndTime() === t.getEndTime();
    return r && o;
  }
};
var rC = class {
  /**
   * @param hours - Hours object in the format returned by Yext Streams
   */
  constructor(t) {
    Ln(this, "holidayHoursByDate");
    Ln(this, "hours");
    this.holidayHoursByDate = Object.fromEntries(
      (t.holidayHours || []).map((r) => [r.date, r])
    ), this.hours = t;
  }
  /**
   * @param date - A moment in time
   * @returns The first interval that contains the given moment, null if none
   */
  getInterval(t) {
    if (this.isTemporarilyClosedAt(t))
      return null;
    const r = new Date(t);
    r.setDate(r.getDate() - 1);
    for (const o of [r, t]) {
      const f = this.getHours(o);
      if (f && !f.isClosed)
        for (const h of f.openIntervals || []) {
          const C = new kf(
            o,
            h
          );
          if (C.contains(t))
            return C;
        }
    }
    return null;
  }
  /**
   * @returns The first interval that contains the current time, null if none
   */
  getCurrentInterval() {
    return this.getInterval(/* @__PURE__ */ new Date());
  }
  /**
   * @param date - A moment in time
   * @returns The next interval that hasn't started as of the given moment
   */
  getIntervalAfter(t) {
    const r = this.getIntervalsForNDays(8, t), o = (h, C) => h.start === C.start ? 0 : h.start > C.start ? 1 : -1, f = r.sort(o);
    for (const [h, C] of f.entries())
      if (C.contains(t) && f.length > h + 1)
        return f[h + 1];
    for (const h of f)
      if (h.start > t)
        return h;
    return null;
  }
  /**
   * @returns The next interval that hasn't started as of the current time
   */
  getNextInterval() {
    return this.getIntervalAfter(/* @__PURE__ */ new Date());
  }
  /**
   * @param n - number of days to check
   * @param startDate - first day to check
   * @returns list of intervals in range [startDate, startDate+7]
   */
  getIntervalsForNDays(t, r) {
    const o = [];
    for (let f = 0; f < t; f++) {
      const h = new Date(r);
      h.setDate(h.getDate() + f);
      const C = this.getHours(h);
      C && !C.isClosed && o.push(
        ...C.openIntervals.map(
          (T) => new kf(h, T)
        )
      );
    }
    return o;
  }
  /**
   * @param date - The day to get the hours for
   * @returns The daily holiday hours object from the original Streams response for the
   *   given date, null if none
   */
  getHolidayHours(t) {
    return this.isTemporarilyClosedAt(t) ? null : this.holidayHoursByDate[this.transformDateToYext(t)] || null;
  }
  /**
   * @param date - The day to get the hours for
   * @returns The daily normal hours object from the original Streams response for the
   *   given date, null if none
   */
  getNormalHours(t) {
    return this.isTemporarilyClosedAt(t) ? null : this.hours[nC[t.getDay()]];
  }
  /**
   * @param date - The day to get the hours for
   * @returns The daily hours object from the original Streams response for the given
   *   date, null if none
   */
  getHours(t) {
    const r = this.getHolidayHours(t);
    return !r || r.isRegularHours ? this.getNormalHours(t) : r;
  }
  /**
   * @param date - A day
   * @returns True if the given day has holiday hours
   */
  isHoliday(t) {
    return !!this.getHolidayHours(t);
  }
  /**
   * Yext platform uses the field `hours.reopenDate` to indicate an entity is
   *  temporarily closed for more than one day.
   * @param targetDate - the date to check against
   * @returns True if the given date is before 'reopenDate'
   */
  isTemporarilyClosedAt(t) {
    return this.hours.reopenDate ? this.transformDateToYext(t) < this.hours.reopenDate : false;
  }
  /**
   * @param date - A moment in time
   * @returns True if the given moment falls within any interval
   */
  isOpenAt(t) {
    return this.isTemporarilyClosedAt(t) ? false : !!this.getInterval(t);
  }
  /**
   * @returns True if the current time falls within any interval
   */
  isOpenNow() {
    return this.isOpenAt(/* @__PURE__ */ new Date());
  }
  /**
   * Convert ISO Date which have 1-based months, to Yext date string which have 0-based months
   * @param date - a moment in time
   * @returns a Yext date string
   */
  transformDateToYext(t) {
    const [r, o, f] = t.toISOString().split("T")[0].split("-"), h = Number(o) - 1, C = h < 10 ? "0" + h : h.toString();
    return `${r}-${C}-${f}`;
  }
};
function $f(e, t) {
  const r = [...e];
  return t = t % r.length, r.concat(r.splice(0, r.length - t));
}
function iC(e, t) {
  if (e.length !== t.length)
    return false;
  for (const [r, o] of e.entries())
    if (!o.timeIsEqualTo(t[r]))
      return false;
  return true;
}
var Ii = [
  "sunday",
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday"
];
var yc = [0, 1, 2, 3, 4, 5, 6];
function oC(e, t) {
  let r = 0;
  return e.startOfWeek === "today" ? (r = t.getDay(), $f(yc, r)) : e.startOfWeek ? (r = Ii.indexOf(e.startOfWeek), $f(yc, r)) : yc;
}
function sC(e) {
  const t = [];
  return e.forEach((r) => {
    const o = t[t.length - 1];
    o ? iC(o.intervals, r.intervals) ? (o.endDay = r.dayOfWeek, o.isToday = o.isToday || r.isToday) : t.push({
      startDay: r.dayOfWeek,
      endDay: r.dayOfWeek,
      ...r
    }) : t.push({
      startDay: r.dayOfWeek,
      endDay: r.dayOfWeek,
      ...r
    });
  }), t.map((r) => ({
    ...r,
    dayOfWeek: r.startDay === r.endDay ? `${r.startDay}` : `${r.startDay} - ${r.endDay}`
  }));
}
function lC(e, t) {
  const r = [];
  return e.intervals.length === 0 ? r.push("Closed") : e.intervals.forEach((o) => {
    const f = o.getStartTime("en-US", t), h = o.getEndTime("en-US", t);
    r.push(`${f} - ${h}`);
  }), r;
}
function aC(e) {
  return [
    e.sunday || Ii[0],
    e.monday || Ii[1],
    e.tuesday || Ii[2],
    e.wednesday || Ii[3],
    e.thursday || Ii[4],
    e.friday || Ii[5],
    e.saturday || Ii[6]
  ];
}
var lN = (e) => {
  const [t, r] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    r(true);
  }, []);
  const o = new rC(e.hours), f = /* @__PURE__ */ new Date(), h = e.dayOfWeekNames ? aC(e.dayOfWeekNames) : Ii, C = oC(e, /* @__PURE__ */ new Date()), T = o.getIntervalsForNDays(7, f);
  let O = [];
  for (let x = 0; x < 7; x++)
    O.push({
      dayOfWeek: h[x],
      sortIdx: C[x],
      intervals: T.filter(
        (D) => D.start.getDay() === x
      ),
      isToday: f.getDay() === x
    });
  const S = (x, D) => x.sortIdx === D.sortIdx ? 0 : x.sortIdx > D.sortIdx ? 1 : -1;
  return O.sort(S), e.collapseDays && (O = sC(O)), yt.jsx(yt.Fragment, { children: t && yt.jsx("div", { className: Ql("HoursTable", e.className), children: O.map((x) => {
    const k = (e.intervalStringsBuilderFn || lC)(
      x,
      e.timeOptions
    );
    return yt.jsxs(
      "div",
      {
        className: Ql("HoursTable-row", { "is-today": x.isToday }),
        children: [
          yt.jsx("span", { className: "HoursTable-day", children: x.dayOfWeek }),
          yt.jsx("span", { className: "HoursTable-intervals", children: k.map((H, N) => yt.jsx("span", { className: "HoursTable-interval", children: H }, N)) })
        ]
      },
      x.sortIdx
    );
  }) }) });
};
var Rc = Math.log2(1.6745627884839434);
var cC = 4;
var uC = 19;
var Dc = "js-baidu-neg-lng-fix";
var Uh;
var dC = new Promise((e) => Uh = e);
var fC = "https://api.map.baidu.com/geoconv/v1/";
var il = [];
var hC = "gcj02ToBD09Callback_b872c21c";
var gC = 0;
var Ff;
async function Wh(e) {
  return await new Promise((t, r) => {
    il.push({ coordinates: e, resolve: t, reject: r }), il.length === 1 && (Ff = setTimeout(o, 100)), il.length > 40 && (clearTimeout(Ff), o());
    function o() {
      const f = il;
      il = [];
      const h = [].concat(
        ...f.map((O) => O.coordinates)
      ), C = hC + "_" + gC++, T = document.createElement("script");
      window[C] = (O) => {
        if (O.status) {
          const D = new Error(
            `Unable to convert coordinates to BD-09: Received status code ${O.status}${O.message ? ": " + O.message : ""}`
          );
          f.forEach((k) => k.reject(D));
        }
        const S = O.result.map(
          (D) => new Vt(D.y, D.x)
        );
        let x = 0;
        f.forEach((D) => {
          D.resolve(
            S.slice(
              x,
              x += D.coordinates.length
            )
          );
        }), delete window[C], T.parentNode.removeChild(T);
      }, dC.then((O) => {
        const S = {
          ak: O,
          callback: C,
          coords: h.map(
            (x) => `${x.longitude},${x.latitude}`
          ).join(";"),
          from: 3,
          to: 5
        };
        T.src = fC + "?" + Object.entries(S).map(([x, D]) => x + "=" + D).join("&"), document.head.appendChild(T);
      });
    }
  });
}
var pC = class extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t);
    const r = !!(window.MSInputMethodContext && document.documentMode);
    this._wrapper = t.wrapper, this.map = new BMap.Map(this._wrapper, {
      enableMapClick: t.controlEnabled,
      // A side effect of the negative pin longitude glitch is that pins don't render at higher zoom levels.
      // For IE, 15 and above is broken. For other browsers, 19 and above.
      maxZoom: r ? 14 : 18,
      ...t.providerOptions
    }), t.controlEnabled ? (this.map.enableScrollWheelZoom(), this.map.addControl(
      new BMap.NavigationControl({
        anchor: BMAP_ANCHOR_TOP_RIGHT,
        type: BMAP_NAVIGATION_CONTROL_ZOOM
      })
    )) : (this.map.disableDragging(), this.map.disableDoubleClickZoom(), this.map.disablePinchToZoom()), this.map.addEventListener("movestart", () => this._panStartHandler()), this.map.addEventListener("moveend", () => this._panHandler()), this.map.addEventListener("zoomstart", () => this._panStartHandler()), this.map.addEventListener("zoomend", () => {
      this._wrapper.dataset.baiduZoom = this.map.getZoom(), this._panHandler();
    }), this._centerReady = Promise.resolve();
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() - Rc;
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    this._centerReady = Wh([t]).then(([o]) => {
      const f = new BMap.Point(
        o.longitude,
        o.latitude
      );
      this.map.panTo(f, { noAnimation: !r });
    });
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this._centerReady.then(() => {
      this.map.setViewport(
        {
          center: this.map.getCenter(),
          zoom: Math.floor(t + Rc)
          // Baidu only allows integer zoom
        },
        { enableAnimation: r }
      );
    });
  }
};
var _C = class extends sa {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._wrapper = null, this._zIndex = 0, this._wrapperClass = "", this._originalWrapperClass = "", this._element = this._pinEl, this._coordinateReady = Promise.resolve(), this._negativeLngFix = false;
    const r = this;
    class o extends BMap.Marker {
      initialize(C) {
        return r._wrapper = super.initialize(C), r._wrapper && (r._wrapper.style.zIndex = r._zIndex, r._originalWrapperClass = r._wrapper.getAttribute("class"), r._wrapper.setAttribute("class", r._getClass()), r._wrapper.appendChild(r._element), r.addListeners()), r._wrapper;
      }
      draw() {
        if (r._wrapper) {
          const C = r._wrapper.style.zIndex;
          super.draw(), r._wrapper.style.height = "", r._wrapper.style.width = "", r._wrapper.style.pointerEvents = "none", r._wrapper.style.zIndex = C;
        } else
          super.draw();
      }
    }
    this.pin = new o(new BMap.Point(0, 0));
    const f = new BMap.Icon(
      "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
      { height: 0, width: 0 }
    );
    this.pin.setIcon(f), this.pin.setShadow(f);
  }
  /**
   * @inheritdoc
   */
  addListeners() {
    super.addListeners(), this._wrapper.addEventListener("touchend", () => this._clickHandler());
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this._coordinateReady = Wh([t]).then(
      ([r]) => {
        this._negativeLngFix = r.longitude < 0, this.pin.setPosition(
          new BMap.Point(
            r.longitude + (this._negativeLngFix ? 180 : 0),
            r.latitude
          )
        ), this._wrapper && this._wrapper.classList[this._negativeLngFix ? "add" : "remove"](
          Dc
        );
      }
    );
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    this._coordinateReady.then(() => {
      r && r.getProviderMap().map.removeOverlay(this.pin), t && t.getProviderMap().map.addOverlay(this.pin);
    });
  }
  /**
   * @inheritdoc
   */
  setProperties(t) {
    super.setProperties(t), this._wrapperClass = t.getClass(), this._element = t.getElement() || this._pinEl, this._zIndex = t.getZIndex(), this._wrapper && this._wrapper.setAttribute("class", this._getClass());
  }
  /**
   * Get the class attribute value for the pin element
   * @protected
   * @returns {string}
   */
  _getClass() {
    return `${this._originalWrapperClass} ${this._negativeLngFix ? Dc : ""} ${this._wrapperClass}`;
  }
};
var mC = "https://api.map.baidu.com/getscript";
function yC(e, t, r, { params: o = {}, version: f = "3.0" } = {}) {
  window.BMAP_PROTOCOL = "https", window.BMap_loadScriptTime = (/* @__PURE__ */ new Date()).getTime();
  const h = r, C = {
    ak: h,
    v: f,
    ...o
  };
  Uh(h);
  const T = document.createElement("script");
  T.src = mC + "?" + Object.entries(C).map(([x, D]) => x + "=" + D).join("&"), T.onload = () => e(), document.head.appendChild(T);
  let O = "";
  for (let x = cC; x <= uC; x++) {
    const D = 2 ** (x - Rc + 7);
    O += `[data-baidu-zoom="${x}"] .${Dc}{transform:translateX(-${D}px);}`;
  }
  const S = document.createElement("style");
  S.innerHTML = O, document.head.appendChild(S);
}
var aN = new Bo().withLoadFunction(yC).withMapClass(pC).withPinClass(_C).withProviderName("Baidu").build();
var zh;
function CC() {
  class e extends Microsoft.Maps.CustomOverlay {
    constructor() {
      super({ beneathLabels: false }), this._container = document.createElement("div"), this._map = null, this._pins = /* @__PURE__ */ new Set(), this._viewChangeEventHandler = null, this._container.style.position = "absolute", this._container.style.left = "0", this._container.style.top = "0";
    }
    addPin(r) {
      this._pins.add(r), r._wrapper.style.position = "absolute", this._container.appendChild(r._wrapper), this._map && this.updatePinPosition(r);
    }
    onAdd() {
      this._map = this.getMap(), this.setHtmlElement(this._container);
    }
    onLoad() {
      this._viewChangeEventHandler = Microsoft.Maps.Events.addHandler(
        this._map,
        "viewchange",
        () => this.updatePinPositions()
      ), this.updatePinPositions();
    }
    onRemove() {
      Microsoft.Maps.Events.removeHandler(this._viewChangeEventHandler), this._map = null;
    }
    removePin(r) {
      this._pins.delete(r), this._container.removeChild(r._wrapper);
    }
    updatePinPosition(r) {
      if (!this._map)
        return;
      const o = this._map.tryLocationToPixel(
        r._location,
        Microsoft.Maps.PixelReference.control
      );
      r._wrapper.style.left = o.x + "px", r._wrapper.style.top = o.y + "px";
    }
    updatePinPositions() {
      this._pins.forEach((r) => this.updatePinPosition(r));
    }
  }
  zh = e;
}
var NC = class extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t), this.wrapper = t.wrapper, this.map = new Microsoft.Maps.Map(this.wrapper, {
      disablePanning: !t.controlEnabled,
      disableZooming: !t.controlEnabled,
      showLocateMeButton: false,
      showMapTypeSelector: false,
      showScalebar: false,
      showTrafficButton: false,
      ...t.providerOptions
    }), this.pinOverlay = new zh(this.map), this.map.layers.insert(this.pinOverlay), Microsoft.Maps.Events.addHandler(
      this.map,
      "viewchangestart",
      () => this._panStartHandler()
    ), Microsoft.Maps.Events.addHandler(
      this.map,
      "viewchangeend",
      () => this._panHandler()
    );
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new Microsoft.Maps.Location(
      t.latitude,
      t.longitude
    );
    this.map.setView({ center: o }), this.pinOverlay.updatePinPositions();
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map.setView({ zoom: Math.floor(t) }), this.pinOverlay.updatePinPositions();
  }
};
var EC = class extends sa {
  /**
   * Bing pins need global callbacks to complete initialization.
   * This function provides a unique ID to include in the name of the callback.
   * @returns {number} An ID for the pin unique across all instances of {@link module:@yext/components-maps~BingPin BingPin}
   */
  static getId() {
    return this._pinId = (this._pinId || 0) + 1, this._pinId;
  }
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._map = null, this._location = new Microsoft.Maps.Location(0, 0);
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this._location = new Microsoft.Maps.Location(
      t.latitude,
      t.longitude
    ), this._map && this._map.getProviderMap().pinOverlay.updatePinPosition(this);
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    r && r.getProviderMap().pinOverlay.removePin(this), t && t.getProviderMap().pinOverlay.addPin(this), this._map = t;
  }
};
var Bf = "BingMapsCallback_593d7d33";
var TC = "https://www.bing.com/api/maps/mapcontrol";
function xC(e, t, r, { params: o = {} } = {}) {
  window[Bf] = () => {
    CC(), e();
  };
  const f = {
    callback: Bf,
    key: r,
    ...o
  };
  Xf(
    TC + "?" + Object.entries(f).map(([h, C]) => h + "=" + C).join("&")
  );
}
var cN = new Bo().withLoadFunction(xC).withMapClass(NC).withPinClass(EC).withProviderName("Bing").build();
var vC = class extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    if (super(t), this.map = new mapboxgl.Map({
      container: t.wrapper,
      interactive: t.controlEnabled,
      style: "mapbox://styles/mapbox/streets-v9",
      ...t.providerOptions
    }), t.controlEnabled) {
      const r = new mapboxgl.NavigationControl({
        showCompass: false
      });
      this.map.addControl(r);
    }
    this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom() + 1;
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new mapboxgl.LngLat(
      t.longitude,
      t.latitude
    );
    this.map[r ? "panTo" : "setCenter"](o);
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map[r ? "zoomTo" : "setZoom"](t - 1);
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(t, r, o) {
    const f = new mapboxgl.LngLat(
      r.longitude,
      r.latitude
    );
    this.map[o ? "easeTo" : "jumpTo"]({ center: f, zoom: t - 1 });
  }
};
var SC = class extends sa {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this._wrapper.style.position = "relative", this.pin = new mapboxgl.Marker({
      anchor: "top-left",
      element: this._wrapper
    });
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    this.pin.setLngLat(
      new mapboxgl.LngLat(t.longitude, t.latitude)
    );
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    t ? this.pin.addTo(t.getProviderMap().map) : this.pin.remove();
  }
};
function wC(e, t, r, { version: o = "v1.13.0" } = {}) {
  const f = `https://api.mapbox.com/mapbox-gl-js/${o}/mapbox-gl`, h = document.createElement("link");
  h.rel = "stylesheet", h.href = f + ".css";
  const C = document.createElement("script");
  C.src = f + ".js", C.onload = () => {
    mapboxgl.accessToken = r, e();
  }, document.head.appendChild(h), document.head.appendChild(C);
}
var uN = new Bo().withLoadFunction(wC).withMapClass(vC).withPinClass(SC).withProviderName("Mapbox").build();
var Gh = class extends Es {
  /**
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  constructor(t) {
    super(t), this._initMap(t), t.controlEnabled && this.map.zoomControl.setPosition("topright"), this.map.on("movestart", () => this._panStartHandler()), this.map.on("moveend", () => this._panHandler());
  }
  /**
   * @inheritdoc
   */
  getCenter() {
    return new Vt(this.map.getCenter());
  }
  /**
   * @inheritdoc
   */
  getZoom() {
    return this.map.getZoom();
  }
  /**
   * @inheritdoc
   */
  setCenter(t, r) {
    const o = new L.latLng(t.latitude, t.longitude);
    this.map.panTo(o, { animate: r });
  }
  /**
   * @inheritdoc
   */
  setZoom(t, r) {
    this.map.setZoom(t, { animate: r });
  }
  /**
   * @inheritdoc
   */
  setZoomCenter(t, r, o) {
    const f = new L.latLng(r.latitude, r.longitude);
    this.map.setView(f, t, { animate: o });
  }
  /**
   * Initialize the Leaflet map
   * @protected
   * @param {module:@yext/components-maps~ProviderMapOptions} options
   */
  _initMap(t) {
    this.map = new L.map(t.wrapper, {
      boxZoom: t.controlEnabled,
      doubleClickZoom: t.controlEnabled,
      dragging: t.controlEnabled,
      zoom: 0,
      zoomControl: t.controlEnabled,
      zoomSnap: 0,
      ...t.providerOptions
    });
    const r = t.providerOptions, o = r.tileLayerSrc || "https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}", f = r.tileLayerOptions || {
      attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
      id: "mapbox/streets-v11"
    };
    f.accessToken = this.constructor.apiKey, L.tileLayer(o, f).addTo(this.map);
  }
};
var OC = class extends Lc {
  /**
   * @param {module:@yext/components-maps~ProviderPinOptions} options
   */
  constructor(t) {
    super(t), this.pin = new L.marker(), this.pin.on("click", () => this._clickHandler()), this.pin.on("mouseover", () => this._hoverHandler(true)), this.pin.on("mouseout", () => this._hoverHandler(false));
  }
  /**
   * @inheritdoc
   */
  setCoordinate(t) {
    const r = new L.latLng(t.latitude, t.longitude);
    this.pin.setLatLng(r);
  }
  /**
   * @inheritdoc
   */
  setMap(t, r) {
    t ? this.pin.addTo(t.getProviderMap().map) : this.pin.remove();
  }
  /**
   * @inheritdoc
   */
  setProperties(t) {
    const r = t.getWidth(), o = t.getHeight(), f = t.getAnchorX(), h = t.getAnchorY();
    this.pin.setIcon(
      new L.icon({
        iconUrl: this._icons[t.getIcon()],
        iconSize: [r, o],
        iconAnchor: [f * r, h * o],
        className: t.getClass()
      })
    ), this.pin.setZIndexOffset(t.getZIndex());
  }
};
function RC(e, t, r, { version: o = "1.7.1" } = {}) {
  const f = `https://unpkg.com/leaflet@${o}/dist/leaflet`;
  Gh.apiKey = r;
  const h = document.createElement("link");
  h.rel = "stylesheet", h.href = f + ".css";
  const C = document.createElement("script");
  C.src = f + ".js", C.onload = () => e(), document.head.appendChild(h), document.head.appendChild(C);
}
var Yh = new Bo().withLoadFunction(RC).withMapClass(Gh).withPinClass(OC).withProviderName("Leaflet").build();
var DC = Yh.getMapClass();
var AC = Yh.getPinClass();
var bC = class extends DC {
  /**
   * @inheritdoc
   */
  _initMap(t) {
    this.map = L.mapquest.map(t.wrapper, {
      boxZoom: t.controlEnabled,
      center: new L.latLng(0, 0),
      doubleClickZoom: t.controlEnabled,
      dragging: t.controlEnabled,
      layers: L.mapquest.tileLayer("map"),
      zoom: 0,
      zoomControl: t.controlEnabled,
      zoomSnap: 0,
      ...t.providerOptions
    });
  }
};
var MC = class extends AC {
};
function LC(e, t, r, { version: o = "v1.3.2" } = {}) {
  const f = `https://api.mqcdn.com/sdk/mapquest-js/${o}/mapquest-maps`, h = document.createElement("link");
  h.rel = "stylesheet", h.href = f + ".css";
  const C = document.createElement("script");
  C.src = f + ".js", C.onload = () => {
    L.mapquest.key = r, e();
  }, document.head.appendChild(h), document.head.appendChild(C);
}
var hN = new Bo().withLoadFunction(LC).withMapClass(bC).withPinClass(MC).withProviderName("MapQuest").build();

export {
  bc,
  Pg,
  Tu,
  $C,
  FC,
  fp,
  Yf,
  qf,
  BC,
  oa,
  KC,
  HC,
  UC,
  WC,
  ko,
  zC,
  xp,
  GC,
  th,
  jC,
  ih,
  qC,
  VC,
  kc,
  Bp,
  JC,
  Wc,
  rl,
  Nm,
  ZC,
  Rf,
  XC,
  QC,
  eN,
  tN,
  nN,
  rN,
  bm,
  iN,
  ta,
  Im,
  al,
  Kh,
  oN,
  sN,
  rC,
  lN,
  aN,
  cN,
  uN,
  Yh,
  hN
};
/*! Bundled license information:

@yext/pages-components/dist/index-i0mhhNq7.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@yext/pages-components/dist/index-i0mhhNq7.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@yext/pages-components/dist/index-i0mhhNq7.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

@yext/pages-components/dist/index-i0mhhNq7.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=chunk-QXIFOUKC.js.map
